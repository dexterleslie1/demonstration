# 连接池



## `dbcp`



### 概述

DBCP（Database Connection Pool）是 Apache 软件基金会旗下的一个**开源数据库连接池实现**，属于 Jakarta Commons 项目的一部分（目前最新版本为 DBCP 2.x，DBCP 1.x 已停止维护）。它通过预先创建并管理一组数据库连接，避免了频繁创建和销毁连接带来的性能开销，显著提升了数据库操作的效率和应用的稳定性。

---

**一、为什么需要连接池？**

传统的数据库操作中，每次执行 SQL 都需要手动创建连接（`DriverManager.getConnection()`），操作完成后关闭连接。这种方式存在以下问题：
- **性能损耗**：建立 TCP 连接、数据库认证等过程耗时较长（通常需要几十到几百毫秒）。
- **资源浪费**：频繁创建/销毁连接会增加系统开销，尤其在高并发场景下可能导致资源耗尽。
- **连接不可控**：无法限制最大连接数，可能导致数据库因连接过多而崩溃。

连接池的核心思想是**复用连接**：预先创建一定数量的连接存入池中，应用需要连接时从池中“借用”，用完后“归还”（而非真正关闭），从而减少开销并控制连接数量。

---

**二、DBCP 核心组件**

DBCP 的核心类是 `BasicDataSource`（实现了 `DataSource` 接口），它负责管理连接的生命周期。主要功能包括：
- **连接创建**：按需创建新连接，直到达到最大连接数限制。
- **连接复用**：从池中获取空闲连接，避免重复创建。
- **连接验证**：确保归还的连接仍然有效（避免数据库断开导致脏连接）。
- **连接回收**：主动或被动回收超时、空闲或失效的连接。

**1. 核心配置参数**

通过配置 `BasicDataSource` 的属性，可以灵活控制连接池行为。以下是常用参数：

| 参数名                          | 说明                                                         | 默认值           |
| ------------------------------- | ------------------------------------------------------------ | ---------------- |
| `driverClassName`               | 数据库驱动类名（如 `com.mysql.cj.jdbc.Driver`）              | 无（需手动加载） |
| `url`                           | 数据库连接 URL                                               | 无               |
| `username`                      | 数据库用户名                                                 | 无               |
| `password`                      | 数据库密码                                                   | 无               |
| `initialSize`                   | 初始化时创建的连接数                                         | 0                |
| `maxTotal`                      | 连接池允许的最大连接数（关键限制）                           | 8                |
| `maxIdle`                       | 连接池中允许的最大空闲连接数                                 | 8                |
| `minIdle`                       | 连接池中保持的最小空闲连接数（避免频繁创建）                 | 0                |
| `maxWaitMillis`                 | 从池中获取连接的最大等待时间（毫秒，超时抛异常）             | -1（无限等待）   |
| `validationQuery`               | 验证连接有效性的 SQL（如 MySQL 的 `SELECT 1`，Oracle 的 `SELECT 1 FROM DUAL`） | 无               |
| `testOnBorrow`                  | 借用连接时是否验证（`true` 则每次取连接前校验，可能影响性能） | false            |
| `testWhileIdle`                 | 空闲时是否验证（配合 `timeBetweenEvictionRunsMillis` 使用，推荐） | false            |
| `timeBetweenEvictionRunsMillis` | 检测空闲连接的间隔时间（毫秒，用于回收失效连接）             | -1（不检测）     |
| `removeAbandonedTimeout`        | 连接被标记为“废弃”的超时时间（秒，超过此时间未关闭的连接会被强制回收） | 300（5分钟）     |
| `logAbandoned`                  | 是否记录“废弃连接”的堆栈信息（用于排查连接泄漏）             | false            |

**2. 关键方法**

- `getConnection()`：从池中获取一个连接（可能阻塞直到超时）。
- `close()`：关闭数据源（释放所有连接）。
- `getNumActive()`：当前活跃连接数（正在使用的连接）。
- `getNumIdle()`：当前空闲连接数（池中可用的连接）。

---

**三、使用步骤（以 DBCP 2.x 为例）**

**1. 添加依赖**

在 Maven 项目中，添加 `commons-dbcp2` 和数据库驱动（如 MySQL）的依赖：
```xml
<!-- DBCP 2.x -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-dbcp2</artifactId>
    <version>2.9.0</version>
</dependency>

<!-- MySQL 驱动（示例） -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
```

**2. 配置数据源**

通过代码或配置文件初始化 `BasicDataSource`。推荐通过 `BasicDataSourceFactory` 加载配置（支持 XML 或 Properties 文件）。

**示例：代码中直接配置**
```java
import org.apache.commons.dbcp2.BasicDataSource;
import javax.sql.DataSource;

public class DBCPExample {
    public static void main(String[] args) throws Exception {
        // 1. 创建 BasicDataSource 实例
        BasicDataSource dataSource = new BasicDataSource();

        // 2. 配置基本参数
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC");
        dataSource.setUsername("root");
        dataSource.setPassword("123456");

        // 3. 配置连接池参数
        dataSource.setInitialSize(5);      // 初始化5个连接
        dataSource.setMaxTotal(20);        // 最大20个连接
        dataSource.setMaxIdle(10);         // 最大空闲10个
        dataSource.setMinIdle(5);          // 最小空闲5个
        dataSource.setMaxWaitMillis(3000); // 等待超时3秒
        dataSource.setValidationQuery("SELECT 1"); // 验证SQL
        dataSource.setTestWhileIdle(true);       // 空闲时验证
        dataSource.setTimeBetweenEvictionRunsMillis(60000); // 每分钟检测一次

        // 4. 获取连接并使用
        try (Connection conn = dataSource.getConnection()) {
            // 执行SQL操作...
            System.out.println("连接成功：" + conn);
        } // 自动关闭连接（归还给池）

        // 5. 关闭数据源（应用退出时）
        dataSource.close();
    }
}
```

**示例：通过 Properties 文件配置**
创建 `dbcp.properties`：
```properties
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC
username=root
password=123456
initialSize=5
maxTotal=20
maxIdle=10
minIdle=5
maxWaitMillis=3000
validationQuery=SELECT 1
testWhileIdle=true
timeBetweenEvictionRunsMillis=60000
```

代码中加载配置：
```java
import org.apache.commons.dbcp2.BasicDataSourceFactory;
import javax.sql.DataSource;
import java.util.Properties;
import java.io.FileInputStream;

public class DBCPExample {
    public static void main(String[] args) throws Exception {
        Properties props = new Properties();
        props.load(new FileInputStream("dbcp.properties"));
        DataSource dataSource = BasicDataSourceFactory.createDataSource(props);
        // 使用 dataSource...
    }
}
```

---

**四、DBCP 的优缺点**

**优点**

- **成熟稳定**：Apache 项目，长期维护，适合企业级场景。
- **配置灵活**：支持丰富的参数调优（如连接验证、空闲回收）。
- **线程安全**：`BasicDataSource` 是线程安全的，可被多线程共享。
- **监控支持**：提供 `getNumActive()`、`getNumIdle()` 等方法监控连接状态。

**缺点**

- **配置复杂度**：参数较多，新手容易配置不当（如连接数不足或过多）。
- **性能瓶颈**：高并发场景下，性能可能不如 HikariCP、Druid 等新兴连接池（DBCP 2.x 已优化，但仍有一定差距）。
- **功能扩展有限**：相比 Druid，缺少 SQL 监控、慢查询日志等高级功能。

---

**五、注意事项**

1. **连接泄漏**：必须确保从 `getConnection()` 获取的连接最终被关闭（通过 `try-with-resources` 或 `finally` 块），否则连接无法归还池，导致池耗尽。
   ```java
   // 错误示例：未关闭连接
   Connection conn = dataSource.getConnection();
   // ...操作后忘记关闭
   
   // 正确示例：使用 try-with-resources（Java 7+）
   try (Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM user")) {
       // 处理结果...
   } // 自动关闭 rs、stmt、conn
   ```

2. **验证连接有效性**：生产环境建议启用 `testWhileIdle` 并设置合理的 `validationQuery`，避免从池中获取到已失效的连接（如数据库重启后）。

3. **合理设置连接数**：
   - `maxTotal` 不宜过大（建议不超过数据库的最大连接数，默认通常为 151）。
   - `minIdle` 应根据业务低峰期的连接需求设置，避免频繁创建连接。

4. **监控与调优**：通过 `getNumActive()`、`getNumIdle()` 监控连接使用情况，调整参数以适应业务负载（如高峰期增加 `maxTotal`）。

---

**六、总结**

DBCP 是一个经典且稳定的数据库连接池，适合对稳定性要求高、配置相对简单的场景。尽管在高并发场景下性能可能不如新兴连接池，但通过合理配置（如连接数、验证策略），仍能有效提升数据库操作的效率。对于需要高级监控或更高性能的场景，可考虑 Druid 或 HikariCP，但 DBCP 仍是学习和中小型项目的可靠选择。



### `Spring Boot` 集成

>详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-spring-boot/demo-spring-boot-dbcp)

`POM` 配置：

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-dbcp2</artifactId>
</dependency>
```

- 如果有 `mybatis` 依赖，需要排除 `HikariCP`

  ```xml
  <!-- mybatis依赖 -->
  <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>2.3.2</version>
      <!-- 排除使用 HikariCP 连接池 -->
      <exclusions>
          <exclusion>
              <groupId>com.zaxxer</groupId>
              <artifactId>HikariCP</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  ```

`application.properties` 配置：

```properties
spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/demo?allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=123456

# 初始化连接数
spring.datasource.dbcp2.initial-size=8
# 最大连接数
spring.datasource.dbcp2.max-total=128
# 最大空闲连接数
spring.datasource.dbcp2.max-idle=32
# 最小空闲连接数
spring.datasource.dbcp2.min-idle=8
# 获取连接最大等待时间（毫秒）
spring.datasource.dbcp2.max-wait-millis=3000
# 验证连接有效性的 SQL
spring.datasource.dbcp2.validation-query=SELECT 1
# 空闲时验证连接
spring.datasource.dbcp2.test-while-idle=true
# 空闲连接检测间隔（毫秒）
spring.datasource.dbcp2.time-between-eviction-runs-millis=30000
# 每次 test-while-idle 时验证所有空闲连接
spring.datasource.dbcp2.num-tests-per-eviction-run=-1
# 从连接池借用连接时是否验证连接有效性
spring.datasource.dbcp2.test-on-borrow=false
# 连接归还时是否验证有效性
spring.datasource.dbcp2.test-on-return=false
```



### 配置参数

#### `initialSize`

在 Apache Commons DBCP2（数据库连接池）中，`initialSize` 是一个关键配置参数，用于控制**连接池初始化时预创建的数据库连接数量**。其核心作用是优化应用的启动性能，避免首次请求连接时的延迟。以下是其详细作用的解析：

**1. 核心作用：预创建连接，减少初始延迟**

当应用启动并初始化连接池时，`initialSize` 决定了池会**预先创建多少个可用的数据库连接**。这些连接在池初始化完成后即处于“空闲”状态，等待被应用获取使用。  
- **场景**：若 `initialSize` 设为 5，则池启动后会立即建立 5 个连接，无需等待应用首次请求时再动态创建。这显著减少了首次请求的等待时间（尤其是数据库连接建立耗时较长时）。  
- **对比默认值**：若 `initialSize` 未设置（默认值为 0），则连接池启动时为空，第一个连接请求会触发动态创建连接（直到达到 `maxActive` 限制），可能导致首次请求延迟较高。  

**2. 与其他参数的协同作用**

`initialSize` 需结合其他核心参数共同管理连接池的行为：

（1）与 `maxActive`（或 `maxTotal`，新版本）的关系  

`maxActive` 定义了连接池允许的最大**活跃连接数**（即同时被使用的连接数）。`initialSize` 不能超过 `maxActive`，否则会被自动限制为 `maxActive` 的值。例如：  
- 若 `maxActive=10`，但 `initialSize=15`，则池初始化时仅会创建 10 个连接（不超过 `maxActive` 上限）。

（2）与 `minIdle`（最小空闲连接数）的关系  

`minIdle` 定义了连接池希望维持的**最小空闲连接数**（即使没有请求，也会尽量保持这么多空闲连接）。`initialSize` 影响初始空闲连接数，但最终会被 `minIdle` 调整：  
- 若 `initialSize > minIdle`：池初始化后空闲连接数为 `initialSize`，但随着时间推移（如连接被释放或超时），若空闲连接数超过 `minIdle`，池会通过**连接回收策略**（由 `timeBetweenEvictionRunsMillis` 控制）逐步关闭多余连接，最终稳定在 `minIdle` 附近。  
- 若 `initialSize < minIdle`：池初始化后空闲连接数为 `initialSize`，但为了满足 `minIdle` 要求，池会主动创建新的空闲连接（直到达到 `maxActive` 上限）。  

**3. 动态调整示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setInitialSize(5);   // 初始创建 5 个连接
dataSource.setMaxActive(20);    // 最大允许 20 个活跃连接
dataSource.setMinIdle(3);       // 至少保持 3 个空闲连接
```

- **启动阶段**：池立即创建 5 个连接，此时空闲连接数为 5（活跃连接数为 0）。  
- **应用运行中**：  
  - 若应用获取 4 个连接（活跃数=4），则空闲数=5-4=1。由于 `minIdle=3`，池会检测到空闲连接不足，主动创建 2 个新连接（总活跃数仍为 4，空闲数变为 3），直到空闲数≥`minIdle`。  
  - 若应用释放所有连接（活跃数=0），空闲数=20（未超过 `maxActive`），但由于 `minIdle=3`，池不会主动关闭连接（除非超过 `maxActive` 或触发超时回收）。  

**4. 最佳实践建议**

- **根据初始负载设置**：若应用启动后短时间内有高并发请求（如批量任务），可将 `initialSize` 设为预期初始活跃连接数（如 5-10），避免首次请求排队等待。  
- **避免过度预创建**：`initialSize` 过大会导致数据库服务器资源（如连接数、内存）被过早占用，需结合数据库的最大连接数限制（如 MySQL 的 `max_connections`）。  
- **长期维护靠 `minIdle`**：`initialSize` 主要解决“启动延迟”问题，长期空闲连接的维护应通过 `minIdle` 控制（确保日常请求有足够的空闲连接可用）。  

**总结**  

`initialSize` 是 DBCP2 连接池的“预热”参数，通过预创建连接减少应用启动或首次请求时的延迟。它需与 `maxActive`（控制最大容量）和 `minIdle`（控制稳态空闲量）配合使用，平衡性能与资源效率。



#### `maxTotal`

在 Apache Commons DBCP2（数据库连接池）中，`maxTotal` 是核心配置参数之一，用于**控制连接池允许的最大总连接数**（包括正在使用的“活跃连接”和未被使用的“空闲连接”）。其核心作用是限制连接池的资源占用，避免因连接过多导致数据库或应用服务器资源耗尽，同时平衡应用的并发需求与数据库的承载能力。

**1. 核心作用：限制连接池的总容量**

`maxTotal` 定义了连接池中**所有连接（活跃 + 空闲）的最大数量**。无论应用如何请求连接，连接池的总连接数永远不会超过这个值。这是防止连接池无限制扩张、保护数据库和系统资源的关键机制。  

- **场景示例**：若 `maxTotal=20`，则连接池最多同时存在 20 个连接（可能是 15 个活跃 + 5 个空闲，或 20 个活跃 + 0 个空闲）。当总连接数达到 20 时，后续的连接请求会被阻塞，直到有连接被释放回池中。  

**2. 默认值与版本差异**

- **默认值**：在 DBCP2 中，`maxTotal` 的默认值为 `8`（早期版本可能不同，需以具体版本文档为准）。  
- **与旧版本的区别**：在 DBCP 1.x 中，连接池通过 `maxActive`（最大活跃连接数）和 `maxIdle`（最大空闲连接数）分别控制活跃和空闲连接的上限；而 DBCP2 合并简化为 `maxTotal`（总连接数上限），并通过 `maxIdle` 单独控制最大空闲连接数，灵活性更高。  

**3. 与其他参数的协同作用**

`maxTotal` 需结合其他参数共同管理连接池行为，核心关联参数包括：

（1）`initialSize`（初始连接数）  

`initialSize` 是连接池启动时预创建的连接数，**不能超过 `maxTotal`**。例如：  
- 若 `initialSize=5` 且 `maxTotal=20`，池启动时会创建 5 个连接（总连接数=5）。  
- 若 `initialSize=25` 且 `maxTotal=20`，池会自动将 `initialSize` 限制为 20（不超过 `maxTotal`）。  

（2）`maxIdle`（最大空闲连接数）  

`maxIdle` 定义了连接池允许的最大空闲连接数（未被使用的连接）。当空闲连接数超过 `maxIdle` 时，多余的连接会被**主动关闭**（即使总连接数未达 `maxTotal`）。例如：  
- 若 `maxTotal=20`，`maxIdle=10`，当连接池中有 15 个空闲连接时，池会关闭 5 个，使空闲连接数降至 10（总连接数可能变为 5 活跃 + 10 空闲 = 15，仍 ≤ `maxTotal`）。  

（3）`minIdle`（最小空闲连接数）  

`minIdle` 定义了连接池希望维持的最小空闲连接数（即使没有请求，也会尽量保持这么多空闲连接）。当空闲连接数低于 `minIdle` 时，池会**创建新连接**（但不超过 `maxTotal`）。例如：  
- 若 `maxTotal=20`，`minIdle=3`，当连接池中活跃连接数为 18（空闲=2），池会创建 1 个新连接（空闲=3），总连接数=20（未超上限）。  

（4）连接请求的阻塞逻辑  

当应用请求连接时：  
- 如果当前总连接数 `< maxTotal`：池会创建新连接（直到 `maxTotal` 上限）并返回。  
- 如果当前总连接数 `= maxTotal`：请求会被阻塞，直到有连接被释放回池中（超时可配置 `maxWaitMillis`）。  

**4. 实际应用示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxTotal(20);    // 总连接数上限 20
dataSource.setMaxIdle(10);     // 最大空闲连接数 10
dataSource.setMinIdle(3);      // 最小空闲连接数 3
dataSource.setInitialSize(5);  // 初始创建 5 个连接
```

- **启动阶段**：池创建 5 个连接（总连接数=5，活跃=0，空闲=5）。  
- **应用运行中**：  
  - 若应用发起 15 次连接请求：活跃连接数=15，空闲连接数=5（总=20）。此时总连接数已达 `maxTotal`，后续请求需等待。  
  - 若应用释放 10 个活跃连接：活跃连接数=5，空闲连接数=15。由于 `maxIdle=10`，池会关闭 5 个空闲连接（总连接数=10，活跃=5，空闲=5）。  
  - 若应用再次发起 10 次请求：活跃连接数=15，空闲连接数=5（总=20）。此时总连接数再次达上限，新请求阻塞。  

**5. 最佳实践建议**

- **结合数据库承载能力**：`maxTotal` 需小于等于数据库的最大连接数（如 MySQL 的 `max_connections`），避免应用连接数超过数据库限制导致拒绝服务。  
- **匹配应用并发需求**：根据应用的峰值并发连接数设置 `maxTotal`（通常略高于峰值），避免连接不足导致请求阻塞。  
- **平衡空闲与活跃**：通过 `maxIdle` 和 `minIdle` 优化空闲连接管理，减少频繁创建/销毁连接的开销（连接池的核心优势）。  
- **监控与调优**：通过连接池的统计接口（如 `getNumActive()`、`getNumIdle()`）监控连接使用情况，动态调整 `maxTotal` 以适应业务变化。  

**总结**  

`maxTotal` 是 DBCP2 连接池的“容量阀门”，通过限制总连接数上限，既保障了应用的并发性能，又避免了资源滥用。合理设置 `maxTotal` 需结合数据库能力、应用负载及连接管理策略，是连接池调优的关键参数之一。



#### `maxIdle`

在 Apache Commons DBCP2（数据库连接池）中，`maxIdle` 是控制连接池**最大空闲连接数**的核心参数，用于限制连接池中未被使用的“空闲连接”的上限。其核心作用是避免因空闲连接过多导致数据库或应用服务器资源浪费，同时平衡连接的复用效率与资源占用。

**1. 核心作用：限制空闲连接上限，避免资源浪费**

`maxIdle` 定义了连接池中允许保留的**最多空闲连接数量**（未被使用、等待被复用的连接）。当空闲连接数超过 `maxIdle` 时，连接池会主动关闭多余的连接，释放数据库和服务端的资源（如数据库连接槽、内存等）。  

- **场景示例**：若 `maxIdle=10`，当连接池中出现 15 个空闲连接时，池会关闭 5 个，仅保留 10 个空闲连接，避免资源闲置。  

**2. 默认值与版本背景**

- **默认值**：DBCP2 中 `maxIdle` 的默认值为 `8`（与早期 DBCP 1.x 的 `maxIdle` 行为一致，但 DBCP2 已将活跃/空闲连接统一由 `maxTotal` 控制）。  
- **版本差异**：在 DBCP 1.x 中，`maxActive`（最大活跃连接数）和 `maxIdle`（最大空闲连接数）需分别配置；而 DBCP2 引入 `maxTotal`（总连接数上限，活跃+空闲）后，`maxIdle` 仅作为“空闲连接的上限”独立存在，灵活性更高。  

**3. 与其他参数的协同作用**

`maxIdle` 需结合其他核心参数共同管理连接池行为，关键关联参数包括：

（1）`minIdle`（最小空闲连接数）  

`minIdle` 定义了连接池希望维持的**最小空闲连接数**（即使没有请求，也会尽量保持这么多空闲连接）。`maxIdle` 是空闲连接的上限，`minIdle` 是下限，两者共同控制空闲连接的动态调整：  
- 若空闲连接数 `< minIdle`：池会主动创建新连接（直到 `maxTotal` 上限），以满足最低空闲需求。  
- 若空闲连接数 `> maxIdle`：池会关闭多余连接（即使总连接数未达 `maxTotal`），以释放资源。  

（2）`maxTotal`（总连接数上限）  

`maxTotal` 是连接池中所有连接（活跃+空闲）的最大数量。`maxIdle` 不能超过 `maxTotal`，否则会被自动限制为 `maxTotal` 的值。例如：  
- 若 `maxTotal=20`，但 `maxIdle=25`，则池实际会将 `maxIdle` 视为 20（不超过总容量）。  

（3）连接请求的处理逻辑  

当应用请求连接时，连接池的行为受 `maxTotal`、`maxIdle` 和 `minIdle` 共同影响：  
- **空闲连接足够**：若有空闲连接且总数 ≤ `maxTotal`，直接复用空闲连接。  
- **空闲连接不足但总连接未满**：创建新连接（直到 `maxTotal` 上限）。  
- **总连接已满**：请求阻塞，直到有连接被释放回池中（超时可配置 `maxWaitMillis`）。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxTotal(20);    // 总连接数上限 20
dataSource.setMaxIdle(10);     // 最大空闲连接数 10
dataSource.setMinIdle(3);      // 最小空闲连接数 3
```

- **场景 1：高并发后连接释放**  
  应用发起 15 次连接请求，活跃连接数=15，空闲连接数=5（总=20，达 `maxTotal` 上限）。此时释放 10 个活跃连接，空闲连接数变为 15。由于 `maxIdle=10`，池会关闭 5 个空闲连接，最终空闲连接数=10（总=10 活跃 + 10 空闲？不，总连接数=活跃+空闲=15（活跃）+10（空闲）=25？哦，这里需要纠正：总连接数不能超过 `maxTotal=20`。所以正确的逻辑是，当释放 10 个活跃连接后，活跃连接数=5，空闲连接数=15（总=20）。此时因 `maxIdle=10`，池会关闭 5 个空闲连接，最终空闲连接数=10，活跃连接数=5（总=15 ≤ 20）。  

- **场景 2：低峰期连接回收**  
  应用长时间无请求，活跃连接数=0，空闲连接数=20（总=20）。由于 `maxIdle=10`，池会关闭 10 个空闲连接，最终空闲连接数=10（总=10），避免资源浪费。  

**5. 最佳实践建议**

- **避免过大**：`maxIdle` 过大会导致大量空闲连接长期占用数据库资源（如 MySQL 的连接槽、内存），可能影响数据库性能或其他应用的连接请求。  
- **避免过小**：`maxIdle` 过小会导致频繁创建/销毁连接（尤其在低峰期），增加连接建立的开销（TCP 握手、认证等），降低响应速度。  
- **匹配业务模式**：若应用是“峰谷明显”的（如白天高并发、夜间低峰），可将 `maxIdle` 设置为略高于平均空闲需求（例如，夜间平均需要 5 个空闲连接，则设为 8-10）。  
- **结合监控调整**：通过连接池的统计接口（如 `getNumIdle()`）监控空闲连接数，动态调整 `maxIdle` 以适应业务变化。  

**总结**  

`maxIdle` 是 DBCP2 连接池的“空闲连接上限控制器”，通过限制空闲连接的最大数量，平衡了连接的复用效率与资源占用。合理设置 `maxIdle` 需结合数据库承载能力、应用负载模式及 `minIdle`、`maxTotal` 等参数，是连接池资源优化的关键环节。



#### `minIdle`

在 Apache Commons DBCP2（数据库连接池）中，`minIdle` 是控制连接池**最小空闲连接数**的核心参数，用于确保连接池在非高峰时段仍保留一定数量的空闲连接，以快速响应后续的请求。其核心作用是**维持连接的“热备用”状态**，避免因频繁创建新连接导致的性能损耗。

**1. 核心作用：维持最小空闲连接，减少请求延迟**

`minIdle` 定义了连接池希望**始终保留的空闲连接数量下限**（即使没有活跃请求）。当连接池中的空闲连接数低于 `minIdle` 时，连接池会主动创建新连接（直到达到 `maxTotal` 上限），以确保有足够的“预热”连接等待使用。  

- **场景示例**：若 `minIdle=5`，当连接池因请求释放导致空闲连接数降至 3 时，池会立即创建 2 个新连接，使空闲连接数恢复至 5，避免下次请求时因无空闲连接而重新创建（耗时）。  

**2. 默认值与版本背景**

- **默认值**：DBCP2 中 `minIdle` 的默认值为 `0`（早期版本可能不同）。若设置为 `0`，连接池不会主动维持任何空闲连接（空闲连接会被回收，直到总连接数降至 `maxIdle` 或更低），可能导致请求时频繁创建连接。  

**3. 与其他参数的协同作用**

`minIdle` 需结合其他核心参数共同管理连接池行为，关键关联参数包括：

（1）`maxIdle`（最大空闲连接数）  

`maxIdle` 是空闲连接的上限，`minIdle` 是下限，两者共同约束空闲连接的数量范围：  
- 若空闲连接数 `< minIdle`：池主动创建新连接（直到 `maxTotal` 上限）。  
- 若空闲连接数 `> maxIdle`：池关闭多余连接（即使总连接数未达 `maxTotal`）。  
- **约束**：`minIdle` 不能超过 `maxIdle`（否则会被自动调整为 `maxIdle`）。例如，若 `maxIdle=10` 但 `minIdle=15`，则 `minIdle` 会被视为 10。  

（2）`maxTotal`（总连接数上限）  

`maxTotal` 是连接池中所有连接（活跃+空闲）的最大数量。`minIdle` 的实现受限于 `maxTotal`：  
- 若空闲连接数需要补充至 `minIdle`，但总连接数已达 `maxTotal`（即活跃连接数已占满），则无法创建新连接，可能导致 `minIdle` 无法满足（此时需依赖连接复用或调整 `maxTotal`）。  

（3）`initialSize`（初始连接数）  

`initialSize` 是连接池启动时预创建的连接数，**最终会被 `minIdle` 调整**：  
- 若 `initialSize > minIdle`：启动后空闲连接数为 `initialSize`，但随着时间推移（如连接被释放），若空闲连接数超过 `maxIdle`，池会关闭多余连接，最终稳定在 `minIdle` 附近（不超过 `maxIdle`）。  
- 若 `initialSize < minIdle`：启动后空闲连接数为 `initialSize`，但为了满足 `minIdle` 要求，池会主动创建新连接（直到 `maxTotal` 上限）。  

（4）连接请求的处理逻辑  

当应用请求连接时，连接池的行为受 `minIdle` 直接影响：  
- **空闲连接足够（≥ minIdle）**：直接复用空闲连接，无需创建。  
- **空闲连接不足（< minIdle）但总连接未满（< maxTotal）**：创建新连接至 `minIdle`（或直到 `maxTotal` 上限），再复用。  
- **总连接已满（= maxTotal）**：请求阻塞，直到有连接被释放回池中（超时可配置 `maxWaitMillis`）。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxTotal(20);    // 总连接数上限 20
dataSource.setMaxIdle(10);     // 最大空闲连接数 10
dataSource.setMinIdle(5);      // 最小空闲连接数 5
```

- **场景 1：高并发后连接释放**  
  应用发起 15 次连接请求，活跃连接数=15，空闲连接数=5（总=20，达 `maxTotal` 上限）。此时释放 10 个活跃连接，空闲连接数变为 15（总=15 活跃 + 15 空闲？不，总连接数不能超过 `maxTotal=20`。正确逻辑是：释放 10 个活跃连接后，活跃连接数=5，空闲连接数=15（总=20）。由于 `maxIdle=10`，池会关闭 5 个空闲连接，最终空闲连接数=10（总=5 活跃 + 10 空闲）。此时空闲连接数（10）≥ `minIdle=5`，无需额外操作。  

- **场景 2：低峰期连接回收**  
  应用长时间无请求，活跃连接数=0，空闲连接数=10（总=10）。由于 `minIdle=5`，当前空闲连接数（10）≥ `minIdle`，池不会关闭连接（除非超过 `maxIdle=10` 或触发超时回收）。若应用持续无请求，空闲连接数保持 10（在 `minIdle` 和 `maxIdle` 之间）。  

- **场景 3：空闲连接不足时主动创建**  
  应用释放所有连接，活跃连接数=0，空闲连接数=3（总=3）。由于 `minIdle=5`，池会创建 2 个新连接（总连接数=5，未超 `maxTotal=20`），使空闲连接数恢复至 5。  

**5. 最佳实践建议**

- **根据业务负载设置**：  
  - 高并发应用（如电商大促）：`minIdle` 应接近峰值空闲需求（例如，日常平均空闲 5 个连接，峰值可能需 10 个，则设为 8-10），避免请求时因无空闲连接而延迟。  
  - 低并发应用（如内部管理系统）：`minIdle` 可设为较低值（如 3-5），避免资源浪费。  

- **避免过大**：  
  `minIdle` 过大会导致大量空闲连接长期占用数据库资源（如 MySQL 的连接槽、内存），可能触发数据库的连接超时策略（如 `wait_timeout`）或影响其他应用的连接请求。  

- **结合 `maxIdle` 和 `maxTotal`**：  
  建议 `minIdle ≤ maxIdle ≤ maxTotal`，并确保 `maxTotal` 不超过数据库的最大连接数（如 MySQL 的 `max_connections`）。  

- **启用连接验证**：  
  若 `minIdle` 较大，建议配置 `testWhileIdle=true` 和 `validationQuery`（如 `SELECT 1`），定期验证空闲连接的有效性（避免数据库主动关闭连接后，池仍保留无效连接）。  

**总结**  

`minIdle` 是 DBCP2 连接池的“稳态空闲连接守护者”，通过强制保留最小数量的空闲连接，确保应用请求时能快速复用连接，减少延迟。合理设置 `minIdle` 需结合业务负载、数据库承载能力及 `maxIdle`、`maxTotal` 等参数，是连接池性能优化的核心配置之一。



#### `maxWaitMillis`

在 Apache Commons DBCP2（数据库连接池）中，`maxWaitMillis` 是控制连接池**请求线程等待连接的最长时间**的核心参数。其核心作用是**避免线程因无限阻塞而耗尽资源**，确保应用在高并发或连接池耗尽时仍能保持响应能力。

**1. 核心作用：限制等待时间，防止线程无限阻塞**

当连接池中的**活跃连接数达到 `maxTotal` 上限**（无可用连接）时，新的连接请求会被阻塞。`maxWaitMillis` 定义了这种阻塞状态的**最长允许等待时间**（单位：毫秒）：  
- 若在 `maxWaitMillis` 时间内，有连接被释放回池中（如其他线程释放连接），请求线程将获取连接并继续执行。  
- 若超过 `maxWaitMillis` 时间仍未获取到连接，连接池会抛出异常（如 `NoSuchElementException` 或 `SQLTransientConnectionException`），终止等待，避免线程无限阻塞。  

**2. 默认值与行为**

- **默认值**：DBCP2 中 `maxWaitMillis` 的默认值为 `-1`，表示**无限等待**（线程会一直阻塞直到获取连接）。  
- **风险**：若设置为 `-1`，当连接池耗尽且无连接释放时，请求线程会永久阻塞，可能导致应用无响应甚至崩溃（如线程池耗尽）。  

**3. 与其他参数的协同作用**

`maxWaitMillis` 需结合其他核心参数共同管理连接池的阻塞行为，关键关联参数包括：

（1）`maxTotal`（总连接数上限）  

`maxTotal` 决定了连接池的最大容量。当活跃连接数达到 `maxTotal` 时，新请求才会触发等待逻辑。例如：  
- 若 `maxTotal=20`，当前活跃连接数=20（无空闲连接），新请求进入等待状态，等待时间由 `maxWaitMillis` 控制。  

（2）`minIdle`（最小空闲连接数）  

`minIdle` 影响连接池的空闲连接储备。若 `minIdle` 配置合理，连接池通常会保留一定数量的空闲连接，减少 `maxWaitMillis` 触发等待的概率。例如：  
- 若 `minIdle=5`，即使活跃连接数短暂达到 15（总连接数=20），空闲连接仍有 5 个，新请求可直接获取，无需等待。  

（3）`timeBetweenEvictionRunsMillis`（连接回收间隔）  

连接池通过后台线程定期回收空闲连接（超过 `maxIdle` 或失效的连接）。若回收策略高效，可及时释放空闲连接，减少 `maxWaitMillis` 的触发频率。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxTotal(20);       // 总连接数上限 20
dataSource.setMaxIdle(10);        // 最大空闲连接数 10
dataSource.setMinIdle(5);         // 最小空闲连接数 5
dataSource.setMaxWaitMillis(3000); // 最长等待 3 秒
```

- **场景 1：正常请求（有空闲连接）**  
  应用发起 10 次连接请求，此时空闲连接数=10（总连接数=10 活跃 + 10 空闲）。10 次请求直接复用空闲连接，无需等待。  

- **场景 2：高并发触发等待**  
  应用发起 15 次连接请求，活跃连接数=15，空闲连接数=5（总=20）。此时第 16 次请求进入等待状态。若在 3 秒内有 1 个活跃连接被释放（空闲连接数=6），第 16 次请求获取连接并执行；若 3 秒内无连接释放，第 16 次请求抛出异常。  

**5. 最佳实践建议**

- **避免默认值 `-1`**：生产环境中应将 `maxWaitMillis` 设置为合理值（如 3000-10000 毫秒），防止线程无限阻塞。  
- **匹配业务容忍度**：根据应用的容错能力设置等待时间：  
  - 对实时性要求高的场景（如支付交易）：设置较短（如 2000 毫秒），快速失败并触发重试或降级。  
  - 对延迟不敏感的场景（如批量任务）：可适当延长（如 5000-10000 毫秒），等待连接释放。  
- **结合监控调整**：通过连接池的统计接口（如 `getNumActive()`、`getNumIdle()`、`getMaxWaitMillis()`）监控等待次数和时长，动态优化 `maxTotal` 或 `minIdle` 以减少等待。  
- **异常处理**：捕获 `NoSuchElementException` 或 `SQLTransientConnectionException`，实现重试逻辑或友好提示（如“系统繁忙，请稍后再试”）。  

**总结**  

`maxWaitMillis` 是 DBCP2 连接池的“阻塞保护器”，通过限制等待时间上限，确保应用在高并发或连接池耗尽时仍能保持响应。合理设置该参数需结合业务场景、数据库响应速度及连接池的其他参数（如 `maxTotal`、`minIdle`），是连接池稳定性调优的关键配置之一。



#### `validationQuery`

在 Apache Commons DBCP2（数据库连接池）中，`validationQuery` 是用于**验证数据库连接是否有效**的核心参数。其核心作用是确保从连接池中获取的连接是“存活”的（未被数据库关闭或因网络问题失效），避免应用使用无效连接导致运行时异常。

**1. 核心作用：检测无效连接，避免运行时故障**

数据库连接可能因以下原因失效：  
- 数据库服务器重启或网络中断，导致连接被断开。  
- 数据库设置了空闲连接超时（如 MySQL 的 `wait_timeout`），长时间未使用的连接被数据库主动关闭。  
- 连接池中的连接因长时间未使用，内部状态异常（如事务未正确提交）。  

`validationQuery` 是一条轻量级的 SQL 查询语句（如 `SELECT 1`），连接池会使用它来**主动验证连接的有效性**。若验证失败（如查询超时或报错），连接会被标记为无效并从池中移除，避免应用拿到“僵尸连接”。  

**2. 关键关联参数：控制验证时机**

`validationQuery` 需配合以下参数共同控制验证逻辑，决定何时、如何验证连接：

（1）`testOnBorrow`（借用时验证）  

- **含义**：当应用从连接池“借用”连接（`getConnection()`）时，是否用 `validationQuery` 验证连接有效性。  
- **默认值**：`false`（不验证）。  
- **适用场景**：对连接可靠性要求极高时启用（如金融交易），但会增加每次借用的延迟（因需执行验证查询）。  

（2）`testWhileIdle`（空闲时验证）  

- **含义**：当连接池的空闲连接被后台线程检查时（由 `timeBetweenEvictionRunsMillis` 控制间隔），是否用 `validationQuery` 验证有效性。  
- **默认值**：`false`（不验证）。  
- **优势**：在连接空闲时验证，不影响业务请求的响应时间，是生产环境最常用的验证策略。  

（3）`testOnReturn`（归还时验证）  

- **含义**：当应用将连接“归还”连接池（`close()`）时，是否用 `validationQuery` 验证有效性。  
- **默认值**：`false`（不验证）。  
- **注意**：若启用，可能增加归还操作的延迟，通常不建议开启（除非连接失效概率极高）。  

（4）`validationQueryTimeout`（验证超时时间）  

- **含义**：`validationQuery` 执行的超时时间（单位：秒）。若验证查询超过此时间未完成，连接会被标记为无效。  
- **默认值**：`-1`（不设置超时，可能长时间阻塞）。  
- **建议**：根据数据库性能设置合理值（如 1-5 秒），避免验证过程本身成为瓶颈。  

**3. 典型配置示例**

```java
BasicDataSource dataSource = new BasicDataSource();
// 验证查询（轻量级，快速执行）
dataSource.setValidationQuery("SELECT 1"); 
// 空闲时验证（后台线程每 30 秒检查一次）
dataSource.setTimeBetweenEvictionRunsMillis(30000); 
dataSource.setTestWhileIdle(true); 
// 借用时验证（可选，根据业务需求）
dataSource.setTestOnBorrow(false); 
// 验证超时时间（3 秒）
dataSource.setValidationQueryTimeout(3); 
```

**4. 注意事项与最佳实践**

（1）选择轻量级验证查询  

`validationQuery` 需是**执行速度极快**的 SQL 语句，避免影响连接池性能。常见写法：  
- 通用：`SELECT 1`（大多数数据库支持）。  
- Oracle：`SELECT 1 FROM DUAL`（DUAL 是 Oracle 的虚拟表）。  
- PostgreSQL：`SELECT 1`（或 `SELECT version()`，但需确保快速返回）。  

（2）避免过度验证  

- 若 `testOnBorrow=true`，每次借用连接都会执行验证，可能增加延迟（尤其在高并发场景）。  
- 优先使用 `testWhileIdle=true`，在连接空闲时验证，平衡性能与可靠性。  

（3）结合数据库超时配置  

若数据库设置了 `wait_timeout`（如 MySQL 默认 8 小时），建议将 `timeBetweenEvictionRunsMillis` 设置为小于 `wait_timeout` 的值（如 30 分钟），确保连接池在数据库关闭连接前主动验证并回收。  

（4）生产环境必配  

在正式生产环境中，**强烈建议启用 `validationQuery` 并配合 `testWhileIdle`**，避免因数据库主动关闭空闲连接导致的“僵尸连接”问题（表现为应用抛出 `SQLTransientConnectionException` 或 `SocketException`）。  

**总结**  

`validationQuery` 是 DBCP2 连接池的“连接健康检测器”，通过执行轻量级 SQL 查询确保连接有效性。合理配置 `validationQuery` 及其关联参数（如 `testWhileIdle`、`validationQueryTimeout`），能有效避免应用使用失效连接，是提升连接池可靠性的关键手段。



#### `testOnBorrow`

在 Apache Commons DBCP2（数据库连接池）中，`testOnBorrow` 是控制**从连接池借用连接时是否验证连接有效性**的核心参数。其核心作用是**确保应用程序获取到的连接是“存活”的**（未被数据库关闭或因网络问题失效），避免使用无效连接导致运行时异常。

**1. 核心作用：借用时验证连接有效性**

当应用程序调用 `dataSource.getConnection()` 从连接池获取连接时，若 `testOnBorrow` 设为 `true`，连接池会执行以下操作：  
1. 从池中取出一个空闲连接。  
2. 使用 `validationQuery`（需提前配置）执行一条轻量级 SQL 查询（如 `SELECT 1`）。  
3. 若查询成功（连接有效），则将该连接返回给应用程序；  
4. 若查询失败（连接无效，如数据库已关闭该连接），则丢弃该连接，并尝试从池中获取下一个连接（或创建新连接，取决于池状态）。  

**2. 默认值与行为**

- **默认值**：`testOnBorrow` 的默认值为 `false`（不验证）。  
- **不验证的风险**：若连接池中存在因数据库超时（如 MySQL 的 `wait_timeout`）或网络问题失效的连接，应用程序可能直接使用这些“僵尸连接”，导致运行时抛出 `SQLTransientConnectionException`、`SocketException` 等异常。  

**3. 关键关联参数**

`testOnBorrow` 需配合以下参数共同生效，决定验证的具体逻辑：

（1）`validationQuery`（验证查询语句）  

- **作用**：定义用于验证连接有效性的 SQL 语句（如 `SELECT 1`）。  
- **必要性**：若未配置 `validationQuery`，即使 `testOnBorrow=true`，验证也会失败（无法执行查询），导致连接无法被借用。  

（2）`validationQueryTimeout`（验证超时时间）  

- **作用**：设置 `validationQuery` 执行的超时时间（单位：秒）。若查询超过此时间未完成，连接会被标记为无效。  
- **默认值**：`-1`（不设置超时，可能长时间阻塞）。  
- **建议**：根据数据库性能设置合理值（如 1-5 秒），避免验证过程本身成为瓶颈。  

（3）`testWhileIdle`（空闲时验证）  

- **作用**：连接池的后台线程会定期检查空闲连接（间隔由 `timeBetweenEvictionRunsMillis` 控制），并使用 `validationQuery` 验证其有效性。  
- **与 `testOnBorrow` 的区别**：`testWhileIdle` 在连接空闲时验证（不影响业务请求），而 `testOnBorrow` 在借用时验证（可能增加请求延迟）。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setValidationQuery("SELECT 1");          // 验证查询
dataSource.setTestOnBorrow(true);                   // 借用时验证
dataSource.setValidationQueryTimeout(3);            // 验证超时 3 秒
dataSource.setTimeBetweenEvictionRunsMillis(30000); // 空闲时每 30 秒验证
```

- **场景 1：借用有效连接**  
  应用调用 `getConnection()`，连接池取出一个空闲连接。执行 `SELECT 1` 验证成功，连接被返回，无延迟。  

- **场景 2：借用无效连接**  
  连接池中存在一个因数据库 `wait_timeout` 被关闭的连接。应用调用 `getConnection()` 时，连接池执行 `SELECT 1` 验证失败，丢弃该连接，并尝试获取下一个连接（若池中有其他有效连接则返回，否则创建新连接）。  

**5. 最佳实践建议**

（1）仅在必要时启用  

`testOnBorrow=true` 会增加每次连接借用的延迟（因需执行验证查询），因此**不建议作为默认配置**。推荐场景：  
- 应用对连接可靠性要求极高（如实时交易系统）。  
- 数据库频繁主动关闭空闲连接（如 `wait_timeout` 很短），且 `testWhileIdle` 无法覆盖所有场景（如突发流量导致连接快速耗尽）。  

（2）配合轻量级 `validationQuery`  

为减少验证延迟，`validationQuery` 应选择执行最快的 SQL 语句：  
- 通用：`SELECT 1`（几乎所有数据库支持）。  
- Oracle：`SELECT 1 FROM DUAL`（需使用 DUAL 表）。  

（3）结合 `testWhileIdle` 优化  

多数场景下，推荐优先启用 `testWhileIdle=true`（空闲时验证），而非 `testOnBorrow=true`。这样既能清理无效连接，又不影响业务请求的响应时间。`testOnBorrow` 仅作为补充，用于处理极端情况下的“漏网”无效连接。  

（4）监控验证性能  

启用 `testOnBorrow` 后，需监控连接池的 `getAverageBorrowWaitTimeMillis()`（平均借用等待时间）和 `getNumFailedBorrows()`（借用失败次数），评估验证对性能的影响。若延迟过高，可调整 `validationQuery` 或改用 `testWhileIdle`。  

**总结**  

`testOnBorrow` 是 DBCP2 连接池的“借用时安全闸门”，通过强制验证连接有效性，确保应用获取到可用连接。尽管它能提升可靠性，但需权衡其对性能的影响。生产环境中，建议优先使用 `testWhileIdle` 配合轻量级验证，仅在必要时启用 `testOnBorrow` 处理极端场景。



#### `testOnReturn`

在 Apache Commons DBCP2（数据库连接池）中，`testOnReturn` 是控制**连接归还时是否验证有效性**的核心参数。其核心作用是**确保应用程序归还的连接是“存活”的**（未被数据库关闭或因网络问题失效），避免将无效连接重新放入连接池，影响后续请求的使用。

**1. 核心作用：归还时验证连接有效性**

当应用程序调用 `connection.close()` 归还连接到连接池时（注意：DBCP2 中 `close()` 是归还而非真正关闭连接），若 `testOnReturn` 设为 `true`，连接池会执行以下操作：  
1. 拦截归还的连接。  
2. 使用 `validationQuery`（需提前配置）执行一条轻量级 SQL 查询（如 `SELECT 1`）。  
3. 若查询成功（连接有效），则将连接标记为“空闲”并放回连接池；  
4. 若查询失败（连接无效，如数据库已关闭该连接），则直接丢弃该连接（不放回池中），避免污染连接池。  

**2. 默认值与行为**

- **默认值**：`testOnReturn` 的默认值为 `false`（不验证）。  
- **不验证的风险**：若连接因数据库超时（如 MySQL 的 `wait_timeout`）或网络问题失效，归还时不会被检测，导致无效连接被重新放入池中。后续借用该连接时，应用会直接使用“僵尸连接”，抛出 `SQLTransientConnectionException` 或 `SocketException` 等异常。  

**3. 关键关联参数**

`testOnReturn` 需配合以下参数共同生效，决定验证的具体逻辑：

（1）`validationQuery`（验证查询语句）  

- **作用**：定义用于验证连接有效性的 SQL 语句（如 `SELECT 1`）。  
- **必要性**：若未配置 `validationQuery`，即使 `testOnReturn=true`，验证也会失败（无法执行查询），导致连接无法被正确处理。  

（2）`validationQueryTimeout`（验证超时时间）  

- **作用**：设置 `validationQuery` 执行的超时时间（单位：秒）。若查询超过此时间未完成，连接会被标记为无效。  
- **默认值**：`-1`（不设置超时，可能长时间阻塞）。  
- **建议**：根据数据库性能设置合理值（如 1-5 秒），避免验证过程本身成为瓶颈。  

（3）`testOnBorrow`（借用时验证）与 `testWhileIdle`（空闲时验证）  

- **`testOnBorrow`**：在连接被借用时验证（优先于 `testOnReturn` 处理无效连接）。  
- **`testWhileIdle`**：在连接空闲时由后台线程验证（清理长期无效的连接）。  
- **与 `testOnReturn` 的区别**：`testOnReturn` 是“归还前最后一道防线”，确保只有有效连接被放回池中；而前两者分别在借用和空闲阶段提前过滤无效连接。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setValidationQuery("SELECT 1");       // 验证查询
dataSource.setTestOnReturn(true);                // 归还时验证
dataSource.setValidationQueryTimeout(3);         // 验证超时 3 秒
```

- **场景 1：归还有效连接**  
  应用调用 `connection.close()` 归还连接。连接池执行 `SELECT 1` 验证成功，连接被标记为空闲并放回池中，供后续请求使用。  

- **场景 2：归还无效连接**  
  连接因数据库重启被关闭。应用归还时，连接池执行 `SELECT 1` 验证失败，该连接被直接丢弃（不放回池中），避免后续请求使用失效连接。  

**5. 最佳实践建议**

（1）仅在必要时启用  

`testOnReturn=true` 会增加每次连接归还的延迟（因需执行验证查询），因此**不建议作为默认配置**。推荐场景：  
- 应用中存在大量“错误归还”场景（如未正确关闭连接导致连接状态异常）。  
- 数据库频繁主动关闭连接（如 `wait_timeout` 极短），且 `testWhileIdle` 无法及时清理（如后台线程间隔较长）。  

（2）配合轻量级 `validationQuery`  

为减少验证延迟，`validationQuery` 应选择执行最快的 SQL 语句：  
- 通用：`SELECT 1`（几乎所有数据库支持）。  
- Oracle：`SELECT 1 FROM DUAL`（需使用 DUAL 表）。  

（3）避免与 `testOnBorrow` 重复验证  

若已启用 `testOnBorrow=true`（借用时验证），大部分无效连接会在借用阶段被过滤，`testOnReturn` 的必要性降低。两者同时启用可能导致冗余验证，增加性能开销。  

（4）监控验证性能  

启用 `testOnReturn` 后，需监控连接池的 `getAverageReturnWaitTimeMillis()`（平均归还等待时间）和 `getNumFailedReturns()`（归还失败次数），评估验证对性能的影响。若延迟过高，可调整 `validationQuery` 或改用 `testWhileIdle`。  

**总结**  

`testOnReturn` 是 DBCP2 连接池的“归还前安检员”，通过在连接放回池前验证其有效性，确保连接池中仅保留可用连接。尽管它能提升连接池的健壮性，但需权衡其对性能的影响。生产环境中，建议优先通过 `testWhileIdle` 清理无效连接，仅在特定场景（如高错误率归还）下启用 `testOnReturn`。



#### `testWhileIdle`

在 Apache Commons DBCP2（数据库连接池）中，`testWhileIdle` 是控制**连接池后台线程在空闲连接被检查时是否验证其有效性**的核心参数。其核心作用是**主动清理无效的空闲连接**，避免将“僵尸连接”（如被数据库主动关闭或因网络问题失效的连接）保留在池中，从而提升连接池的健壮性和应用的稳定性。

**1. 核心作用：空闲时验证连接有效性**

DBCP2 会启动一个后台线程（称为“驱逐线程”），定期扫描连接池中的空闲连接（未被使用的连接）。若 `testWhileIdle` 设为 `true`，该线程会对每个空闲连接执行以下操作：  
1. 使用 `validationQuery`（需提前配置的轻量级 SQL 查询）验证连接是否有效。  
2. 若验证成功（连接存活），则保留该连接作为空闲连接备用。  
3. 若验证失败（连接失效，如数据库已关闭该连接），则直接从池中移除该连接，避免后续请求误用。  

**2. 默认值与行为**

- **默认值**：`testWhileIdle` 的默认值为 `false`（不验证）。  
- **不验证的风险**：若连接因数据库超时（如 MySQL 的 `wait_timeout`）、网络中断等原因失效，这些无效连接会被长期保留在池中。当应用尝试借用这些连接时，会直接抛出 `SQLTransientConnectionException`、`SocketException` 等异常，导致业务失败。  

**3. 关键关联参数**

`testWhileIdle` 需配合以下参数共同生效，决定验证的具体逻辑和效率：

（1）`validationQuery`（验证查询语句）  

- **作用**：定义用于验证连接有效性的 SQL 语句（如 `SELECT 1`）。  
- **必要性**：若未配置 `validationQuery`，即使 `testWhileIdle=true`，验证也会失败（无法执行查询），导致无效连接无法被清理。  

（2）`timeBetweenEvictionRunsMillis`（驱逐线程检查间隔）  

- **作用**：后台驱逐线程两次扫描空闲连接的间隔时间（单位：毫秒）。  
- **默认值**：`-1`（不启动驱逐线程）。  
- **建议**：根据数据库的空闲连接超时时间（如 MySQL 的 `wait_timeout` 默认 8 小时）设置，通常设为 `wait_timeout` 的 1/3~1/2（如 30 分钟），确保在数据库关闭连接前主动清理。  

（3）`validationQueryTimeout`（验证超时时间）  

- **作用**：`validationQuery` 执行的超时时间（单位：秒）。若查询超过此时间未完成，连接会被标记为无效。  
- **默认值**：`-1`（不设置超时，可能长时间阻塞）。  
- **建议**：根据数据库性能设置合理值（如 1-5 秒），避免验证过程本身成为瓶颈。  

（4）`minIdle`（最小空闲连接数）  

- **作用**：连接池希望保留的最小空闲连接数。  
- **与 `testWhileIdle` 的协同**：若空闲连接数因验证被清理而低于 `minIdle`，连接池会主动创建新连接（直到 `maxTotal` 上限），确保有足够的备用连接。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setValidationQuery("SELECT 1");                // 轻量级验证查询
dataSource.setTestWhileIdle(true);                        // 空闲时验证
dataSource.setTimeBetweenEvictionRunsMillis(1800000);     // 每 30 分钟检查一次（MySQL wait_timeout 默认 28800000ms=8小时）
dataSource.setValidationQueryTimeout(3);                  // 验证超时 3 秒
dataSource.setMinIdle(5);                                 // 最小保留 5 个空闲连接
```

- **场景 1：正常空闲连接**  
  连接池中有 10 个空闲连接，驱逐线程每 30 分钟扫描一次。执行 `SELECT 1` 验证成功，所有连接被保留，继续作为空闲连接备用。  

- **场景 2：存在无效空闲连接**  
  其中 2 个连接因数据库 `wait_timeout` 被关闭。驱逐线程扫描时执行 `SELECT 1` 验证失败，这 2 个连接被移除。由于当前空闲连接数为 8（≥ `minIdle=5`），无需创建新连接。  

**5. 最佳实践建议**

（1）生产环境必启  

`testWhileIdle` 是 DBCP2 连接池的“空闲连接清道夫”，能有效清理因数据库超时或网络问题失效的连接。**强烈建议在生产环境中启用**（设为 `true`），避免应用使用“僵尸连接”。  

（2）配置轻量级 `validationQuery`  

为减少验证对数据库的压力，`validationQuery` 应选择执行最快的 SQL 语句：  
- 通用：`SELECT 1`（几乎所有数据库支持，无实际数据操作）。  
- Oracle：`SELECT 1 FROM DUAL`（需使用 DUAL 虚拟表）。  

（3）合理设置 `timeBetweenEvictionRunsMillis`  

根据数据库的空闲连接超时策略调整检查间隔：  
- 若数据库 `wait_timeout=8小时`（28800000ms），建议 `timeBetweenEvictionRunsMillis=1800000ms`（30分钟），确保在数据库关闭连接前主动清理。  

（4）配合 `minIdle` 维持连接储备  

若 `testWhileIdle` 清理了部分无效连接，导致空闲连接数低于 `minIdle`，连接池会自动创建新连接（直到 `maxTotal` 上限）。因此，`minIdle` 应根据业务的峰值空闲需求设置（如日常平均空闲 5 个，设为 8-10）。  

（5）监控验证效果  

通过连接池的统计接口（如 `getNumIdle()`、`getNumValidatedIdle()`、`getNumFailedValidations()`）监控验证结果，确保无效连接被及时清理。若验证失败次数过多，需检查 `validationQuery` 或数据库连接状态。  

**总结**  

`testWhileIdle` 是 DBCP2 连接池的“空闲连接健康检查器”，通过在后台定期验证空闲连接的有效性，主动清理“僵尸连接”，确保连接池中的连接始终可用。合理配置 `testWhileIdle` 及其关联参数（如 `validationQuery`、`timeBetweenEvictionRunsMillis`），能显著提升应用的稳定性和数据库连接的利用率，是生产环境中连接池调优的核心配置之一。



#### `timeBetweenEvictionRunsMillis`

在 Apache Commons DBCP2（数据库连接池）中，`timeBetweenEvictionRunsMillis` 是控制**后台驱逐线程执行间隔**的核心参数。其核心作用是**定期触发连接池对空闲连接的检查与回收**，确保连接池中的连接始终有效且资源合理利用。

**1. 核心作用：控制后台检查的频率**

DBCP2 会启动一个**后台驱逐线程**（Eviction Thread），专门负责扫描连接池中的空闲连接（未被使用的连接），并执行以下操作：  
- 验证连接有效性（若 `testWhileIdle=true`）。  
- 回收超过 `maxIdle` 限制的空闲连接。  
- 清理因数据库超时或网络问题失效的“僵尸连接”。  

`timeBetweenEvictionRunsMillis` 定义了该后台线程**两次检查之间的间隔时间**（单位：毫秒）。例如，设置为 `1800000`（30 分钟），则驱逐线程每 30 分钟执行一次检查。  

**2. 默认值与行为**

- **默认值**：`timeBetweenEvictionRunsMillis` 的默认值为 `-1`（不启动驱逐线程）。  
- **不启动的风险**：若未显式设置该参数（或设为 `-1`），后台驱逐线程不会运行，连接池无法主动清理无效或超量的空闲连接，可能导致：  
  - 无效连接（如被数据库关闭的连接）长期滞留池中，应用使用时抛出异常。  
  - 空闲连接过多（超过 `maxIdle`），浪费数据库资源（如连接槽、内存）。  

**3. 关键关联参数**

`timeBetweenEvictionRunsMillis` 需与其他参数协同工作，共同决定连接池的清理策略：

（1）`testWhileIdle`（空闲时验证）  

- **关系**：若 `testWhileIdle=true`，驱逐线程在检查空闲连接时会执行 `validationQuery`（需提前配置）验证连接有效性；若 `testWhileIdle=false`，驱逐线程仅回收超过 `maxIdle` 的空闲连接，不验证有效性。  
- **典型场景**：生产环境中通常同时启用 `testWhileIdle=true` 和合理的 `timeBetweenEvictionRunsMillis`，以主动清理无效连接。  

（2）`maxIdle`（最大空闲连接数）  

- **关系**：驱逐线程会回收超过 `maxIdle` 的空闲连接（即使连接有效）。例如，若 `maxIdle=10`，当前空闲连接数为 15，则驱逐线程会关闭 5 个连接，使空闲数降至 10。  

（3）`minIdle`（最小空闲连接数）  

- **关系**：若驱逐线程回收连接后，空闲连接数低于 `minIdle`，连接池会自动创建新连接（直到 `maxTotal` 上限），确保有足够的备用连接。  

（4）`validationQuery`（验证查询）与 `validationQueryTimeout`（验证超时）  

- **关系**：若 `testWhileIdle=true`，驱逐线程需通过 `validationQuery` 验证连接有效性，`validationQueryTimeout` 定义验证的超时时间（避免长时间阻塞）。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setTimeBetweenEvictionRunsMillis(1800000); // 每 30 分钟检查一次
dataSource.setTestWhileIdle(true);                    // 空闲时验证
dataSource.setValidationQuery("SELECT 1");            // 验证查询
dataSource.setMaxIdle(10);                            // 最大空闲 10 个
dataSource.setMinIdle(5);                             // 最小空闲 5 个
```

- **场景 1：正常空闲连接**  
  驱逐线程每 30 分钟扫描一次，发现 10 个空闲连接（≤ `maxIdle=10`），且 `SELECT 1` 验证成功，连接被保留。  

- **场景 2：空闲连接超量**  
  当前空闲连接数为 15（超过 `maxIdle=10`），驱逐线程关闭 5 个连接，空闲数降至 10（满足 `maxIdle`）。  

- **场景 3：存在无效连接**  
  其中 2 个连接因数据库 `wait_timeout` 被关闭。驱逐线程执行 `SELECT 1` 验证失败，直接移除这 2 个连接。由于剩余空闲连接数为 8（≥ `minIdle=5`），无需创建新连接。  

**5. 最佳实践建议**

（1）生产环境必显式设置  

`timeBetweenEvictionRunsMillis` 的默认值 `-1` 会导致后台线程不运行，**必须在生产环境中显式设置为正数**（如 30 分钟），以主动清理无效连接。  

（2）根据数据库超时策略调整  

数据库通常有空闲连接超时机制（如 MySQL 的 `wait_timeout` 默认 8 小时）。建议将 `timeBetweenEvictionRunsMillis` 设置为数据库超时时间的 **1/3~1/2**（如数据库超时 8 小时，则设为 30 分钟），确保在数据库关闭连接前主动回收。  

（3）平衡检查频率与性能  

- 检查间隔过短（如 1 分钟）：会增加数据库的验证压力（尤其 `testWhileIdle=true` 时），可能影响业务性能。  
- 检查间隔过长（如 24 小时）：可能导致无效连接长期滞留池中，增加应用使用“僵尸连接”的风险。  

（4）配合 `minIdle` 维持连接储备  

若驱逐线程回收连接后，空闲连接数低于 `minIdle`，连接池会自动创建新连接（直到 `maxTotal` 上限）。因此，`minIdle` 应根据业务的峰值空闲需求设置（如日常平均空闲 5 个，设为 8-10）。  

（5）监控检查效果  

通过连接池的统计接口（如 `getLastEvictionRunMillis()`、`getNumEvictedIdleConnections()`）监控驱逐线程的执行次数和回收的连接数，确保策略生效。  

**总结**  

`timeBetweenEvictionRunsMillis` 是 DBCP2 连接池的“后台检查调度器”，通过控制驱逐线程的执行间隔，定期清理无效或超量的空闲连接，确保连接池的资源高效利用和应用稳定性。合理配置该参数（结合 `testWhileIdle`、`maxIdle` 等参数），是连接池长期健康运行的关键。



#### `minEvictableIdleTimeMillis`

在 Apache Commons DBCP2（数据库连接池）中，`minEvictableIdleTimeMillis` 是控制**空闲连接被回收前的最小存活时间**的核心参数。其核心作用是**避免连接池频繁回收“刚空闲”的连接**，减少因连接创建/销毁带来的性能开销，同时平衡数据库资源的合理利用。

**1. 核心作用：定义空闲连接的“最小存活时间”**

当连接池中的空闲连接（未被使用的连接）数量超过 `maxIdle`（最大空闲连接数）时，后台驱逐线程会启动回收逻辑。但 `minEvictableIdleTimeMillis` 规定了：  
**只有空闲时间超过该阈值的连接才会被回收**，而空闲时间未达阈值的连接会被保留，避免“刚空闲就被回收”的情况。  

**2. 默认值与行为**

- **默认值**：`minEvictableIdleTimeMillis` 的默认值为 `60000` 毫秒（即 1 分钟）。  
- **不设置的后果**：若未显式配置，连接池可能在空闲连接数超过 `maxIdle` 时，立即回收部分“年轻”（空闲时间短）的连接，导致连接池频繁创建/销毁连接，增加数据库开销。  

**3. 关键关联参数**

`minEvictableIdleTimeMillis` 需与其他参数协同工作，共同决定连接池的回收策略：

（1）`maxIdle`（最大空闲连接数）  

- **关系**：当空闲连接数 > `maxIdle` 时，驱逐线程启动回收。但回收的目标是**空闲时间 ≥ `minEvictableIdleTimeMillis` 的连接**，而非所有超量连接。  

（2）`timeBetweenEvictionRunsMillis`（驱逐线程检查间隔）  

- **关系**：驱逐线程每间隔 `timeBetweenEvictionRunsMillis` 检查一次空闲连接。若 `minEvictableIdleTimeMillis` 较大（如 5 分钟），需适当缩短检查间隔（如 1 分钟），确保超量空闲连接被逐步回收。  

（3）`testWhileIdle`（空闲时验证）与 `validationQuery`（验证查询）  

- **关系**：若 `testWhileIdle=true`，回收前会验证连接有效性。`minEvictableIdleTimeMillis` 仅控制“存活时间”，不影响验证逻辑。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setMaxIdle(10);                      // 最大空闲 10 个
dataSource.setMinEvictableIdleTimeMillis(300000); // 空闲至少 5 分钟才回收
dataSource.setTimeBetweenEvictionRunsMillis(60000); // 每分钟检查一次
dataSource.setTestWhileIdle(true);              // 空闲时验证
dataSource.setValidationQuery("SELECT 1");      // 验证查询
```

- **场景 1：空闲连接数未超 `maxIdle`**  
  当前空闲连接数为 8（≤ `maxIdle=10`），驱逐线程不触发回收，所有连接保留。  

- **场景 2：空闲连接数超 `maxIdle`，但部分连接未达存活时间**  
  当前空闲连接数为 15（> `maxIdle=10`），其中 5 个连接空闲时间为 3 分钟（< `minEvictableIdleTimeMillis=5 分钟`），另外 10 个连接空闲时间为 6 分钟（≥ 5 分钟）。驱逐线程仅回收 10 个超量连接中的 5 个（优先回收存活时间长的），最终空闲连接数降至 10（符合 `maxIdle`）。  

- **场景 3：空闲连接均达存活时间**  
  空闲连接数为 15，所有连接空闲时间 ≥ 5 分钟。驱逐线程回收 5 个连接，空闲数降至 10。  

**5. 最佳实践建议**

（1）根据业务场景调整  

- **高并发短事务应用**（如 Web 服务）：连接频繁借还，空闲时间短。建议设置 `minEvictableIdleTimeMillis` 为 `300000`（5 分钟）~ `600000`（10 分钟），避免刚空闲的连接被回收，减少连接创建开销。  
- **低并发长事务应用**（如批量任务）：连接长期空闲。建议设置 `minEvictableIdleTimeMillis` 为 `180000`（3 分钟）~ `300000`（5 分钟），确保数据库资源及时释放。  

（2）避免过小或过大  

- **过小（如 60000 毫秒）**：连接刚空闲即被回收，导致连接池频繁创建/销毁连接，增加数据库压力。  
- **过大（如 3600000 毫秒）**：空闲连接长期滞留池中，可能占用数据库连接槽（如 MySQL 的 `max_connections`），影响其他应用的连接请求。  

（3）配合 `maxIdle` 控制资源上限  

`minEvictableIdleTimeMillis` 决定连接的“存活资格”，`maxIdle` 决定存活连接的数量上限。例如：  
- 若 `maxIdle=10`，`minEvictableIdleTimeMillis=5 分钟`，则连接池最多保留 10 个“存活至少 5 分钟”的空闲连接，既保证复用性，又避免资源浪费。  

（4）监控回收效果  

通过连接池的统计接口（如 `getNumEvictedIdleConnections()`、`getTotalEvictionCount()`）监控回收次数和数量，评估策略是否合理。若回收次数过多，可能需延长 `minEvictableIdleTimeMillis`；若回收不足，可能需缩短该值。  

**总结**  

`minEvictableIdleTimeMillis` 是 DBCP2 连接池的“空闲连接保护器”，通过定义连接被回收前的最小存活时间，平衡了连接复用的效率与数据库资源的合理利用。合理配置该参数（结合业务场景、`maxIdle` 及 `timeBetweenEvictionRunsMillis`），能有效减少连接创建/销毁的开销，提升应用性能。



#### `numTestsPerEvictionRun`

在 Apache Commons DBCP2（数据库连接池）中，`numTestsPerEvictionRun` 是控制**每次驱逐线程运行时验证的空闲连接数量**的核心参数。其核心作用是**平衡连接验证的全面性与性能开销**，确保连接池在高效运行的同时，及时清理无效连接。

**1. 核心作用：限制每次驱逐线程验证的连接数**

DBCP2 的后台驱逐线程（Eviction Thread）会定期扫描连接池中的空闲连接（未被使用的连接），并执行以下操作：  
- 验证连接有效性（若 `testWhileIdle=true`）。  
- 回收超过 `maxIdle` 限制的空闲连接。  

`numTestsPerEvictionRun` 定义了**每次驱逐线程运行时，最多验证的空闲连接数量**：  
- 若空闲连接总数 ≤ `numTestsPerEvictionRun`：所有空闲连接都会被验证。  
- 若空闲连接总数 > `numTestsPerEvictionRun`：仅随机选取 `numTestsPerEvictionRun` 个连接进行验证。  

**2. 默认值3与行为**

- **默认值**：`numTestsPerEvictionRun` 的默认值为 `-1`（表示验证所有空闲连接）。  
- **不设置的风险**：若设为 `-1` 且空闲连接数很大（如数千个），每次驱逐线程运行时需验证所有连接，可能导致数据库压力激增或应用响应延迟。  

**3. 关键关联参数**

`numTestsPerEvictionRun` 需与其他参数协同工作，共同决定连接池的验证效率：

（1）`testWhileIdle`（空闲时验证）  

- **关系**：若 `testWhileIdle=false`，驱逐线程仅回收超量的空闲连接（不验证有效性），`numTestsPerEvictionRun` 会被忽略。  
- **典型场景**：生产环境中通常启用 `testWhileIdle=true`，此时 `numTestsPerEvictionRun` 控制每次验证的连接数。  

（2）`timeBetweenEvictionRunsMillis`（驱逐线程检查间隔）  

- **关系**：若 `numTestsPerEvictionRun` 较小（如 10），但 `timeBetweenEvictionRunsMillis` 较短（如 1 分钟），驱逐线程会更频繁地运行，确保所有空闲连接被逐步验证。  

（3）`maxIdle`（最大空闲连接数）  

- **关系**：若 `maxIdle=100`，而 `numTestsPerEvictionRun=20`，则每次驱逐线程仅验证 20 个连接（即使空闲连接数为 100）。未被验证的连接可能暂时保留，但下次检查时会被覆盖。  

（4）`validationQuery`（验证查询）与 `validationQueryTimeout`（验证超时）  

- **关系**：每次验证连接时需执行 `validationQuery`，`numTestsPerEvictionRun` 越大，验证的总耗时越长（可能影响数据库性能）。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setTestWhileIdle(true);                // 空闲时验证
dataSource.setNumTestsPerEvictionRun(20);         // 每次验证 20 个连接
dataSource.setTimeBetweenEvictionRunsMillis(60000); // 每分钟检查一次
dataSource.setMaxIdle(100);                       // 最大空闲 100 个
dataSource.setValidationQuery("SELECT 1");        // 验证查询
```

- **场景 1：空闲连接数 ≤ 20**  
  驱逐线程每分钟扫描一次，验证所有空闲连接（如 15 个）。若其中 3 个无效，直接移除；剩余 12 个保留。  

- **场景 2：空闲连接数 > 20（如 100）**  
  驱逐线程每分钟随机选取 20 个连接验证。若其中 5 个无效，移除后空闲连接数降至 95（仍 ≤ `maxIdle=100`），无需创建新连接。  

**5. 最佳实践建议**

（1）根据连接池大小调整  

- **小连接池**（如 `maxIdle=50`）：可设为 `-1`（验证所有连接），确保每次检查全面。  
- **大连接池**（如 `maxIdle=500`）：建议设为 `50~100`，平衡验证效率与性能。例如，`numTestsPerEvictionRun=50`，每分钟检查一次，每小时可覆盖所有 500 个连接（50×12次=600次，覆盖 500 个）。  

（2）避免过度验证  

- 若 `numTestsPerEvictionRun` 过大（如 `maxIdle=100` 时设为 100），每次验证需执行 100 次 `validationQuery`，可能增加数据库压力（尤其高并发时）。  

（3）结合 `timeBetweenEvictionRunsMillis` 优化  

- 若 `numTestsPerEvictionRun=20`，`timeBetweenEvictionRunsMillis=30000`（30 分钟），则每小时仅验证 40 个连接（20×2次），可能无法及时清理无效连接。建议缩短间隔（如 1 分钟）或增大 `numTestsPerEvictionRun`（如 50）。  

（4）监控验证性能  

通过连接池的统计接口（如 `getTotalValidationCount()`、`getTotalValidationTimeMillis()`）监控验证次数和耗时，调整 `numTestsPerEvictionRun` 以确保验证总耗时不超过数据库的承受能力。  

**总结**  

`numTestsPerEvictionRun` 是 DBCP2 连接池的“验证效率调节器”，通过限制每次驱逐线程验证的连接数，在确保无效连接被清理的同时，降低对数据库的性能影响。合理设置该参数（结合连接池大小、数据库性能及 `testWhileIdle` 等参数），是连接池长期高效运行的关键。



#### `removeAbandoned`

在 Apache Commons DBCP2（数据库连接池）中，`removeAbandoned` 是控制**检测并移除“被遗弃连接”**的核心参数。其核心作用是**防止因连接未正确释放（泄漏）导致的连接池资源耗尽**，确保连接池长期稳定运行。

**1. 核心作用：检测并回收“被遗弃的连接”**

当应用程序从连接池借出连接（`getConnection()`）后，若**长时间未主动释放连接**（未调用 `connection.close()`），连接池会认为该连接被“遗弃”（Abandoned）。此时，`removeAbandoned` 机制会强制回收这些连接，避免连接池因连接耗尽而无法提供服务。  

**2. 默认值与行为**

- **默认值**：`removeAbandoned` 的默认值为 `false`（禁用）。  
- **启用条件**：需显式设置为 `true`，并配合 `removeAbandonedTimeout`（遗弃超时时间）使用。  

**3. 关键关联参数**

`removeAbandoned` 需与其他参数协同工作，共同决定遗弃连接的检测与回收逻辑：

（1）`removeAbandonedTimeout`（遗弃超时时间）  

- **作用**：定义连接被判定为“遗弃”的超时时间（单位：毫秒）。若连接被借出后超过此时间未被释放（未调用 `close()`），则被标记为遗弃。  
- **默认值**：`300000`（5 分钟）。  
- **建议**：根据业务场景调整。例如，短事务应用可设为 `60000`（1 分钟），长事务应用需适当延长（如 `1800000`，30 分钟）。  

（2）`logAbandoned`（记录遗弃连接）  

- **作用**：若设为 `true`，连接池会在回收遗弃连接时记录日志（如连接被借出的时间、调用栈等），帮助定位连接泄漏的源头。  
- **默认值**：`false`。  

（3）`testWhileIdle`（空闲时验证）与 `validationQuery`（验证查询）  

- **作用**：若 `removeAbandoned=true`，回收遗弃连接前，连接池可能通过 `testWhileIdle` 和 `validationQuery` 验证连接有效性。若连接已失效（如被数据库关闭），则直接丢弃；若有效，则强制回收。  

**4. 工作流程示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setRemoveAbandoned(true);          // 启用遗弃检测
dataSource.setRemoveAbandonedTimeout(60000);  // 60 秒未释放则判定为遗弃
dataSource.setLogAbandoned(true);             // 记录遗弃日志
dataSource.setTestWhileIdle(true);            // 空闲时验证连接
dataSource.setValidationQuery("SELECT 1");    // 验证查询
```

- **场景 1：正常释放连接**  
  应用借出连接后，在 50 秒内调用 `connection.close()` 归还。连接池正常回收，不触发遗弃逻辑。  

- **场景 2：连接被遗弃（未释放）**  
  应用借出连接后，因代码异常或逻辑错误未调用 `close()`，连接被持有 70 秒（超过 `removeAbandonedTimeout=60000`）。此时：  
  1. 后台线程或下次借用连接时，检测到该连接已超时。  
  2. 若 `testWhileIdle=true`，连接池执行 `SELECT 1` 验证连接有效性：  
     - 若验证成功（连接存活）：强制回收该连接（标记为空闲）。  
     - 若验证失败（连接失效）：直接丢弃该连接（不放回池中）。  
  3. 若 `logAbandoned=true`，日志会记录该连接的借出时间、调用栈等信息，帮助排查泄漏。  

**5. 最佳实践建议**

（1）仅在必要时启用  

`removeAbandoned` 会强制回收长时间未释放的连接，可能影响正常业务（如长事务中连接被意外回收）。因此：  
- **推荐场景**：应用中存在频繁的连接泄漏（如未正确关闭连接的代码），或连接池频繁耗尽。  
- **不推荐场景**：应用使用长事务（如批量任务持续数小时），且连接需长时间保持活跃。  

（2）合理设置 `removeAbandonedTimeout`  

- 超时时间过短（如 1 分钟）：可能误回收仍在使用的连接（如长事务），导致业务失败。  
- 超时时间过长（如 30 分钟）：无法及时回收泄漏的连接，连接池仍可能耗尽。  
- **建议**：根据业务平均连接使用时长设置（如短事务应用设为 1~5 分钟，长事务应用设为 10~30 分钟）。  

（3）启用 `logAbandoned` 定位泄漏  

通过 `logAbandoned=true` 记录遗弃连接的调用栈，可快速定位未释放连接的代码位置（如未关闭 `Connection` 的 `try-with-resources` 块缺失）。  

（4）配合连接验证避免误回收  

启用 `testWhileIdle=true` 和 `validationQuery`，确保回收前验证连接有效性。若连接已被数据库关闭，直接丢弃；若仍有效，强制回收以复用。  

（5）监控回收效果  

通过连接池的统计接口（如 `getNumAbandoned()`、`getLastAbandonedTime()`）监控遗弃连接的数量和回收时间，评估策略是否有效。  

**总结**  

`removeAbandoned` 是 DBCP2 连接池的“连接泄漏防御器”，通过检测并回收长时间未释放的连接，防止连接池资源耗尽。合理启用该参数（结合 `removeAbandonedTimeout`、`logAbandoned` 等参数），能有效解决连接泄漏问题，是生产环境中保障连接池稳定性的重要工具。



#### `removeAbandonedTimeout`

在 Apache Commons DBCP2（数据库连接池）中，`removeAbandonedTimeout` 是控制**“被遗弃连接”判定超时时间**的核心参数。其核心作用是**定义连接被标记为“遗弃”的时间阈值**，配合 `removeAbandoned` 参数共同实现连接泄漏的自动检测与回收，防止因连接未正确释放导致的连接池资源耗尽。

**1. 核心作用：定义“遗弃连接”的时间阈值**

当应用程序从连接池借出连接（`getConnection()`）后，若**长时间未主动释放连接**（未调用 `connection.close()`），连接池会认为该连接被“遗弃”（Abandoned）。`removeAbandonedTimeout` 定义了这个“长时间”的具体时长（单位：毫秒）：  
- 若连接被借出后超过此时间未被释放，则被标记为“遗弃连接”。  
- 连接池会强制回收这些遗弃连接（即使它们仍处于活跃状态），避免连接池因连接耗尽而无法服务。  

**2. 默认值与行为**

- **默认值**：`removeAbandonedTimeout` 的默认值为 `300000` 毫秒（即 5 分钟）。  
- **启用条件**：需配合 `removeAbandoned=true`（启用遗弃检测）才能生效。若 `removeAbandoned=false`，该参数会被忽略。  

**3. 关键关联参数**

`removeAbandonedTimeout` 需与其他参数协同工作，共同决定遗弃连接的检测与回收逻辑：

（1）`removeAbandoned`（启用遗弃检测）  

- **关系**：`removeAbandoned` 是“开关”，`removeAbandonedTimeout` 是“阈值”。仅当 `removeAbandoned=true` 时，`removeAbandonedTimeout` 才会生效。  

（2）`logAbandoned`（记录遗弃日志）  

- **作用**：若设为 `true`，连接池会在回收遗弃连接时记录日志（如连接被借出的时间、调用栈等），帮助定位连接泄漏的源头。  

（3）`testWhileIdle`（空闲时验证）与 `validationQuery`（验证查询）  

- **作用**：若 `removeAbandoned=true`，回收遗弃连接前，连接池可能通过 `testWhileIdle` 和 `validationQuery` 验证连接有效性。若连接已失效（如被数据库关闭），则直接丢弃；若有效，则强制回收以复用。  

**4. 工作流程示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setRemoveAbandoned(true);          // 启用遗弃检测
dataSource.setRemoveAbandonedTimeout(60000);  // 60 秒未释放则判定为遗弃
dataSource.setLogAbandoned(true);             // 记录遗弃日志
dataSource.setTestWhileIdle(true);            // 空闲时验证连接
dataSource.setValidationQuery("SELECT 1");    // 验证查询
```

- **场景 1：正常释放连接**  
  应用借出连接后，在 50 秒内调用 `connection.close()` 归还。连接池正常回收，不触发遗弃逻辑。  

- **场景 2：连接被遗弃（未释放）**  
  应用借出连接后，因代码异常或逻辑错误未调用 `close()`，连接被持有 70 秒（超过 `removeAbandonedTimeout=60000`）。此时：  
  1. 后台线程或下次借用连接时，检测到该连接已超时。  
  2. 若 `testWhileIdle=true`，连接池执行 `SELECT 1` 验证连接有效性：  
     - 若验证成功（连接存活）：强制回收该连接（标记为空闲）。  
     - 若验证失败（连接失效）：直接丢弃该连接（不放回池中）。  
  3. 若 `logAbandoned=true`，日志会记录该连接的借出时间、调用栈等信息，帮助排查泄漏。  

**5. 最佳实践建议**

（1）合理设置超时时间  

- **短事务应用**（如 Web 请求，连接使用时长通常几秒到几分钟）：建议设置为 `60000`（1 分钟）~ `180000`（3 分钟），避免误回收仍在使用的连接。  
- **长事务应用**（如批量数据处理，连接需持续数小时）：需适当延长（如 `3600000`，1 小时），避免正常使用中的连接被误判为遗弃。  

（2）启用 `logAbandoned` 定位泄漏  

通过 `logAbandoned=true` 记录遗弃连接的调用栈，可快速定位未释放连接的代码位置（如未关闭 `Connection` 的 `try-with-resources` 块缺失）。  

（3）配合连接验证避免误回收  

启用 `testWhileIdle=true` 和 `validationQuery`，确保回收前验证连接有效性。若连接已被数据库关闭，直接丢弃；若仍有效，强制回收以复用。  

（4）监控回收效果  

通过连接池的统计接口（如 `getNumAbandoned()`、`getLastAbandonedTime()`）监控遗弃连接的数量和回收时间，评估超时时间是否合理。若频繁回收有效连接，需延长超时时间；若连接池频繁耗尽，需缩短超时时间。  

**总结**  

`removeAbandonedTimeout` 是 DBCP2 连接池的“遗弃时间裁判”，通过定义连接被判定为遗弃的超时阈值，配合 `removeAbandoned` 实现连接泄漏的自动检测与回收。合理设置该参数（结合业务场景和其他关联参数），能有效防止连接池因连接泄漏耗尽资源，是保障应用稳定性的关键工具。



#### `logAbandoned`

在 Apache Commons DBCP2（数据库连接池）中，`logAbandoned` 是控制**是否记录“被遗弃连接”详细日志**的核心参数。其核心作用是**通过日志追踪未正确释放的连接**，帮助开发者快速定位连接泄漏（Connection Leak）的源头，从而修复代码中的潜在问题。

**1. 核心作用：记录“被遗弃连接”的关键信息**

当应用程序从连接池借出连接（`getConnection()`）后，若**长时间未主动释放连接**（未调用 `connection.close()`），连接池会判定该连接为“被遗弃”（Abandoned）。此时，若 `logAbandoned` 设为 `true`，连接池会记录以下关键信息到日志中：  
- 连接被借出的时间戳。  
- 连接被判定为遗弃的时间戳（超过 `removeAbandonedTimeout` 后）。  
- 连接的调用栈（Stack Trace）：显示哪段代码借出了连接但未释放。  
- 连接的其他元数据（如连接池名称、连接对象 ID 等）。  

**2. 默认值与行为**

- **默认值**：`logAbandoned` 的默认值为 `false`（不记录日志）。  
- **生效条件**：需同时满足以下两个条件才会触发日志记录：  
  1. `removeAbandoned=true`（启用遗弃连接检测）。  
  2. 连接被借出后超过 `removeAbandonedTimeout`（遗弃超时时间）未被释放。  

**3. 关键关联参数**

`logAbandoned` 需与其他参数协同工作，共同实现连接泄漏的追踪：

（1）`removeAbandoned`（启用遗弃检测）  

- **关系**：`logAbandoned` 是“日志开关”，`removeAbandoned` 是“检测开关”。仅当 `removeAbandoned=true` 时，`logAbandoned` 才会生效。  

（2）`removeAbandonedTimeout`（遗弃超时时间）  

- **关系**：定义连接被判定为“遗弃”的时间阈值（单位：毫秒）。若连接被借出后超过此时间未被释放，才会触发日志记录和回收。  

（3）`remo4veAbandoned` 的回收逻辑  

- 即使 `logAbandoned=true`，连接池仍会强制回收遗弃连接（除非连接已失效）。日志仅用于记录，不影响回收行为。  

**4. 实际行为示例**

假设配置如下：  
```java
BasicDataSource dataSource = new BasicDataSource();
dataSource.setRemoveAbandoned(true);          // 启用遗弃检测
dataSource.setRemoveAbandonedTimeout(60000);  // 60 秒未释放则判定为遗弃
dataSource.setLogAbandoned(true);             // 记录遗弃日志
dataSource.setTestWhileIdle(true);            // 空闲时验证连接
dataSource.setValidationQuery("SELECT 1");    // 验证查询
```

- **场景 1：正常释放连接**  
  应用借出连接后，在 50 秒内调用 `connection.close()` 归还。连接池正常回收，不触发日志记录。  

- **场景 2：连接被遗弃（未释放）**  
  应用借出连接后，因代码异常或逻辑错误未调用 `close()`，连接被持有 70 秒（超过 `removeAbandonedTimeout=60000`）。此时：  
  1. 连接池检测到该连接超时，标记为遗弃。  
  2. 若 `logAbandoned=true`，日志会记录类似以下信息：  
     ```log
     DEBUG org.apache.commons.dbcp2.BasicDataSource - Abandoned connection 'jdbc:mysql://localhost:3306/mydb, User: root' 
     was borrowed at: 2024-05-20 10:00:00, and not returned after 60000ms.
     Stack trace:
         at com.example.MyService.getData(MyService.java:25)
         at com.example.MyController.handleRequest(MyController.java:15)
     ```
  3. 连接池强制回收该连接（若有效）或丢弃（若无效）。  

**5. 最佳实践建议**

（1）仅在怀疑连接泄漏时启用  

`logAbandoned=true` 会生成详细日志（可能包含敏感信息），**不建议长期开启**。推荐在以下场景临时启用：  
- 应用出现“连接池耗尽”异常（`Cannot get a connection from the pool`）。  
- 监控发现连接池的空闲连接数持续低于 `minIdle`。  

（2）结合 `removeAbandonedTimeout` 精准定位  

根据业务场景调整 `removeAbandonedTimeout`，确保日志能捕捉到“真正的泄漏”而非正常长事务：  
- 短事务应用（如 Web 请求）：设为 `60000`（1 分钟）~ `180000`（3 分钟）。  
- 长事务应用（如批量任务）：设为 `3600000`（1 小时）以上。  

（3）分析日志定位泄漏源  

日志中的 `Stack trace` 是关键线索，可直接定位到未释放连接的代码行（如未关闭 `Connection` 的 `try-with-resources` 块缺失）。例如：  
```log
Stack trace:
    at com.example.UserService.queryUser(UserService.java:42)  // 未关闭连接的代码位置
    at com.example.UserController.getUser(UserController.java:18)
```

（4）避免日志泛滥  

若长期开启 `logAbandoned=true`，可能导致日志文件过大。建议：  
- 仅在问题排查期间临时启用。  
- 结合日志框架（如 Log4j2、Logback）的级别控制（设为 `DEBUG` 而非 `INFO`）。  

**总结**  

`logAbandoned` 是 DBCP2 连接池的“泄漏追踪器”，通过记录被遗弃连接的详细日志，帮助开发者快速定位代码中的连接泄漏问题。合理启用该参数（结合 `removeAbandoned` 和 `removeAbandonedTimeout`），能有效解决因连接未释放导致的连接池耗尽问题，是生产环境中排查连接泄漏的核心工具。



### 调试配置参数

借助本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-spring-boot/demo-spring-boot-dbcp) 调试配置参数。



#### 调试 `testOnBorrow` 和 `testOnReturn`

在 `MySQL` 中配置 `general_log=on` 启用日志。

调用接口 `http://localhost:8080/api/v1/testSelectSleep` 观察 `MySQL` 日志输出情况。



#### 调试 `testWhileIdle` 一直空闲时

在 `MySQL` 中配置 `general_log=on` 启用日志。

调用一次接口 `http://localhost:8080/api/v1/testSelectSleep` 以激活 `dbcp` 连接池初始化。

观察 `MySQL` 日志输出情况。



#### 调试 `testWhileIdle` 一直忙时

在 `MySQL` 中配置 `general_log=on` 启用日志。

使用 `wrk` 模拟应用一直忙时，观察 `MySQL` 日志输出情况：

```sh
wrk -t1 -c16 -d150000s --latency --timeout 30 http://localhost:8080/api/v1/testSelectSleep
```

