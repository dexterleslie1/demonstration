## 帐号信息

网站：https://login.qt.io/login

帐号：`gmail`，密码：`Kl`



## 概念

您可以把它想象成一个 **超级强大的“应用程序开发工具包”** 或 **“积木工具箱”**。它的核心目标是让软件开发人员能够用同一套代码，轻松地开发出能运行在不同操作系统（如 Windows、macOS、Linux、Android、iOS）上的应用程序。

---

### 1. 核心定义：一个跨平台的应用程序开发框架

*   **框架**：它不是一门编程语言，而是一个用 **C++** 语言写成的庞大工具集合。它提供了预先写好的代码、工具和规则，让你能更高效地构建复杂、专业的应用程序，而不用从零开始造轮子。
*   **跨平台**：这是 Qt 最著名的特点。你写一次代码，只需要稍微调整（甚至无需调整），就可以在多个平台上编译运行。这极大地节省了开发和维护成本。

### 2. 主要用途和能做什么？

Qt 几乎可以用来开发任何类型的桌面和移动应用，尤其擅长：

*   **传统桌面软件**：如 **Adobe Photoshop Elements、WPS Office、VirtualBox** 等知名软件的部分界面就使用 Qt 开发。
*   **工业与嵌入式系统**：这是 Qt 的强项。汽车的中控仪表盘、医疗设备界面、工业控制面板、智能家居终端等，很多都基于 Qt。因为它性能高，对硬件控制能力强。
*   **图形界面程序**：任何需要窗口、按钮、菜单、图表、3D 效果的软件。
*   **移动应用**：可以开发 Android 和 iOS 的应用。

### 3. Qt 的核心组成部分（就像工具箱里的不同工具）

一个完整的 Qt 不仅仅是你写代码的库，它是一整套生态：

| 组成部分          | 说明                                                         | 类比                                                         |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Qt Library**    | **核心代码库**。提供了创建图形界面、处理文件、连接网络、访问数据库等所有功能的 C++ 类。 | **积木块本身**。提供了各种形状和颜色的积木。                 |
| **Qt Creator**    | **官方集成开发环境**。一个轻量级、强大的代码编辑器，专为 Qt 开发设计，集成了调试、界面设计等功能。 | **工作台和工具**。让你更方便地拼接积木的工作台。             |
| **Qt Designer**   | **可视化UI设计工具**。你可以通过拖拽按钮、文本框等控件来设计界面，它会自动生成对应的代码。 | **界面草图板**。让你先画好蓝图，再根据蓝图找积木。           |
| **qmake / CMake** | **构建工具**。负责管理你的代码，告诉编译器如何把代码和 Qt 库链接起来，最终生成可执行程序。 | **施工说明书**。告诉工人（编译器）如何把积木组装成最终模型。 |
| **Qt Linguist**   | **国际化工具**。可以轻松地为你的应用程序添加多种语言支持。   | **翻译官**。帮助你把模型上的标签换成不同语言。               |

### 4. 一个简单的例子

假设你想创建一个窗口，上面有一个按钮，点击后能弹出“Hello World！”。

*   **没有 Qt**：你需要调用复杂的操作系统底层 API（Windows 和 macOS 的API完全不同），写大量代码来创建窗口、绘制按钮、处理鼠标点击事件。
*   **使用 Qt**：你只需要几行简单的 C++ 代码，调用 Qt 提供的 `QWidget`（窗口）、`QPushButton`（按钮）等类就可以了。Qt 帮你处理了所有底层操作系统的差异。

### 总结

**Qt 是一个基于 C++ 的、跨平台的应用程序开发框架。它提供了一整套工具和代码库，让开发者能高效地构建出拥有精美图形界面的、高性能的软件，并可以轻松地部署到 Windows、Linux、macOS、Android 等多种操作系统上。**

简单说，它就是软件开发者的一个 **“万能高效开发神器”**。



## 历史

好的，Qt 的历史非常精彩，它从一个北欧软件公司的创新项目，发展成为驱动全球无数设备的核心框架。它的发展史大致可以分为以下几个阶段：

---

### 1. 诞生：奇趣科技时代 (1991-1994)

*   **创始人与灵感**：Qt 由 **Haavard Nord** 和 **Eirik Chambe-Eng** 共同创建。他们需要一种能在 Unix 上开发具有良好图形界面的应用程序的方法，但当时的工具（如 Motif）既昂贵又难以使用。
*   **名字的由来**：他们在 Emacs 编辑器中使用字体命令 **`Q-t`** 来生成字母 Q 的特定外观（Quaaak!），并觉得这个缩写看起来很不错。同时，**“Qt”** 在当时的字体下看起来很像 **“Quota”**，但他们澄清这并非本意。官方说法是，它读作 **“cute”** [kjuːt]，但本身不是任何词的缩写。
*   **公司成立**：1994年，他们创立了 **Trolltech**（**奇趣科技**）公司来推广和开发 Qt。“Troll” 在挪威语中既有“巨魔”的意思，也有“魔法”或“有趣”的涵义，体现了公司的技术极客文化。

### 2. 早期发展与 KDE (1996-1998)

*   **开源契机**：1996年，Qt 的一个重要转折点到来。德国程序员 **Matthias Ettrich** 发起了 **KDE** 项目，旨在为 Unix/Linux 创建一个统一、好用的桌面环境。他选择了 Qt 作为其图形工具箱，因为 Qt 是当时唯一能满足其需求的 C++ 库。
*   ** licensing 争议与解决**：Qt 最初是**专有许可**，这与自由软件精神相悖，因此引发了 GNU 阵营的强烈反对，甚至直接催生了另一个竞争项目：GNOME（最初使用 GTK+ 工具包）。
*   **QPL 与 GPL**：为了应对社区的担忧，Trolltech 于 1998 年推出了 **Q Public License**，并在 2000 年为其 Unix 版本增加了 **GPL** 许可。这意味着开发者可以在开源项目中使用 Qt。这一举措极大地促进了 Qt 在 Linux 社区的普及和接纳。

### 3. 扩张与 acquisition 收购 (2000-2008)

*   **跨平台战略**：随着成功，Trolltech 开始将 Qt 移植到更多平台：
    *   **2001年**：发布了 **Qt/Windows** 和 **Qt/macOS** 的**商业版本**，标志着 Qt 正式成为一个真正的跨平台框架。
    *   **2005年**：发布了 **Qt 4**，这是一个里程碑版本。它引入了全新的**图形视图架构**、统一的**跨平台 API** 以及将 GUI 与核心功能分离的模块化系统，奠定了现代 Qt 的基础。
*   **被诺基亚收购**：2008年，手机巨头 **诺基亚** 收购了 Trolltech，并将其重命名为 **Qt Development Frameworks**。诺基亚的战略是使用 Qt 作为其 **Maemo/MeeGo** 智能手机操作系统（如诺基亚 N9）的**核心应用开发框架**，以期与 iOS 和 Android 竞争。

### 4. 诺基亚时代与开源化 (2009-2012)

*   **LGPL 许可**：在诺基亚领导下，Qt 于 2009 年发布了 **LGPL v2.1** 许可版本。这是一个**革命性的举措**，它允许开发者即使在闭源商业项目中使用 Qt，也无需购买商业许可或开源自己的代码。这极大地降低了 Qt 的商业使用门槛，吸引了海量开发者。
*   **战略摇摆与衰落**：随着诺基亚手机业务的衰落和放弃 MeeGo，转向 Windows Phone，Qt 在诺基亚内部的战略地位变得模糊不清，发展一度陷入停滞。

### 5. 独立与重生：Digia 与 The Qt Company (2012-至今)

*   **被 Digia 收购**：2012年，芬兰软件公司 **Digia** 从诺基亚手中收购了 Qt 业务，确保了 Qt 的持续发展。
*   **成立 Qt 公司**：2014年，Digia 将 Qt 业务完全剥离，成立了 **The Qt Company**，专注于 Qt 的开发和支持。
*   **现代发展与繁荣**：
    *   **Qt 5**：2012年发布，带来了**QML** 和 **Qt Quick** 的革命性技术，使声明式UI和流畅动效的开发变得非常简单。同时大幅改进了对**嵌入式系统**和**移动平台**的支持。
    *   **Qt 6**：2020年发布，是又一次重大革新。它专注于满足未来需求：更好的性能（图形堆栈重写）、更现代的 C++（支持 C++17/20）、更高效的开发流程（CMake 成为默认构建系统）。
    *   **应用领域**：如今，Qt 已无处不在，从**汽车数字座舱**、**医疗设备**、**工业自动化**到**Adobe Photoshop Elements**、**VLC 媒体播放器**等知名软件，其背后都有 Qt 的身影。

### Qt 历史大事记简表

| 时间     | 事件                       | 意义                               |
| :------- | :------------------------- | :--------------------------------- |
| **1991** | Haavard 和 Eirik 开始开发  | Qt 项目启动                        |
| **1994** | 成立 Trolltech（奇趣科技） | 公司化运营                         |
| **1996** | KDE 选择 Qt 作为基础       | 获得关键社区支持，但也引发许可争议 |
| **1998** | 推出 QPL 许可              | 向开源迈出第一步                   |
| **2000** | 增加 GPL 许可              | 进一步拥抱开源社区                 |
| **2001** | 发布 Windows 和 macOS 版本 | 成为真正跨平台框架                 |
| **2005** | 发布 Qt 4                  | 里程碑版本，架构现代化             |
| **2008** | 被诺基亚收购               | 进入移动领域战略                   |
| **2009** | 采用 LGPL 许可             | 极大促进商业应用，迎来爆发式增长   |
| **2012** | 被 Digia 收购；Qt 5 发布   | 摆脱困境，QML/Qt Quick 带来革命    |
| **2014** | 成立 The Qt Company        | 独立公司，专注Qt发展               |
| **2020** | 发布 Qt 6                  | 面向未来的又一次重大革新           |

### 总结

Qt 的历史是一部从**解决特定问题**的工具，到被**大型社区项目**选中，经历**许可风波**后通过开源化找到出路，被**巨头收购**后又经历战略摇摆，最终**独立重生**并成为**行业基石**的精彩故事。它的成功源于其卓越的技术设计、关键时刻拥抱开源的决策（尤其是LGPL），以及其强大的跨平台能力，正好契合了嵌入式和物联网时代的发展浪潮。



## 跨平台发布

`todo`



## `MFC`概念

好的，我们来详细解释一下 **MFC开发**。

### 核心定义

**MFC开发** 指的是使用 **Microsoft Foundation Classes** 来开发 Windows 桌面应用程序。

您可以把它理解为：
*   **一套工具包**：MFC 是微软提供的一个 C++ **类库**。
*   **它的目的**：为了简化 Windows 平台的 GUI 程序开发，让开发者不用去记忆和直接调用复杂且庞大的 Windows 底层 API。

---

### 一个生动的比喻：盖房子

开发一个带图形界面的 Windows 程序，就像盖一栋房子。

*   **Windows API**：就像是**一堆积木和最基本的工具**。理论上你可以用它们盖出任何房子，但你需要自己处理每一块积木的摆放，过程极其繁琐、重复且容易出错。
*   **MFC**：就像是**一套预先制作好的“房屋框架”和“门窗模块”**。它用 C++ 类把这些“积木”封装成了墙、门、窗等组件。开发者要盖房子时，直接调用这些现成的“墙”和“窗”就行了，大大提高了效率，减少了重复劳动。

**MFC开发，就是利用这套现成的“框架和模块”来快速搭建Windows程序。**

---

### MFC 的由来和历史背景

要理解 MFC，必须了解它的历史背景，因为它身上有深深的时代烙印：

1.  **早期Windows开发（1990年前后）**：开发GUI程序极其痛苦，必须直接使用 C 语言调用庞大的 **Windows API**。代码冗长，需要处理大量底层细节。
2.  **MFC的诞生（1992年）**：为了应对这种复杂性，微软推出了 MFC。它应用了当时先进的 **“面向对象”** 思想，将窗口、按钮、对话框等GUI元素和消息机制**封装成C++类**。
3.  **它的巨大成功**：在 **90年代到21世纪初**，MFC 是Windows平台GUI开发的**绝对霸主**。Visual C++ 6.0 和 MFC 的组合是那个时代无数桌面软件（如QQ早期版本、迅雷、各类企业管理软件、工业软件）的开发标准。
4.  **如今的地位**：MFC是一个**经典但逐渐过时**的技术。微软早已不再对其进行重大更新，推出了 **.NET Framework（WinForms, WPF）** 等更现代的平台来取代它。但目前仍有大量遗留系统在使用和维护。

---

### MFC开发的核心特点

| 特点                 | 说明                                                         | 类比                                              |
| :------------------- | :----------------------------------------------------------- | :------------------------------------------------ |
| **1. C++ 类库**      | 对 Windows API 的面向对象封装。核心是 `CWinApp`（应用程序类）和 `CWnd`（窗口基类）。所有的控件（如按钮 `CButton`）都派生自这些基类。 | 把散乱的积木（API）打包成了标准的门窗模块（类）。 |
| **2. 文档/视图架构** | MFC一个非常核心和著名的框架，用于将**数据管理**和**数据显示**分离。非常适合开发像记事本、Excel这类需要处理数据文档的应用程序。 | 模型（数据）- 视图（显示）分离思想的早期实践。    |
| **3. 消息映射**      | 将Windows的**消息机制**（如点击按钮、移动鼠标）封装成更易用的形式。开发者不需要处理复杂的消息循环，而是通过宏来指定“当某个消息发生时，调用哪个函数”。 | 一个高效的事件处理分配器。                        |
| **4. 资源编辑器**    | Visual Studio 内置的可视化对话框、菜单、图标编辑器，可以“拖拽”式地设计界面，然后自动生成相关代码。 | 所见即所得的界面设计工具。                        |

---

### MFC 的优缺点

#### 优点（为什么曾经如此成功）

*   **性能优异**：本质是原生C++，直接编译为本地代码，执行效率高。
*   **对Windows支持极好**：可以调用几乎所有Windows特性，控制力极强。
*   **稳定成熟**：经过几十年考验，非常稳定，Bug少。
*   **部署简单**：生成的程序通常只有一个exe加几个dll，几乎不需要额外的运行环境（对比.NET需要框架）。

#### 缺点（为什么现在不推荐新项目使用）

*   **过于古老和陈旧**：设计理念和代码风格停留在20多年前，与现代C++标准脱节。
*   **开发效率低**：相比 C# WinForms/WPF 或 Qt，实现同样功能的界面，代码更繁琐，开发周期更长。
*   **界面丑陋**：默认界面风格是古老的Windows经典样式，难以做出现代化的漂亮UI（虽然可以通过换肤库弥补，但很麻烦）。
*   **学习曲线陡峭**：需要同时熟悉C++、面向对象和Windows底层机制，对新手不友好。
*   **微软已不再积极发展**：官方停止重大更新，新技术支持差。

---

### 总结与现状

*   **MFC开发** 是 **Windows桌面开发一个时代的象征**，是用C++进行原生Windows开发的重要工具。
*   它**简化了但未完全隐藏**Windows API的复杂性，开发者有时仍需了解底层机制。
*   **现状**：
    *   **新项目**：**强烈不推荐**使用MFC启动新项目。应选择 **（C# + WinForms/WPF/UWP）** 或 **（C++ + Qt）** 等更现代、高效的框架。
    *   **旧项目**：目前存在大量的**遗留系统**（特别是在工业控制、嵌入式、传统企业管理软件领域）仍然基于MFC。因此，**维护和更新这些现有系统**是当前MFC开发者的主要工作，市场需求是**维护大于新建**。

所以，学习MFC更像是在**学习一段重要的计算机历史**，或者是为了**维护和改造那些仍在服役的“老功臣”软件**。



## `Qt`和`MFC`区别

好的，Qt 和 MFC 是两大经典的 C++ GUI 开发框架，但它们的设计理念、功能和现代性有着天壤之别。

我们可以通过一个详细的对比表格来清晰了解它们的区别，然后用一个总结来帮你做出选择。

### Qt 与 MFC 核心区别对比表

| 特性维度              | Qt                                                           | MFC                                                          | **核心差异解读**                                             |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 设计与理念**     | **跨平台框架**。一套代码编译到多个平台。采用**现代面向对象设计**，信号与槽机制是核心，解耦性极佳。 | **Windows平台框架**。本质是**对Windows API的C++封装**。遵循文档/视图架构，与Windows紧密绑定。 | Qt是**抽象了操作系统**的现代框架；MFC是**包装了Windows**的传统库。 |
| **2. 跨平台能力**     | **核心优势**。支持Windows, Linux, macOS, Android, iOS, 嵌入式系统等。**真正的“一次编写，到处编译”**。 | **仅支持Windows**。无法移植到其他操作系统。                  | 这是最根本的区别。如果你的项目需要考虑Linux或macOS用户，Qt是唯一选择。 |
| **3. 界面与样式**     | **样式引擎强大**。支持QSS（类似CSS）轻松定制现代化、炫酷的界面。控件外观与操作系统解耦，在任何平台上看起来都一致（也可设置为原生风格）。 | **界面陈旧**。默认是Windows经典样式（如Windows 95/XP）。制作现代化UI非常困难，需要大量自定义绘制或第三方皮肤库。 | Qt能做出更漂亮、更现代的界面，开发体验更好。MFC应用通常给人“老旧”的感觉。 |
| **4. 开发效率与体验** | **高**。清晰的API设计，优秀的文档，强大的集成开发环境Qt Creator。信号与槽机制让事件处理非常直观。 | **较低**。需要熟悉Windows消息机制和文档/视图结构。代码常显得繁琐、冗长。依赖Visual Studio。 | Qt的学习曲线更平滑，开发更愉快。MFC需要了解更多Windows底层细节。 |
| **5. 社区与生态**     | **非常活跃**。由Qt公司和开源社区共同推动，持续更新，紧跟技术潮流（如对QML、3D、Python的支持）。拥有庞大的跨平台社区。 | **维护状态**。微软已停止功能更新，仅做安全维护。社区主要是维护遗留项目的开发者。 | Qt代表着未来和活力，拥有丰富的第三方库和资源。MFC是过去式，生态停滞。 |
| **6. 授权与许可**     | **双重许可**。开源版（GPL/LGPL）和商业版。使用开源版需遵守协议要求（如动态链接）。 | **完全免费**。作为Visual Studio的一部分分发，可免费用于开发。 | MFC在授权上更简单无虑。Qt需要开发者了解开源协议或购买商业许可。 |
| **7. 应用场景**       | **新项目首选**。尤其是需要**跨平台**的项目，如：工业嵌入式HMI、汽车仪表盘、消费软件、移动应用、Linux桌面软件等。 | **遗留系统维护**。主要用于维护和更新**现有的、历史悠久的Windows桌面软件**，如：一些内部企业管理软件、老牌工业控制软件。 | **Qt面向未来和多元生态，MFC连接过去和Windows旧世界。**       |

---

### 总结与选择建议

你可以将 Qt 和 MFC 理解为 **“现代电动汽车”** 和 **“经典燃油老爷车”** 的区别。

*   **Qt 是那辆“现代电动汽车”**：
    *   **技术新**：设计理念先进，功能全面（自动驾驶、智能座舱）。
    *   **环保（跨平台）**：能适应更多道路（操作系统）。
    *   **体验好**：开发顺畅，界面酷炫。
    *   **适合**：**几乎所有新的C++ GUI项目**，尤其是那些有跨平台需求、希望拥有现代化界面和长期维护的项目。

*   **MFC 是那辆“经典燃油老爷车”**：
    *   **年代久**：技术停留在过去，但非常稳定。
    *   **专路专用**：只能在Windows这条老路上开。
    *   **有情怀/不得已**：家里已经有这辆车了（现有系统），修修补补还能用，重新买辆新的不划算。
    *   **适合**：**维护和扩展现有的、用MFC编写的遗留应用程序**。除非有极其特殊的理由（如团队只会MFC且项目极度依赖Windows特性），否则**绝不建议用于新项目**。

**最终选择指南：**

1.  **需要开发一个新项目吗？**
    *   **是** -> **毫不犹豫地选择 Qt**（或者C#/.NET）。
    *   **否，我是要维护一个旧程序** -> 如果旧程序是MFC写的，那你只能继续使用MFC。

2.  **项目需要运行在Linux或macOS上吗？**
    *   **是** -> **只能选择 Qt**。
    *   **否，只在Windows上运行** -> **依然强烈推荐Qt**，因为它能提供更好的开发体验和更漂亮的界面。除非项目非常简单且团队对MFC极其熟悉。

简而言之，**在当今时代，Qt 全面超越了 MFC**。MFC 的价值主要在于其历史遗产的维护，而非新的开发。



## 安装 - `Ubuntu`

>参考链接：https://askubuntu.com/questions/1320562/how-do-i-download-qt5-default-for-ubuntu-20-04-lts

安装 `Qt5`

```sh
sudo apt install -y qtcreator qtbase5-dev qt5-qmake cmake
```



## 创建项目 - 类型

`todo`



## 构建工具 - `cmake` - 概念

>说明：目前 `Qt` 项目主流使用此构建工具管理项目。

### 一句话概括

**CMake 是一个开源、跨平台的构建系统“生成器”，它使用一个统一的配置文件（CMakeLists.txt），来为不同的底层构建工具（如 Make、Ninja、Visual Studio 等）生成对应的项目文件或构建脚本，从而实现“一次编写，处处构建”。**

---

### 为什么需要 CMake？—— 解决的核心问题

想象一下，你的 C++ 项目需要在不同平台上编译：
*   **在 Linux/macOS 上**，开发者习惯使用 `Makefile` 和 `g++/clang`。
*   **在 Windows 上**，开发者可能使用 Visual Studio 的 `.sln` 解决方案文件 和 MSVC 编译器。

如果没有 CMake，你就需要维护至少两套构建配置：一套 `Makefile` 和一套 `.sln` 文件。这非常痛苦。

**CMake 的解决方案是：**
你只需要用一种中立的、统一的语言编写一份构建说明（`CMakeLists.txt`）。然后，CMake 会根据你当前所在的**平台**和**编译器**，**生成**该平台原生支持的构建文件。

*   在 Linux 上，它生成 `Makefile`，你就可以用 `make` 编译。
*   在 Windows 上，它生成 `Visual Studio.sln` 项目文件，你就可以用 VS 打开编译。
*   它还可以生成 `Ninja` 构建文件（更快）、`Xcode` 项目文件等。

**所以，CMake 本身并不直接编译代码，它是一个“元构建系统”，是构建系统的生成器。**

---

### CMake 的核心工作流程

让我们通过一个最简单的例子来看 CMake 是如何工作的。

假设我们有一个项目，只有一个 `main.cpp` 文件。

1.  **编写 CMakeLists.txt**
    在项目根目录创建一个名为 `CMakeLists.txt` 的文件，内容如下：
    ```cmake
    # 指定 CMake 所需的最低版本
    cmake_minimum_required(VERSION 3.10)
    
    # 设置项目名称
    project(MyAwesomeApp)
    
    # 告诉 CMake 我们要创建一个可执行文件
    add_executable(MyAwesomeApp main.cpp)
    ```
    这个文件用 CMake 自己的语法描述了这个项目：项目名是 `MyAwesomeApp`，最终要生成一个同名的可执行文件，源文件是 `main.cpp`。

2.  **生成构建系统（Generate）**
    在源代码目录外，创建一个构建目录（这叫做“外部构建”，是推荐的做法），然后运行 `cmake` 命令，并指定源代码路径。
    ```bash
    mkdir build
    cd build
    cmake .. -G "Unix Makefiles"  # -G 指定生成器，在 Linux/macOS 下通常可省略
    ```
    执行后，CMake 会读取上一级目录（`..`）中的 `CMakeLists.txt` 文件，并在当前 `build` 目录下生成一整套 `Makefile` 等文件。

3.  **执行构建（Build）**
    现在，使用生成的构建文件来编译项目。
    ```bash
    cmake --build .  # 跨平台的构建命令，CMake 会自动调用底层的构建工具（如 make）
    # 或者直接使用底层的构建工具
    make
    ```
    编译完成后，你就能在 `build` 目录下找到生成的可执行文件 `MyAwesomeApp`。

**如果你在 Windows 上，想用 Visual Studio 编译，只需要在第二步指定不同的生成器即可：**
```bash
# 在 PowerShell 或 CMD 中，进入 build 目录后执行
cmake .. -G "Visual Studio 17 2022"
```
执行后，CMake 会生成 `MyAwesomeApp.sln` 解决方案文件。此时，你可以用 Visual Studio 打开它，或者直接使用 `cmake --build .` 命令来编译。

---

### CMake 的主要优势和特点

1.  **强大的跨平台能力**：这是 CMake 诞生的初衷，也是它最核心的价值。
2.  **依赖管理**：CMake 自带强大的**查找依赖包**的功能（`find_package`）。无论是查找系统安装的 Qt、OpenCV 还是 Boost 库，CMake 都有标准化的方式去定位头文件和库路径，极大地简化了第三方库的集成。
3.  **模块化和可扩展性**：大型项目可以被组织成多个子目录，每个子目录可以有自己 `CMakeLists.txt`，最终由顶层的文件统一管理。它还支持编写自定义函数和宏。
4.  **强大的生态系统**：CMake 是 C/C++ 社区的**事实标准**。绝大多数开源 C++ 库（如 Qt、VTK、ITK、OpenCV 等）都直接提供 CMake 的配置文件。现代 IDE（如 CLion、Qt Creator、Visual Studio）都对 CMake 提供了原生、深度的支持。
5.  **测试和打包**：CMake 原生集成了 CTest 用于管理测试，以及 CPack 用于生成安装包（如 DEB、RPM、NSIS 安装程序等）。

---

### CMake 与 qmake / Qbs 的最终对比

| 特性           | qmake (Qt)              | Qbs (Qt)                      | **CMake (行业标准)**                      |
| :------------- | :---------------------- | :---------------------------- | :---------------------------------------- |
| **定位**       | Qt 专用的构建生成器     | 先进的、独立的构建引擎        | **通用的、行业标准的构建生成器**          |
| **工作原理**   | 生成 Makefile           | 直接构建，不生成中间文件      | **生成各种底层构建系统文件**              |
| **语法**       | 简单，专有语法（`.pro`) | 强大，类 QML/JS 语法（`.qbs`) | 自有的脚本语言（`CMakeLists.txt`）        |
| **生态系统**   | 主要在 Qt 生态内        | 小众                          | **极其庞大，是 C++ 世界的基石**           |
| **现状与前景** | Qt 5 主流，Qt 6 中维护  | 独立发展，非主流              | **Qt 6 官方推荐，业界绝对主流，未来可期** |

### 总结

*   **CMake 是什么？** 它是一个**构建系统生成器**，是解决 C++ 跨平台构建问题的**行业标准工具**。
*   **它如何工作？** 你编写中立的 `CMakeLists.txt` 配置文件，CMake 根据目标平台为你生成对应的原生构建文件（如 Makefile、.sln 等）。
*   **我该用吗？** **绝对应该！** 无论你是做 Qt 开发还是一般的 C++ 开发，学习 CMake 都是一项**必备技能**。对于任何**新开始的 C++ 项目，CMake 都是不二之选**。

简单来说，如果你希望在 C++ 领域进行严肃的、跨平台的开发，**掌握 CMake 不是可选项，而是必选项**。它已经取代了 qmake 的历史地位，并凭借其强大的生态成为了无可争议的王者。



## 构建工具 - `qmake` - 概念

好的，我们来用一个简单易懂的方式解释一下 qmake 是什么。

### 一句话概括

**qmake 是一个用来为软件项目自动生成“编译脚本”（比如 Makefile）的工具，它主要由 Qt 公司开发，专门为简化 Qt 程序的编译过程而设计。**

---

### 详细解释

要理解 qmake，我们需要先了解一个 C++ 项目从源代码到可执行文件需要经历什么。

1.  **编写代码**：你写好了 `.h` 头文件和 `.cpp` 源文件。
2.  **编译（Compile）**：编译器（如 g++、clang）需要将每个 `.cpp` 文件编译成机器能识别的目标文件（`.o` 或 `.obj`）。
3.  **链接（Link）**：链接器将所有的目标文件，以及它们所依赖的库（比如 Qt 的库文件 `QtCore.so`, `QtGui.dll` 等）捆绑在一起，最终生成一个可执行文件（如 `.exe` 或 `.app`）。

这个过程如果手动完成会非常繁琐。比如，你需要输入一长串命令来告诉编译器头文件在哪、要链接哪些库等等。这就是 **构建系统（Build System）** 工具出场的原因。

#### qmake 的角色

qmake 就是一个构建系统工具。它的核心工作流程如下：

1.  **你编写一个项目文件**：这个文件通常命名为 `你的项目名.pro`（例如 `myapp.pro`）。这是一个相对简单、人类可读的配置文件。
2.  **你在 `.pro` 文件中说明项目信息**：你用简单的语法告诉 qmake：
    *   项目类型（是生成一个应用程序，还是一个库？）：`TEMPLATE = app`
    *   项目中包含哪些源文件和头文件：`SOURCES = main.cpp widget.cpp`， `HEADERS = widget.h`
    *   需要链接哪些 Qt 模块：`QT += core gui` （如果需要图形界面，还要加上 `widgets`）
    *   其他配置，比如程序的名称、编译选项等。
3.  **qmake 读取 `.pro` 文件并生成 Makefile**：qmake 会根据你项目文件里的描述，**自动生成**一个非常复杂、但完全符合当前平台（Windows、Linux、macOS）和编译器（GCC、MSVC 等）规范的 `Makefile`。
4.  **你使用 Makefile 进行编译**：生成了 `Makefile` 之后，你只需要在命令行输入 `make`（Linux/macOS）或 `nmake`/`mingw32-make`（Windows），构建系统（make 工具）就会根据 `Makefile` 里的指令，自动调用编译器和你，完成编译和链接的所有步骤。

**简单来说，qmake 是一个“构建系统的生成器”，它把你从编写复杂编译命令的劳动中解放了出来。**

---

### 一个简单的 .pro 文件例子

```pro
# 指定这是一个应用程序项目
TEMPLATE = app

# 指定需要使用的 Qt 模块
QT += core gui widgets

# 如果 Qt 版本大于 4，需要加上 widgets 模块（因为 Qt5 开始 GUI 和 Widgets 模块分开了）
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

# 指定目标文件名（生成的可执行文件叫 MyApp）
TARGET = MyApp

# 指定源文件
SOURCES += \
    main.cpp \
    widget.cpp

# 指定头文件
HEADERS += \
    widget.h
```

### qmake 的主要优势（特别是对于 Qt 项目）

*   **对 Qt 特性原生支持**：它能自动处理 Qt 特有的编译步骤，比如**元对象系统（MOC）**、**用户界面编译器（UIC）** 和**资源文件（RCC）**。这是它最强大的地方。
*   **跨平台**：一份简单的 `.pro` 文件可以在 Windows、Linux、macOS 上使用，qmake 会为各个平台生成对应的正确 Makefile。
*   **简单易学**：`.pro` 文件的语法比直接写 CMakeLists.txt 或 Makefile 要简单得多。

### qmake 的现状：qmake 与 CMake

近年来，**CMake** 已经成为了 C++ 社区更主流的构建工具生成器。Qt 6 也开始**官方推荐使用 CMake** 来管理项目，而不是 qmake。

**两者的简单对比：**

| 特性         | qmake                                                        | CMake                                                    |
| :----------- | :----------------------------------------------------------- | :------------------------------------------------------- |
| **定位**     | 主要为 Qt 项目设计，是 Qt 的“原装工具”                       | 通用型 C++ 构建工具，是业界的**事实标准**                |
| **语法**     | 简单、专有                                                   | 更强大、灵活，但学习曲线稍陡                             |
| **生态系统** | 主要在 Qt 生态内                                             | 拥有极其庞大的生态系统，被绝大多数 C++ 开源项目使用      |
| **现状**     | **维护模式**。Qt 5 及之前是默认选择，Qt 6 仍支持，但不再是首选。 | **未来趋势**。是 Qt 6 的推荐构建系统，也是新项目的首选。 |

### 总结

*   **qmake 是一个方便、跨平台的构建工具，尤其适合 Qt 应用程序开发。**
*   它的核心工作是读取简单的 `.pro` 项目文件，然后生成复杂的 `Makefile`。
*   对于学习和维护现有的 Qt 5（或更早）项目，了解 qmake 非常重要。
*   但对于**新开始的 Qt 项目，强烈建议学习并使用 CMake**，因为它更强大，并且是行业和 Qt 未来的发展方向。



## 构建工具 - `Qbs` - 概念

好的，我们来聊聊 **Qbs**，它是 Qt 家族中的另一款构建工具。

### 一句话概括

**Qbs（Qt Build Suite）是一个由 Qt 公司开发的现代化构建工具，它不仅仅生成 Makefile，其设计目标是成为一个功能更强大、更灵活、配置更直观的 qmake 替代品。**

---

### 为什么在有了 qmake 之后，还要开发 Qbs？

要理解 Qbs，首先要知道 qmake 和 Makefile 这类工具的一些局限性：

1.  **两级抽象**：qmake 只是一个“生成器”。它先根据 `.pro` 文件生成 `Makefile`，然后你再调用 `make` 来执行真正的编译。这多了一层间接性，不够直接。
2.  **描述能力有限**：`.pro` 文件的语法相对简单，对于描述非常复杂的构建流程（尤其是涉及自定义构建步骤、复杂的依赖关系时）会变得力不从心。
3.  **不够“智能”**：传统的 `make` 工具基于文件时间戳来判断是否需要重新编译，这有时不够精确和高效。

Qbs 就是为了解决这些问题而诞生的。

### Qbs 的核心思想与特点

Qbs 不再采用“生成 Makefile”的模式，而是一个**真正的构建引擎**。你直接调用 `qbs` 命令，它会自己解析项目文件、分析依赖关系并直接调用编译器进行构建，不再需要中间生成的 `Makefile`。

它的主要特点如下：

#### 1. 基于项目的高级语言
Qbs 使用一种名为 **QML（Qt Modeling Language）** 风格的 **JavaScript** 语法来编写项目文件（通常是 `.qbs` 文件）。这种语法比 qmake 的 `.pro` 文件语法更强大、更结构化、也更易于表达复杂逻辑。

**一个简单的 `application.qbs` 文件示例：**
```javascript
import qbs

CppApplication {
    name: "MyApp"
    files: [
        "*.cpp",
        "*.h"
    ]

    cpp.cxxLanguageVersion: "c++11"

    Depends { name: "Qt.core" }
    Depends { name: "Qt.widgets" }
}
```
可以看到，它的语法更像是在描述一个对象及其属性，非常清晰。

#### 2. 构建图（Build Graph）
Qbs 的核心概念是“构建图”。它会解析你的项目文件及其依赖，在内存中构建一个完整的、精确的依赖关系图。这使得它能做到：
*   **高度精确的增量构建**：只编译真正需要编译的部分，最大程度提升构建速度。
*   **更好的并行构建**：能更智能地调度编译任务，充分利用多核CPU。

#### 3. 强大的依赖模型
Qbs 对模块和产品（Product）之间的依赖关系有原生支持。你可以很容易地定义：
*   一个静态库产品
*   一个依赖于该静态库的应用程序产品
*   一个单元测试产品，依赖于应用程序
Qbs 能自动管理它们之间的依赖和构建顺序。

#### 4. 跨平台抽象
和 qmake 一样，Qbs 也是跨平台的。你可以在项目文件中方便地编写平台相关的条件判断，例如：
```javascript
Group {
    condition: qbs.targetOS.contains("windows")
    files: [ "windows_specific.cpp" ]
}

Group {
    condition: qbs.targetOS.contains("linux")
    files: [ "linux_specific.cpp" ]
}
```

### Qbs 与 qmake / CMake 的对比

| 特性     | qmake                               | **Qbs**                               | CMake                                                  |
| :------- | :---------------------------------- | :------------------------------------ | :----------------------------------------------------- |
| **架构** | 构建系统**生成器**（生成 Makefile） | **独立的构建引擎**（不生成 Makefile） | 构建系统**生成器**（可生成 Makefile、Ninja、VS项目等） |
| **语法** | 简单的专有语法（`.pro`）            | **强大的类 QML/JS 语法**（`.qbs`）    | 自有的脚本语言（`CMakeLists.txt`）                     |
| **理念** | 简单、专注 Qt                       | **强大、灵活、自包含**                | 通用、行业标准、高度可配置                             |
| **状态** | 成熟、维护模式                      | **实验性/小众**                       | **业界标准、蓬勃发展**                                 |

### Qbs 的现状与未来

尽管 Qbs 在技术上有很多优点，但它的发展路径比较曲折：

1.  **曾被视为 qmake 的继任者**：在 Qt 5 时代，Qt 公司曾大力推广 Qbs，希望用它取代 qmake。
2.  **面临 CMake 的激烈竞争**：与此同时，CMake 在 C++ 社区的势头越来越猛，生态越来越完善。
3.  **战略调整**：由于社区采纳度远不及 CMake，Qt 公司后来调整了策略。从 **Qt 6 开始，官方明确将 CMake 作为首选的构建系统**。
4.  **当前定位**：Qbs 目前**不再是 Qt 的默认或推荐构建工具**。它变成了一个由 Qt 公司赞助的**独立开源项目**。它仍然被维护，并且在一些特定领域（如嵌入式开发、需要复杂自定义构建步骤的项目）有其用武之地，但已经不再是主流选择。

### 总结

*   **Qbs 是什么？** 它是一个设计先进、功能强大的**直接构建引擎**，使用类 JavaScript 的语法。
*   **它有什么优点？** 构建模型更精确、配置更灵活、语法更现代。
*   **我应该用它吗？**
    *   对于**大多数新项目，尤其是 Qt 项目，答案是否定的**。你应该选择 **CMake**，因为它是行业标准和 Qt 官方推荐，拥有最广泛的社区和支持。
    *   如果你在一个**特定的、需要高度定制化构建流程**的环境中，并且团队对 Qbs 有研究，那么它可能是一个值得考虑的技术选项。

简单来说，Qbs 是一个“技术上的成功者，但商业/社区上的失败者”。了解它有助于你理解构建工具的发展历程，但为新项目做技术选型时，**CMake 是毫无疑问的首选**。



## 跨平台原理

Qt 的跨平台原理是一个**多层次、系统性的设计**，它通过抽象层、工具链和开发范式来实现"一次编写，到处编译"。以下是其核心原理的详细分解：

---

### **1. 架构概览：分层设计**

```
[ 你的 Qt 应用程序代码 ]
         ↓
[ Qt API 抽象层（QWidgets, QML） ]
         ↓
[ Qt 平台抽象层（QPA - Qt Platform Abstraction）]
         ↓
[ 原生平台 API（Win32, Cocoa, X11, Wayland）]
         ↓
[ 操作系统（Windows, macOS, Linux, ...）]
```

---

### **2. 核心原理一：抽象层设计**

#### **A. GUI 抽象层**
Qt 不直接调用原生 GUI API，而是通过中间层：

```cpp
// 你的代码 - 完全平台无关
QPushButton *button = new QPushButton("Click me");
button->show();

// Qt 内部 - 根据不同平台调用相应实现
```

**各平台后端实现：**
- **Windows** → 调用 `Win32 API` / `DirectWrite` / `Direct2D`
- **macOS** → 调用 `Cocoa` / `AppKit` / `Core Graphics`
- **Linux/X11** → 调用 `Xlib` / `XCB`
- **Linux/Wayland** → 调用 `Wayland` 协议

#### **B. 基础功能抽象**
Qt 为各种操作系统服务提供统一接口：

```cpp
// 文件操作 - 同一套API在不同平台自动适配
QFile file("path/to/file");
file.open(QIODevice::ReadOnly);

// 网络编程
QTcpSocket socket;
socket.connectToHost("example.com", 80);

// 线程管理
QThread *thread = new QThread;
```

---

### **3. 核心原理二：元对象系统（Meta-Object System）**

这是 Qt 的"秘密武器"，通过 C++ 扩展实现信号槽机制：

#### **编译时代码生成（MOC）**
```
[ .h 头文件（含 Q_OBJECT）] 
         → [ MOC 编译器 ] 
         → [ moc_*.cpp 元对象代码 ]
         → [ 与你的代码一起编译 ]
```

**示例：**
```cpp
// 你的头文件
class MyClass : public QObject {
    Q_OBJECT  // ← 这个宏启用元对象系统
public slots:
    void handleClick();
signals:
    void dataChanged();
};

// MOC 自动生成代码（简化示意）
// 为每个类创建元对象，包含信号槽的字符串名称和调用信息
```

**跨平台意义**：MOC 在编译前为每个平台生成适配的胶水代码，确保信号槽机制在所有平台一致工作。

---

### **4. 核心原理三：构建系统与条件编译**

#### **qmake/cmake 的配置系统**
Qt 的构建系统自动检测平台并设置相应参数：

```pro
# .pro 文件示例 - 条件编译
win32 {
    LIBS += -luser32
    DEFINES += WIN32_LEAN_AND_MEAN
}

macx {
    LIBS += -framework Cocoa
}

unix:!macx {
    LIBS += -lX11
}
```

#### **预定义宏**
Qt 提供平台检测宏：
```cpp
#ifdef Q_OS_WIN
    // Windows 特定代码
#elif defined(Q_OS_MAC)
    // macOS 特定代码  
#elif defined(Q_OS_LINUX)
    // Linux 特定代码
#endif
```

---

### **5. 核心原理四：工具链统一**

#### **同一套开发工具**
- **qmake/cmake**：生成各平台原生构建文件（Makefile, .vcxproj, .xcodeproj）
- **Qt Creator**：跨平台 IDE，提供一致的开发体验
- **uic**（UI 编译器）：将 `.ui` 文件编译为平台无关的 C++ 代码
- **rcc**（资源编译器）：将资源文件编译为平台无关的 C++ 代码

#### **资源系统**
```cpp
// 资源文件统一管理，编译进可执行文件
QImage image(":/images/icon.png");  // 冒号表示从资源文件加载
```

---

### **6. 具体平台适配示例**

#### **窗口管理差异处理**
```cpp
// 你的代码
QMainWindow window;
window.show();

// Qt 内部适配
#ifdef Q_OS_WIN
    // 调用 CreateWindowEx, 处理 Win32 消息循环
#elif defined(Q_OS_MAC)
    // 调用 [NSWindow makeKeyAndOrderFront:]
#elif defined(Q_OS_LINUX)
    // 调用 XCreateWindow 或 xdg_surface
#endif
```

#### **文件路径差异处理**
```cpp
QString path = QApplication::applicationDirPath();
// Windows: "C:/Program Files/MyApp"
// macOS:   "/Applications/MyApp.app/Contents/MacOS"
// Linux:   "/usr/bin"
```

---

### **7. 现代 Qt 的跨平台演进**

#### **Qt for WebAssembly**
```cpp
// 同样的代码可编译为 WebAssembly 在浏览器运行
QPushButton *btn = new QPushButton("Run in Browser");
```

#### **Qt for Mobile**
```cpp
// 适配 iOS/Android 触摸界面
QGestureRecognizer::registerRecognizer(new MyGestureRecognizer);
```

---

### **8. 实践中的跨平台考虑**

#### **保持平台无关性**
```cpp
// 推荐做法 - 使用 Qt 抽象
QStandardPaths::displayName(QStandardPaths::DesktopLocation);

// 而不是直接使用平台特定路径
#ifdef Q_OS_WIN
    QString path = "C:/Users/...";
#else
    QString path = "/home/...";
#endif
```

#### **处理不可避免的平台差异**
```cpp
// 集中管理平台相关代码
class PlatformUtils {
public:
    static void setWindowTitleBarColor(QWidget *widget) {
#if defined(Q_OS_WIN)
        // Windows 特定实现
        HWND hwnd = reinterpret_cast<HWND>(widget->winId());
        // ... Win32 API 调用
#elif defined(Q_OS_MAC)
        // macOS 特定实现  
        NSView *view = reinterpret_cast<NSView*>(widget->winId());
        // ... Cocoa 调用
#endif
    }
};
```

---

### **9. 原理验证：编译过程分析**

```
同一份源代码 → 
    ↓
Qt 构建系统根据目标平台配置 →
    ↓
调用平台原生编译器（MSVC, GCC, Clang） →
    ↓
链接对应平台的 Qt 库 →
    ↓
生成原生可执行文件
```

---

### **总结**

Qt 的跨平台原理基于：

1. **抽象层设计** - 统一 API 屏蔽平台差异
2. **元对象系统** - 通过 MOC 实现高级 C++ 特性
3. **工具链统一** - 一套工具生成多平台版本
4. **条件编译** - 优雅处理必要平台差异
5. **资源系统** - 统一管理平台相关资源

这种设计让开发者能够**专注于业务逻辑**，而不用操心底层平台差异，真正实现了"write once, run anywhere"的承诺。



## `QtCreator` - 创建项目

打开 `QtCreator`，点击 `File` > `New File or Project`，在弹出框中选择 `Application` > `Qt Widgets Application`，点击 `Choose` 按钮。

在 `Project Location wizard` 中填写如下信息：

- 项目名称 `Name` 填写为 `demo-qt1`
- 项目创建的根路径 `Create in` 选择 `/home/xxx/Documents`
- 勾选 `Use as default project location`

点击 `Next` 按钮，在 `Define Build System wizard` 中 `Build System` 选择 `CMake`，点击 `Next` 按钮。

在 `Class information wizard` 中填写信息如下：

- `Base class` 选择 `QWidget`（没有菜单栏的窗口应用）
- 取消勾选 `Generate form`（不生成 `ui` 布局文件）
- 其他默认值

点击 `Next` 按钮，`Translation File wizard` 中 `Language` 选中 `<none>`，点击 `Next` 按钮。

在 `Kit Selection wizard` 中 `Select all kits` 和 `Desktop` 都勾选，点击 `Next` 按钮。

在 `Project Management wizard` 中 `Add as a subproject to project` 选中 `<none>`，`Add to version control` 选中 `<none>`，点击 `Finish` 按钮。



## `QtCreator` - `QtCreator`和`Qt`版本对应吗？

>提示：不完全严格对应，但有较强的兼容性关系。两者可以**混合搭配**使用，但某些组合有最佳实践。

**不完全严格对应，但有较强的兼容性关系。** 让我详细解释一下：

### 🔄 **版本关系概述**

#### **松耦合设计**
- **Qt Creator** 是独立的 IDE
- **Qt 库** 是 GUI 框架
- 两者可以**混合搭配**使用，但某些组合有最佳实践

#### **实际兼容情况**
| 组合类型                   | 兼容性 | 说明               |
| -------------------------- | ------ | ------------------ |
| **新版 Creator + 旧版 Qt** | ✅ 优秀 | 向下兼容性好       |
| **旧版 Creator + 新版 Qt** | ⚠️ 有限 | 可能缺少新特性支持 |
| **同代版本**               | ✅ 最佳 | 官方测试组合       |

---

### 📊 **具体兼容性矩阵**

#### **Qt Creator 对 Qt 版本的支持**
| Qt Creator 版本      | Qt 4.x   | Qt 5.9-5.15 | Qt 6.0-6.2 | Qt 6.3+  |
| -------------------- | -------- | ----------- | ---------- | -------- |
| **Creator 3.x-4.10** | ✅ 完整   | ✅ 完整      | ❌ 不支持   | ❌ 不支持 |
| **Creator 4.11-8.0** | ⚠️ 有限   | ✅ 完整      | ✅ 实验性   | ❌ 不支持 |
| **Creator 9.0+**     | ❌ 不支持 | ✅ 完整      | ✅ 完整     | ✅ 完整   |
| **Creator 12.0+**    | ❌ 不支持 | ⚠️ 有限      | ✅ 完整     | ✅ 完整   |

---

### 🎯 **推荐组合策略**

#### **1. 生产环境（稳定性优先）**
```bash
# LTS 组合：最稳定
Qt Creator 8.0 + Qt 5.15.2 LTS
# 或
Qt Creator 11.0 + Qt 6.2.4 LTS
```

#### **2. 新项目开发（功能优先）**
```bash
# 现代组合：享受最新特性
Qt Creator 12.0 + Qt 6.5+ 
```

#### **3. 旧项目维护**
```bash
# 匹配原开发环境
Qt Creator 4.x + Qt 5.9-5.12
```

---

### 🔍 **实际兼容性检查**

#### **验证组合是否工作**
在 Qt Creator 中检查：
1. **工具 → 选项 → Kits**：查看自动检测的工具包
2. **如果显示黄色警告**：可能需要手动配置
3. **绿色对勾**：表示组合可用

#### **常见不兼容现象**
- ❌ QML 语法高亮失效
- ❌ 代码补全不工作  
- ❌ 调试器连接失败
- ❌ 新语法特性报错

---

### 🛠️ **Ubuntu 20.04 实战建议**

#### **系统仓库版本（稳定）**
```bash
sudo apt install qtcreator qt5-default
# 得到：Creator 4.11 + Qt 5.12.8
```

#### **官方安装器组合**
```bash
# 下载 Qt 在线安装器，选择：
Qt 5.15.2 + Qt Creator 8.0    # 经典稳定
Qt 6.2.4 + Qt Creator 9.0    # 平衡选择
Qt 6.5.0 + Qt Creator 12.0   # 最新特性
```

---

### 📝 **版本选择决策指南**

#### **根据需求选择**
| 使用场景         | 推荐组合             | 理由               |
| ---------------- | -------------------- | ------------------ |
| **企业项目**     | Creator 11 + Qt 5.15 | 长期支持，稳定可靠 |
| **个人学习**     | Creator 12 + Qt 6.5  | 体验最新技术       |
| **Ubuntu 20.04** | 系统默认版本         | 免配置，开箱即用   |
| **跨平台开发**   | Creator 12 + Qt 6.2+ | 更好的新平台支持   |

#### **检查命令**
```bash
# 查看当前组合
qtcreator --version
qmake --version

# 预期输出示例：
# Qt Creator 4.11.0
# Qt version 5.12.8
```

---

### ✅ **总结**
- **不需要严格版本匹配**，Qt Creator 设计为向前兼容
- **推荐使用 LTS（长期支持）版本组合**，稳定性最好
- **对于 Ubuntu 20.04**，系统自带的 Qt 5.12.8 + Creator 4.11 是完全可用的组合
- **如果遇到问题**，通常可以通过安装更新版本的 Qt Creator 解决



## `QtCreator` - `QtCreator`和`Qt`版本对照表

以下是 Qt Creator 与 Qt 版本的对照关系表，帮助你选择合适的版本组合：

### 📊 **Qt Creator 与 Qt 版本对照表**

| Qt Creator 版本         | 发布年份  | 推荐的 Qt 版本 | 主要特性                 |
| ----------------------- | --------- | -------------- | ------------------------ |
| **Qt Creator 12+**      | 2023-2024 | Qt 6.4+        | 全面支持 Qt 6，C++20     |
| **Qt Creator 11**       | 2022-2023 | Qt 6.2-6.5     | 改进的 LSP 支持          |
| **Qt Creator 10**       | 2022      | Qt 6.2-6.4     | 初始 Qt 6.2 完整支持     |
| **Qt Creator 9**        | 2021-2022 | Qt 6.0-6.3     | 首个官方支持 Qt 6 的版本 |
| **Qt Creator 8**        | 2021      | Qt 5.15-6.2    | 实验性 Qt 6 支持         |
| **Qt Creator 7**        | 2020-2021 | Qt 5.12-5.15   | 稳定的 Qt 5 支持         |
| **Qt Creator 6**        | 2020      | Qt 5.9-5.15    | 性能改进                 |
| **Qt Creator 5**        | 2019-2020 | Qt 5.9-5.14    | C++17 支持改进           |
| **Qt Creator 4.6-4.15** | 2016-2019 | Qt 5.6-5.12    | 长期支持版本             |

---

### 🎯 **Ubuntu 20.04.3 推荐版本组合**

#### **方案1：系统仓库版本（最稳定）**
```bash
# Ubuntu 20.04 官方仓库版本
sudo apt update
sudo apt install qtcreator       # 约 Qt Creator 4.11
sudo apt install qt5-default     # Qt 5.12.8 LTS
```

#### **方案2：在线安装器（推荐）**
从 https://www.qt.io/download 下载在线安装器，选择：
- **Qt 5.15.2** + **Qt Creator 4.14-8.0**
- 或 **Qt 6.2.4** + **Qt Creator 7.0+**

---

### 🔍 **版本兼容性详情**

#### **Qt Creator 4.x 系列（Ubuntu 20.04 默认）**
| Qt Creator | Qt 5 支持 | Qt 6 支持 | C++标准 |
| ---------- | --------- | --------- | ------- |
| 4.15       | ✓ 5.15    | 实验性    | C++17   |
| 4.14       | ✓ 5.12-15 | 有限      | C++17   |
| 4.11       | ✓ 5.9-15  | ✗         | C++14   |

#### **Qt 5 各版本特性**
| Qt 版本      | 类型     | 支持截止 | 主要特性   |
| ------------ | -------- | -------- | ---------- |
| **5.15 LTS** | 长期支持 | 2023-05  | 最后商业版 |
| **5.12 LTS** | 长期支持 | 2021-05  | 稳定可靠   |
| **5.9 LTS**  | 长期支持 | 2020-05  | 旧系统兼容 |

---

### 🛠️ **检查当前版本**

#### **查看已安装版本**
```bash
# 查看 Qt Creator 版本
qtcreator --version

# 查看 Qt 版本
qmake --version

# 查看所有已安装的 Qt 版本
ls /usr/lib/x86_64-linux-gnu/qt5/
```

#### **Ubuntu 20.04 默认版本**
```bash
# 通常预装版本
Qt Creator: 4.11.0 或 4.14.0
Qt 5: 5.12.8 (系统默认)
```

---

### 📥 **安装最新版本的方法**

#### **方法1：使用官方安装器（推荐）**
```bash
# 下载安装器
wget https://download.qt.io/official_releases/online_installers/qt-unified-linux-x64-online.run
chmod +x qt-unified-linux-x64-online.run
./qt-unified-linux-x64-online.run
```

#### **方法2：使用PPA（第三方）**
```bash
# 添加PPA（谨慎使用）
sudo add-apt-repository ppa:beineri/opt-qt-5.15.2-focal
sudo apt update
sudo apt install qtcreator qt5.15.2
```

---

### ✅ **版本选择建议**

#### **新手/生产环境**
- **Qt 5.15.2** + **Qt Creator 4.14-8.0**
- 理由：稳定性最好，文档丰富，社区支持强

#### **学习/新项目**
- **Qt 6.2+** + **Qt Creator 9.0+**
- 理由：现代特性，长期支持，未来导向

#### **Ubuntu 20.04 兼容性**
```bash
# 验证兼容性
ldd --version | head -1  # 检查glibc版本（应≥2.31）
gcc --version | head -1  # 检查GCC版本（应≥9.3）
```



## `UI`组件 - `QWidget`

`QWidget` 是 Qt 框架中最基础的**图形用户界面 (GUI)** 组件类，它是所有 Qt 可视化控件的基类。简单来说：

---

### 🔍 **核心概念**
1. **父类**：继承自 `QObject`（Qt 对象基类）和 `QPaintDevice`（可绘制对象）
2. **作用**：提供屏幕上的一个可视化矩形区域，能接收用户输入（鼠标/键盘）和绘制界面
3. **特点**：
   - 所有窗口（`QMainWindow`）、对话框（`QDialog`）和控件（按钮、文本框等）都直接或间接继承自 `QWidget`
   - 既可作为独立窗口，也可作为其他控件的子部件（通过父子层级管理布局）

---

### 🛠️ **关键功能**
| 功能类别     | 示例方法/特性                         |
| ------------ | ------------------------------------- |
| **显示控制** | `show()`, `hide()`, `setVisible()`    |
| **几何属性** | `resize()`, `move()`, `setGeometry()` |
| **外观样式** | `setStyleSheet()`, `palette()`        |
| **事件处理** | `mousePressEvent()`, `paintEvent()`   |
| **父子关系** | `setParent()`, `children()`           |

---

### 🌳 **QWidget 继承体系示例**
```plaintext
QObject
└── QWidget
    ├── QMainWindow（主窗口）
    ├── QDialog（对话框）
    ├── QFrame（带边框的控件）
    │   └── QLabel（文本/图片标签）
    ├── QAbstractButton（按钮基类）
    │   ├── QPushButton（普通按钮）
    │   └── QCheckBox（复选框）
    └── ...（其他所有可视化控件）
```

---

### 📝 **基础使用示例**
#### 1. 创建一个空白窗口
```cpp
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    
    QWidget window;
    window.resize(400, 300);          // 设置大小
    window.setWindowTitle("Hello Qt"); // 设置标题
    window.show();                     // 显示窗口
    
    return app.exec();
}
```

#### 2. 创建带子控件的界面
```cpp
#include <QPushButton>

QWidget window;
QPushButton *button = new QPushButton("Click me", &window); // 指定父对象
button->move(50, 50); // 相对父窗口的位置
```

---

### 🎨 **QWidget 与 QML 的区别**
| 特性         | QWidget            | QML                           |
| ------------ | ------------------ | ----------------------------- |
| **编程范式** | 面向对象（C++）    | 声明式（类似JSON+JavaScript） |
| **渲染引擎** | 传统CPU绘制        | 硬件加速（Scene Graph）       |
| **适用场景** | 复杂业务桌面应用   | 动态UI/移动端/嵌入式界面      |
| **样式控制** | 代码/样式表（QSS） | 属性绑定/动画                 |

---

### 💡 **何时选择 QWidget？**
- 需要开发传统的**桌面应用程序**
- 对性能要求高且需要精细控制（如CAD、科学计算软件）
- 项目主要使用 C++ 且需要深度定制控件
- 跨平台需求但不需要炫酷动画效果

---

### 🚀 **进阶方向**
1. **自定义控件**：重写 `paintEvent()` 实现特殊绘制
   ```cpp
   class CircleWidget : public QWidget {
   protected:
       void paintEvent(QPaintEvent*) override {
           QPainter painter(this);
           painter.drawEllipse(rect());
       }
   };
   ```
2. **事件处理**：覆写 `keyPressEvent()`、`mouseMoveEvent()` 等
3. **样式定制**：使用 Qt Style Sheets（类似CSS）
   ```cpp
   widget->setStyleSheet("background: #FF0000; border-radius: 10px;");
   ```

