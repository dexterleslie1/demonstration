## 概念

您可以把它想象成一个 **超级强大的“应用程序开发工具包”** 或 **“积木工具箱”**。它的核心目标是让软件开发人员能够用同一套代码，轻松地开发出能运行在不同操作系统（如 Windows、macOS、Linux、Android、iOS）上的应用程序。

---

### 1. 核心定义：一个跨平台的应用程序开发框架

*   **框架**：它不是一门编程语言，而是一个用 **C++** 语言写成的庞大工具集合。它提供了预先写好的代码、工具和规则，让你能更高效地构建复杂、专业的应用程序，而不用从零开始造轮子。
*   **跨平台**：这是 Qt 最著名的特点。你写一次代码，只需要稍微调整（甚至无需调整），就可以在多个平台上编译运行。这极大地节省了开发和维护成本。

### 2. 主要用途和能做什么？

Qt 几乎可以用来开发任何类型的桌面和移动应用，尤其擅长：

*   **传统桌面软件**：如 **Adobe Photoshop Elements、WPS Office、VirtualBox** 等知名软件的部分界面就使用 Qt 开发。
*   **工业与嵌入式系统**：这是 Qt 的强项。汽车的中控仪表盘、医疗设备界面、工业控制面板、智能家居终端等，很多都基于 Qt。因为它性能高，对硬件控制能力强。
*   **图形界面程序**：任何需要窗口、按钮、菜单、图表、3D 效果的软件。
*   **移动应用**：可以开发 Android 和 iOS 的应用。

### 3. Qt 的核心组成部分（就像工具箱里的不同工具）

一个完整的 Qt 不仅仅是你写代码的库，它是一整套生态：

| 组成部分          | 说明                                                         | 类比                                                         |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Qt Library**    | **核心代码库**。提供了创建图形界面、处理文件、连接网络、访问数据库等所有功能的 C++ 类。 | **积木块本身**。提供了各种形状和颜色的积木。                 |
| **Qt Creator**    | **官方集成开发环境**。一个轻量级、强大的代码编辑器，专为 Qt 开发设计，集成了调试、界面设计等功能。 | **工作台和工具**。让你更方便地拼接积木的工作台。             |
| **Qt Designer**   | **可视化UI设计工具**。你可以通过拖拽按钮、文本框等控件来设计界面，它会自动生成对应的代码。 | **界面草图板**。让你先画好蓝图，再根据蓝图找积木。           |
| **qmake / CMake** | **构建工具**。负责管理你的代码，告诉编译器如何把代码和 Qt 库链接起来，最终生成可执行程序。 | **施工说明书**。告诉工人（编译器）如何把积木组装成最终模型。 |
| **Qt Linguist**   | **国际化工具**。可以轻松地为你的应用程序添加多种语言支持。   | **翻译官**。帮助你把模型上的标签换成不同语言。               |

### 4. 一个简单的例子

假设你想创建一个窗口，上面有一个按钮，点击后能弹出“Hello World！”。

*   **没有 Qt**：你需要调用复杂的操作系统底层 API（Windows 和 macOS 的API完全不同），写大量代码来创建窗口、绘制按钮、处理鼠标点击事件。
*   **使用 Qt**：你只需要几行简单的 C++ 代码，调用 Qt 提供的 `QWidget`（窗口）、`QPushButton`（按钮）等类就可以了。Qt 帮你处理了所有底层操作系统的差异。

### 总结

**Qt 是一个基于 C++ 的、跨平台的应用程序开发框架。它提供了一整套工具和代码库，让开发者能高效地构建出拥有精美图形界面的、高性能的软件，并可以轻松地部署到 Windows、Linux、macOS、Android 等多种操作系统上。**

简单说，它就是软件开发者的一个 **“万能高效开发神器”**。



## 历史

好的，Qt 的历史非常精彩，它从一个北欧软件公司的创新项目，发展成为驱动全球无数设备的核心框架。它的发展史大致可以分为以下几个阶段：

---

### 1. 诞生：奇趣科技时代 (1991-1994)

*   **创始人与灵感**：Qt 由 **Haavard Nord** 和 **Eirik Chambe-Eng** 共同创建。他们需要一种能在 Unix 上开发具有良好图形界面的应用程序的方法，但当时的工具（如 Motif）既昂贵又难以使用。
*   **名字的由来**：他们在 Emacs 编辑器中使用字体命令 **`Q-t`** 来生成字母 Q 的特定外观（Quaaak!），并觉得这个缩写看起来很不错。同时，**“Qt”** 在当时的字体下看起来很像 **“Quota”**，但他们澄清这并非本意。官方说法是，它读作 **“cute”** [kjuːt]，但本身不是任何词的缩写。
*   **公司成立**：1994年，他们创立了 **Trolltech**（**奇趣科技**）公司来推广和开发 Qt。“Troll” 在挪威语中既有“巨魔”的意思，也有“魔法”或“有趣”的涵义，体现了公司的技术极客文化。

### 2. 早期发展与 KDE (1996-1998)

*   **开源契机**：1996年，Qt 的一个重要转折点到来。德国程序员 **Matthias Ettrich** 发起了 **KDE** 项目，旨在为 Unix/Linux 创建一个统一、好用的桌面环境。他选择了 Qt 作为其图形工具箱，因为 Qt 是当时唯一能满足其需求的 C++ 库。
*   ** licensing 争议与解决**：Qt 最初是**专有许可**，这与自由软件精神相悖，因此引发了 GNU 阵营的强烈反对，甚至直接催生了另一个竞争项目：GNOME（最初使用 GTK+ 工具包）。
*   **QPL 与 GPL**：为了应对社区的担忧，Trolltech 于 1998 年推出了 **Q Public License**，并在 2000 年为其 Unix 版本增加了 **GPL** 许可。这意味着开发者可以在开源项目中使用 Qt。这一举措极大地促进了 Qt 在 Linux 社区的普及和接纳。

### 3. 扩张与 acquisition 收购 (2000-2008)

*   **跨平台战略**：随着成功，Trolltech 开始将 Qt 移植到更多平台：
    *   **2001年**：发布了 **Qt/Windows** 和 **Qt/macOS** 的**商业版本**，标志着 Qt 正式成为一个真正的跨平台框架。
    *   **2005年**：发布了 **Qt 4**，这是一个里程碑版本。它引入了全新的**图形视图架构**、统一的**跨平台 API** 以及将 GUI 与核心功能分离的模块化系统，奠定了现代 Qt 的基础。
*   **被诺基亚收购**：2008年，手机巨头 **诺基亚** 收购了 Trolltech，并将其重命名为 **Qt Development Frameworks**。诺基亚的战略是使用 Qt 作为其 **Maemo/MeeGo** 智能手机操作系统（如诺基亚 N9）的**核心应用开发框架**，以期与 iOS 和 Android 竞争。

### 4. 诺基亚时代与开源化 (2009-2012)

*   **LGPL 许可**：在诺基亚领导下，Qt 于 2009 年发布了 **LGPL v2.1** 许可版本。这是一个**革命性的举措**，它允许开发者即使在闭源商业项目中使用 Qt，也无需购买商业许可或开源自己的代码。这极大地降低了 Qt 的商业使用门槛，吸引了海量开发者。
*   **战略摇摆与衰落**：随着诺基亚手机业务的衰落和放弃 MeeGo，转向 Windows Phone，Qt 在诺基亚内部的战略地位变得模糊不清，发展一度陷入停滞。

### 5. 独立与重生：Digia 与 The Qt Company (2012-至今)

*   **被 Digia 收购**：2012年，芬兰软件公司 **Digia** 从诺基亚手中收购了 Qt 业务，确保了 Qt 的持续发展。
*   **成立 Qt 公司**：2014年，Digia 将 Qt 业务完全剥离，成立了 **The Qt Company**，专注于 Qt 的开发和支持。
*   **现代发展与繁荣**：
    *   **Qt 5**：2012年发布，带来了**QML** 和 **Qt Quick** 的革命性技术，使声明式UI和流畅动效的开发变得非常简单。同时大幅改进了对**嵌入式系统**和**移动平台**的支持。
    *   **Qt 6**：2020年发布，是又一次重大革新。它专注于满足未来需求：更好的性能（图形堆栈重写）、更现代的 C++（支持 C++17/20）、更高效的开发流程（CMake 成为默认构建系统）。
    *   **应用领域**：如今，Qt 已无处不在，从**汽车数字座舱**、**医疗设备**、**工业自动化**到**Adobe Photoshop Elements**、**VLC 媒体播放器**等知名软件，其背后都有 Qt 的身影。

### Qt 历史大事记简表

| 时间     | 事件                       | 意义                               |
| :------- | :------------------------- | :--------------------------------- |
| **1991** | Haavard 和 Eirik 开始开发  | Qt 项目启动                        |
| **1994** | 成立 Trolltech（奇趣科技） | 公司化运营                         |
| **1996** | KDE 选择 Qt 作为基础       | 获得关键社区支持，但也引发许可争议 |
| **1998** | 推出 QPL 许可              | 向开源迈出第一步                   |
| **2000** | 增加 GPL 许可              | 进一步拥抱开源社区                 |
| **2001** | 发布 Windows 和 macOS 版本 | 成为真正跨平台框架                 |
| **2005** | 发布 Qt 4                  | 里程碑版本，架构现代化             |
| **2008** | 被诺基亚收购               | 进入移动领域战略                   |
| **2009** | 采用 LGPL 许可             | 极大促进商业应用，迎来爆发式增长   |
| **2012** | 被 Digia 收购；Qt 5 发布   | 摆脱困境，QML/Qt Quick 带来革命    |
| **2014** | 成立 The Qt Company        | 独立公司，专注Qt发展               |
| **2020** | 发布 Qt 6                  | 面向未来的又一次重大革新           |

### 总结

Qt 的历史是一部从**解决特定问题**的工具，到被**大型社区项目**选中，经历**许可风波**后通过开源化找到出路，被**巨头收购**后又经历战略摇摆，最终**独立重生**并成为**行业基石**的精彩故事。它的成功源于其卓越的技术设计、关键时刻拥抱开源的决策（尤其是LGPL），以及其强大的跨平台能力，正好契合了嵌入式和物联网时代的发展浪潮。



## 跨平台发布

`todo`



## `MFC`概念

好的，我们来详细解释一下 **MFC开发**。

### 核心定义

**MFC开发** 指的是使用 **Microsoft Foundation Classes** 来开发 Windows 桌面应用程序。

您可以把它理解为：
*   **一套工具包**：MFC 是微软提供的一个 C++ **类库**。
*   **它的目的**：为了简化 Windows 平台的 GUI 程序开发，让开发者不用去记忆和直接调用复杂且庞大的 Windows 底层 API。

---

### 一个生动的比喻：盖房子

开发一个带图形界面的 Windows 程序，就像盖一栋房子。

*   **Windows API**：就像是**一堆积木和最基本的工具**。理论上你可以用它们盖出任何房子，但你需要自己处理每一块积木的摆放，过程极其繁琐、重复且容易出错。
*   **MFC**：就像是**一套预先制作好的“房屋框架”和“门窗模块”**。它用 C++ 类把这些“积木”封装成了墙、门、窗等组件。开发者要盖房子时，直接调用这些现成的“墙”和“窗”就行了，大大提高了效率，减少了重复劳动。

**MFC开发，就是利用这套现成的“框架和模块”来快速搭建Windows程序。**

---

### MFC 的由来和历史背景

要理解 MFC，必须了解它的历史背景，因为它身上有深深的时代烙印：

1.  **早期Windows开发（1990年前后）**：开发GUI程序极其痛苦，必须直接使用 C 语言调用庞大的 **Windows API**。代码冗长，需要处理大量底层细节。
2.  **MFC的诞生（1992年）**：为了应对这种复杂性，微软推出了 MFC。它应用了当时先进的 **“面向对象”** 思想，将窗口、按钮、对话框等GUI元素和消息机制**封装成C++类**。
3.  **它的巨大成功**：在 **90年代到21世纪初**，MFC 是Windows平台GUI开发的**绝对霸主**。Visual C++ 6.0 和 MFC 的组合是那个时代无数桌面软件（如QQ早期版本、迅雷、各类企业管理软件、工业软件）的开发标准。
4.  **如今的地位**：MFC是一个**经典但逐渐过时**的技术。微软早已不再对其进行重大更新，推出了 **.NET Framework（WinForms, WPF）** 等更现代的平台来取代它。但目前仍有大量遗留系统在使用和维护。

---

### MFC开发的核心特点

| 特点                 | 说明                                                         | 类比                                              |
| :------------------- | :----------------------------------------------------------- | :------------------------------------------------ |
| **1. C++ 类库**      | 对 Windows API 的面向对象封装。核心是 `CWinApp`（应用程序类）和 `CWnd`（窗口基类）。所有的控件（如按钮 `CButton`）都派生自这些基类。 | 把散乱的积木（API）打包成了标准的门窗模块（类）。 |
| **2. 文档/视图架构** | MFC一个非常核心和著名的框架，用于将**数据管理**和**数据显示**分离。非常适合开发像记事本、Excel这类需要处理数据文档的应用程序。 | 模型（数据）- 视图（显示）分离思想的早期实践。    |
| **3. 消息映射**      | 将Windows的**消息机制**（如点击按钮、移动鼠标）封装成更易用的形式。开发者不需要处理复杂的消息循环，而是通过宏来指定“当某个消息发生时，调用哪个函数”。 | 一个高效的事件处理分配器。                        |
| **4. 资源编辑器**    | Visual Studio 内置的可视化对话框、菜单、图标编辑器，可以“拖拽”式地设计界面，然后自动生成相关代码。 | 所见即所得的界面设计工具。                        |

---

### MFC 的优缺点

#### 优点（为什么曾经如此成功）

*   **性能优异**：本质是原生C++，直接编译为本地代码，执行效率高。
*   **对Windows支持极好**：可以调用几乎所有Windows特性，控制力极强。
*   **稳定成熟**：经过几十年考验，非常稳定，Bug少。
*   **部署简单**：生成的程序通常只有一个exe加几个dll，几乎不需要额外的运行环境（对比.NET需要框架）。

#### 缺点（为什么现在不推荐新项目使用）

*   **过于古老和陈旧**：设计理念和代码风格停留在20多年前，与现代C++标准脱节。
*   **开发效率低**：相比 C# WinForms/WPF 或 Qt，实现同样功能的界面，代码更繁琐，开发周期更长。
*   **界面丑陋**：默认界面风格是古老的Windows经典样式，难以做出现代化的漂亮UI（虽然可以通过换肤库弥补，但很麻烦）。
*   **学习曲线陡峭**：需要同时熟悉C++、面向对象和Windows底层机制，对新手不友好。
*   **微软已不再积极发展**：官方停止重大更新，新技术支持差。

---

### 总结与现状

*   **MFC开发** 是 **Windows桌面开发一个时代的象征**，是用C++进行原生Windows开发的重要工具。
*   它**简化了但未完全隐藏**Windows API的复杂性，开发者有时仍需了解底层机制。
*   **现状**：
    *   **新项目**：**强烈不推荐**使用MFC启动新项目。应选择 **（C# + WinForms/WPF/UWP）** 或 **（C++ + Qt）** 等更现代、高效的框架。
    *   **旧项目**：目前存在大量的**遗留系统**（特别是在工业控制、嵌入式、传统企业管理软件领域）仍然基于MFC。因此，**维护和更新这些现有系统**是当前MFC开发者的主要工作，市场需求是**维护大于新建**。

所以，学习MFC更像是在**学习一段重要的计算机历史**，或者是为了**维护和改造那些仍在服役的“老功臣”软件**。



## `Qt`和`MFC`区别

好的，Qt 和 MFC 是两大经典的 C++ GUI 开发框架，但它们的设计理念、功能和现代性有着天壤之别。

我们可以通过一个详细的对比表格来清晰了解它们的区别，然后用一个总结来帮你做出选择。

### Qt 与 MFC 核心区别对比表

| 特性维度              | Qt                                                           | MFC                                                          | **核心差异解读**                                             |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 设计与理念**     | **跨平台框架**。一套代码编译到多个平台。采用**现代面向对象设计**，信号与槽机制是核心，解耦性极佳。 | **Windows平台框架**。本质是**对Windows API的C++封装**。遵循文档/视图架构，与Windows紧密绑定。 | Qt是**抽象了操作系统**的现代框架；MFC是**包装了Windows**的传统库。 |
| **2. 跨平台能力**     | **核心优势**。支持Windows, Linux, macOS, Android, iOS, 嵌入式系统等。**真正的“一次编写，到处编译”**。 | **仅支持Windows**。无法移植到其他操作系统。                  | 这是最根本的区别。如果你的项目需要考虑Linux或macOS用户，Qt是唯一选择。 |
| **3. 界面与样式**     | **样式引擎强大**。支持QSS（类似CSS）轻松定制现代化、炫酷的界面。控件外观与操作系统解耦，在任何平台上看起来都一致（也可设置为原生风格）。 | **界面陈旧**。默认是Windows经典样式（如Windows 95/XP）。制作现代化UI非常困难，需要大量自定义绘制或第三方皮肤库。 | Qt能做出更漂亮、更现代的界面，开发体验更好。MFC应用通常给人“老旧”的感觉。 |
| **4. 开发效率与体验** | **高**。清晰的API设计，优秀的文档，强大的集成开发环境Qt Creator。信号与槽机制让事件处理非常直观。 | **较低**。需要熟悉Windows消息机制和文档/视图结构。代码常显得繁琐、冗长。依赖Visual Studio。 | Qt的学习曲线更平滑，开发更愉快。MFC需要了解更多Windows底层细节。 |
| **5. 社区与生态**     | **非常活跃**。由Qt公司和开源社区共同推动，持续更新，紧跟技术潮流（如对QML、3D、Python的支持）。拥有庞大的跨平台社区。 | **维护状态**。微软已停止功能更新，仅做安全维护。社区主要是维护遗留项目的开发者。 | Qt代表着未来和活力，拥有丰富的第三方库和资源。MFC是过去式，生态停滞。 |
| **6. 授权与许可**     | **双重许可**。开源版（GPL/LGPL）和商业版。使用开源版需遵守协议要求（如动态链接）。 | **完全免费**。作为Visual Studio的一部分分发，可免费用于开发。 | MFC在授权上更简单无虑。Qt需要开发者了解开源协议或购买商业许可。 |
| **7. 应用场景**       | **新项目首选**。尤其是需要**跨平台**的项目，如：工业嵌入式HMI、汽车仪表盘、消费软件、移动应用、Linux桌面软件等。 | **遗留系统维护**。主要用于维护和更新**现有的、历史悠久的Windows桌面软件**，如：一些内部企业管理软件、老牌工业控制软件。 | **Qt面向未来和多元生态，MFC连接过去和Windows旧世界。**       |

---

### 总结与选择建议

你可以将 Qt 和 MFC 理解为 **“现代电动汽车”** 和 **“经典燃油老爷车”** 的区别。

*   **Qt 是那辆“现代电动汽车”**：
    *   **技术新**：设计理念先进，功能全面（自动驾驶、智能座舱）。
    *   **环保（跨平台）**：能适应更多道路（操作系统）。
    *   **体验好**：开发顺畅，界面酷炫。
    *   **适合**：**几乎所有新的C++ GUI项目**，尤其是那些有跨平台需求、希望拥有现代化界面和长期维护的项目。

*   **MFC 是那辆“经典燃油老爷车”**：
    *   **年代久**：技术停留在过去，但非常稳定。
    *   **专路专用**：只能在Windows这条老路上开。
    *   **有情怀/不得已**：家里已经有这辆车了（现有系统），修修补补还能用，重新买辆新的不划算。
    *   **适合**：**维护和扩展现有的、用MFC编写的遗留应用程序**。除非有极其特殊的理由（如团队只会MFC且项目极度依赖Windows特性），否则**绝不建议用于新项目**。

**最终选择指南：**

1.  **需要开发一个新项目吗？**
    *   **是** -> **毫不犹豫地选择 Qt**（或者C#/.NET）。
    *   **否，我是要维护一个旧程序** -> 如果旧程序是MFC写的，那你只能继续使用MFC。

2.  **项目需要运行在Linux或macOS上吗？**
    *   **是** -> **只能选择 Qt**。
    *   **否，只在Windows上运行** -> **依然强烈推荐Qt**，因为它能提供更好的开发体验和更漂亮的界面。除非项目非常简单且团队对MFC极其熟悉。

简而言之，**在当今时代，Qt 全面超越了 MFC**。MFC 的价值主要在于其历史遗产的维护，而非新的开发。



## 安装 - `Ubuntu`

>参考链接：https://askubuntu.com/questions/1320562/how-do-i-download-qt5-default-for-ubuntu-20-04-lts

安装 `Qt5`

```sh
sudo apt install -y qtcreator qtbase5-dev qt5-qmake cmake
```



## 创建项目 - 类型

`todo`



## 构建工具 - `cmake` - 概念

>说明：目前 `Qt` 项目主流使用此构建工具管理项目。

### 一句话概括

**CMake 是一个开源、跨平台的构建系统“生成器”，它使用一个统一的配置文件（CMakeLists.txt），来为不同的底层构建工具（如 Make、Ninja、Visual Studio 等）生成对应的项目文件或构建脚本，从而实现“一次编写，处处构建”。**

---

### 为什么需要 CMake？—— 解决的核心问题

想象一下，你的 C++ 项目需要在不同平台上编译：
*   **在 Linux/macOS 上**，开发者习惯使用 `Makefile` 和 `g++/clang`。
*   **在 Windows 上**，开发者可能使用 Visual Studio 的 `.sln` 解决方案文件 和 MSVC 编译器。

如果没有 CMake，你就需要维护至少两套构建配置：一套 `Makefile` 和一套 `.sln` 文件。这非常痛苦。

**CMake 的解决方案是：**
你只需要用一种中立的、统一的语言编写一份构建说明（`CMakeLists.txt`）。然后，CMake 会根据你当前所在的**平台**和**编译器**，**生成**该平台原生支持的构建文件。

*   在 Linux 上，它生成 `Makefile`，你就可以用 `make` 编译。
*   在 Windows 上，它生成 `Visual Studio.sln` 项目文件，你就可以用 VS 打开编译。
*   它还可以生成 `Ninja` 构建文件（更快）、`Xcode` 项目文件等。

**所以，CMake 本身并不直接编译代码，它是一个“元构建系统”，是构建系统的生成器。**

---

### CMake 的核心工作流程

让我们通过一个最简单的例子来看 CMake 是如何工作的。

假设我们有一个项目，只有一个 `main.cpp` 文件。

1.  **编写 CMakeLists.txt**
    在项目根目录创建一个名为 `CMakeLists.txt` 的文件，内容如下：
    ```cmake
    # 指定 CMake 所需的最低版本
    cmake_minimum_required(VERSION 3.10)
    
    # 设置项目名称
    project(MyAwesomeApp)
    
    # 告诉 CMake 我们要创建一个可执行文件
    add_executable(MyAwesomeApp main.cpp)
    ```
    这个文件用 CMake 自己的语法描述了这个项目：项目名是 `MyAwesomeApp`，最终要生成一个同名的可执行文件，源文件是 `main.cpp`。

2.  **生成构建系统（Generate）**
    在源代码目录外，创建一个构建目录（这叫做“外部构建”，是推荐的做法），然后运行 `cmake` 命令，并指定源代码路径。
    ```bash
    mkdir build
    cd build
    cmake .. -G "Unix Makefiles"  # -G 指定生成器，在 Linux/macOS 下通常可省略
    ```
    执行后，CMake 会读取上一级目录（`..`）中的 `CMakeLists.txt` 文件，并在当前 `build` 目录下生成一整套 `Makefile` 等文件。

3.  **执行构建（Build）**
    现在，使用生成的构建文件来编译项目。
    ```bash
    cmake --build .  # 跨平台的构建命令，CMake 会自动调用底层的构建工具（如 make）
    # 或者直接使用底层的构建工具
    make
    ```
    编译完成后，你就能在 `build` 目录下找到生成的可执行文件 `MyAwesomeApp`。

**如果你在 Windows 上，想用 Visual Studio 编译，只需要在第二步指定不同的生成器即可：**
```bash
# 在 PowerShell 或 CMD 中，进入 build 目录后执行
cmake .. -G "Visual Studio 17 2022"
```
执行后，CMake 会生成 `MyAwesomeApp.sln` 解决方案文件。此时，你可以用 Visual Studio 打开它，或者直接使用 `cmake --build .` 命令来编译。

---

### CMake 的主要优势和特点

1.  **强大的跨平台能力**：这是 CMake 诞生的初衷，也是它最核心的价值。
2.  **依赖管理**：CMake 自带强大的**查找依赖包**的功能（`find_package`）。无论是查找系统安装的 Qt、OpenCV 还是 Boost 库，CMake 都有标准化的方式去定位头文件和库路径，极大地简化了第三方库的集成。
3.  **模块化和可扩展性**：大型项目可以被组织成多个子目录，每个子目录可以有自己 `CMakeLists.txt`，最终由顶层的文件统一管理。它还支持编写自定义函数和宏。
4.  **强大的生态系统**：CMake 是 C/C++ 社区的**事实标准**。绝大多数开源 C++ 库（如 Qt、VTK、ITK、OpenCV 等）都直接提供 CMake 的配置文件。现代 IDE（如 CLion、Qt Creator、Visual Studio）都对 CMake 提供了原生、深度的支持。
5.  **测试和打包**：CMake 原生集成了 CTest 用于管理测试，以及 CPack 用于生成安装包（如 DEB、RPM、NSIS 安装程序等）。

---

### CMake 与 qmake / Qbs 的最终对比

| 特性           | qmake (Qt)              | Qbs (Qt)                      | **CMake (行业标准)**                      |
| :------------- | :---------------------- | :---------------------------- | :---------------------------------------- |
| **定位**       | Qt 专用的构建生成器     | 先进的、独立的构建引擎        | **通用的、行业标准的构建生成器**          |
| **工作原理**   | 生成 Makefile           | 直接构建，不生成中间文件      | **生成各种底层构建系统文件**              |
| **语法**       | 简单，专有语法（`.pro`) | 强大，类 QML/JS 语法（`.qbs`) | 自有的脚本语言（`CMakeLists.txt`）        |
| **生态系统**   | 主要在 Qt 生态内        | 小众                          | **极其庞大，是 C++ 世界的基石**           |
| **现状与前景** | Qt 5 主流，Qt 6 中维护  | 独立发展，非主流              | **Qt 6 官方推荐，业界绝对主流，未来可期** |

### 总结

*   **CMake 是什么？** 它是一个**构建系统生成器**，是解决 C++ 跨平台构建问题的**行业标准工具**。
*   **它如何工作？** 你编写中立的 `CMakeLists.txt` 配置文件，CMake 根据目标平台为你生成对应的原生构建文件（如 Makefile、.sln 等）。
*   **我该用吗？** **绝对应该！** 无论你是做 Qt 开发还是一般的 C++ 开发，学习 CMake 都是一项**必备技能**。对于任何**新开始的 C++ 项目，CMake 都是不二之选**。

简单来说，如果你希望在 C++ 领域进行严肃的、跨平台的开发，**掌握 CMake 不是可选项，而是必选项**。它已经取代了 qmake 的历史地位，并凭借其强大的生态成为了无可争议的王者。



## 构建工具 - `qmake` - 概念

好的，我们来用一个简单易懂的方式解释一下 qmake 是什么。

### 一句话概括

**qmake 是一个用来为软件项目自动生成“编译脚本”（比如 Makefile）的工具，它主要由 Qt 公司开发，专门为简化 Qt 程序的编译过程而设计。**

---

### 详细解释

要理解 qmake，我们需要先了解一个 C++ 项目从源代码到可执行文件需要经历什么。

1.  **编写代码**：你写好了 `.h` 头文件和 `.cpp` 源文件。
2.  **编译（Compile）**：编译器（如 g++、clang）需要将每个 `.cpp` 文件编译成机器能识别的目标文件（`.o` 或 `.obj`）。
3.  **链接（Link）**：链接器将所有的目标文件，以及它们所依赖的库（比如 Qt 的库文件 `QtCore.so`, `QtGui.dll` 等）捆绑在一起，最终生成一个可执行文件（如 `.exe` 或 `.app`）。

这个过程如果手动完成会非常繁琐。比如，你需要输入一长串命令来告诉编译器头文件在哪、要链接哪些库等等。这就是 **构建系统（Build System）** 工具出场的原因。

#### qmake 的角色

qmake 就是一个构建系统工具。它的核心工作流程如下：

1.  **你编写一个项目文件**：这个文件通常命名为 `你的项目名.pro`（例如 `myapp.pro`）。这是一个相对简单、人类可读的配置文件。
2.  **你在 `.pro` 文件中说明项目信息**：你用简单的语法告诉 qmake：
    *   项目类型（是生成一个应用程序，还是一个库？）：`TEMPLATE = app`
    *   项目中包含哪些源文件和头文件：`SOURCES = main.cpp widget.cpp`， `HEADERS = widget.h`
    *   需要链接哪些 Qt 模块：`QT += core gui` （如果需要图形界面，还要加上 `widgets`）
    *   其他配置，比如程序的名称、编译选项等。
3.  **qmake 读取 `.pro` 文件并生成 Makefile**：qmake 会根据你项目文件里的描述，**自动生成**一个非常复杂、但完全符合当前平台（Windows、Linux、macOS）和编译器（GCC、MSVC 等）规范的 `Makefile`。
4.  **你使用 Makefile 进行编译**：生成了 `Makefile` 之后，你只需要在命令行输入 `make`（Linux/macOS）或 `nmake`/`mingw32-make`（Windows），构建系统（make 工具）就会根据 `Makefile` 里的指令，自动调用编译器和你，完成编译和链接的所有步骤。

**简单来说，qmake 是一个“构建系统的生成器”，它把你从编写复杂编译命令的劳动中解放了出来。**

---

### 一个简单的 .pro 文件例子

```pro
# 指定这是一个应用程序项目
TEMPLATE = app

# 指定需要使用的 Qt 模块
QT += core gui widgets

# 如果 Qt 版本大于 4，需要加上 widgets 模块（因为 Qt5 开始 GUI 和 Widgets 模块分开了）
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

# 指定目标文件名（生成的可执行文件叫 MyApp）
TARGET = MyApp

# 指定源文件
SOURCES += \
    main.cpp \
    widget.cpp

# 指定头文件
HEADERS += \
    widget.h
```

### qmake 的主要优势（特别是对于 Qt 项目）

*   **对 Qt 特性原生支持**：它能自动处理 Qt 特有的编译步骤，比如**元对象系统（MOC）**、**用户界面编译器（UIC）** 和**资源文件（RCC）**。这是它最强大的地方。
*   **跨平台**：一份简单的 `.pro` 文件可以在 Windows、Linux、macOS 上使用，qmake 会为各个平台生成对应的正确 Makefile。
*   **简单易学**：`.pro` 文件的语法比直接写 CMakeLists.txt 或 Makefile 要简单得多。

### qmake 的现状：qmake 与 CMake

近年来，**CMake** 已经成为了 C++ 社区更主流的构建工具生成器。Qt 6 也开始**官方推荐使用 CMake** 来管理项目，而不是 qmake。

**两者的简单对比：**

| 特性         | qmake                                                        | CMake                                                    |
| :----------- | :----------------------------------------------------------- | :------------------------------------------------------- |
| **定位**     | 主要为 Qt 项目设计，是 Qt 的“原装工具”                       | 通用型 C++ 构建工具，是业界的**事实标准**                |
| **语法**     | 简单、专有                                                   | 更强大、灵活，但学习曲线稍陡                             |
| **生态系统** | 主要在 Qt 生态内                                             | 拥有极其庞大的生态系统，被绝大多数 C++ 开源项目使用      |
| **现状**     | **维护模式**。Qt 5 及之前是默认选择，Qt 6 仍支持，但不再是首选。 | **未来趋势**。是 Qt 6 的推荐构建系统，也是新项目的首选。 |

### 总结

*   **qmake 是一个方便、跨平台的构建工具，尤其适合 Qt 应用程序开发。**
*   它的核心工作是读取简单的 `.pro` 项目文件，然后生成复杂的 `Makefile`。
*   对于学习和维护现有的 Qt 5（或更早）项目，了解 qmake 非常重要。
*   但对于**新开始的 Qt 项目，强烈建议学习并使用 CMake**，因为它更强大，并且是行业和 Qt 未来的发展方向。



## 构建工具 - `Qbs` - 概念

好的，我们来聊聊 **Qbs**，它是 Qt 家族中的另一款构建工具。

### 一句话概括

**Qbs（Qt Build Suite）是一个由 Qt 公司开发的现代化构建工具，它不仅仅生成 Makefile，其设计目标是成为一个功能更强大、更灵活、配置更直观的 qmake 替代品。**

---

### 为什么在有了 qmake 之后，还要开发 Qbs？

要理解 Qbs，首先要知道 qmake 和 Makefile 这类工具的一些局限性：

1.  **两级抽象**：qmake 只是一个“生成器”。它先根据 `.pro` 文件生成 `Makefile`，然后你再调用 `make` 来执行真正的编译。这多了一层间接性，不够直接。
2.  **描述能力有限**：`.pro` 文件的语法相对简单，对于描述非常复杂的构建流程（尤其是涉及自定义构建步骤、复杂的依赖关系时）会变得力不从心。
3.  **不够“智能”**：传统的 `make` 工具基于文件时间戳来判断是否需要重新编译，这有时不够精确和高效。

Qbs 就是为了解决这些问题而诞生的。

### Qbs 的核心思想与特点

Qbs 不再采用“生成 Makefile”的模式，而是一个**真正的构建引擎**。你直接调用 `qbs` 命令，它会自己解析项目文件、分析依赖关系并直接调用编译器进行构建，不再需要中间生成的 `Makefile`。

它的主要特点如下：

#### 1. 基于项目的高级语言
Qbs 使用一种名为 **QML（Qt Modeling Language）** 风格的 **JavaScript** 语法来编写项目文件（通常是 `.qbs` 文件）。这种语法比 qmake 的 `.pro` 文件语法更强大、更结构化、也更易于表达复杂逻辑。

**一个简单的 `application.qbs` 文件示例：**
```javascript
import qbs

CppApplication {
    name: "MyApp"
    files: [
        "*.cpp",
        "*.h"
    ]

    cpp.cxxLanguageVersion: "c++11"

    Depends { name: "Qt.core" }
    Depends { name: "Qt.widgets" }
}
```
可以看到，它的语法更像是在描述一个对象及其属性，非常清晰。

#### 2. 构建图（Build Graph）
Qbs 的核心概念是“构建图”。它会解析你的项目文件及其依赖，在内存中构建一个完整的、精确的依赖关系图。这使得它能做到：
*   **高度精确的增量构建**：只编译真正需要编译的部分，最大程度提升构建速度。
*   **更好的并行构建**：能更智能地调度编译任务，充分利用多核CPU。

#### 3. 强大的依赖模型
Qbs 对模块和产品（Product）之间的依赖关系有原生支持。你可以很容易地定义：
*   一个静态库产品
*   一个依赖于该静态库的应用程序产品
*   一个单元测试产品，依赖于应用程序
Qbs 能自动管理它们之间的依赖和构建顺序。

#### 4. 跨平台抽象
和 qmake 一样，Qbs 也是跨平台的。你可以在项目文件中方便地编写平台相关的条件判断，例如：
```javascript
Group {
    condition: qbs.targetOS.contains("windows")
    files: [ "windows_specific.cpp" ]
}

Group {
    condition: qbs.targetOS.contains("linux")
    files: [ "linux_specific.cpp" ]
}
```

### Qbs 与 qmake / CMake 的对比

| 特性     | qmake                               | **Qbs**                               | CMake                                                  |
| :------- | :---------------------------------- | :------------------------------------ | :----------------------------------------------------- |
| **架构** | 构建系统**生成器**（生成 Makefile） | **独立的构建引擎**（不生成 Makefile） | 构建系统**生成器**（可生成 Makefile、Ninja、VS项目等） |
| **语法** | 简单的专有语法（`.pro`）            | **强大的类 QML/JS 语法**（`.qbs`）    | 自有的脚本语言（`CMakeLists.txt`）                     |
| **理念** | 简单、专注 Qt                       | **强大、灵活、自包含**                | 通用、行业标准、高度可配置                             |
| **状态** | 成熟、维护模式                      | **实验性/小众**                       | **业界标准、蓬勃发展**                                 |

### Qbs 的现状与未来

尽管 Qbs 在技术上有很多优点，但它的发展路径比较曲折：

1.  **曾被视为 qmake 的继任者**：在 Qt 5 时代，Qt 公司曾大力推广 Qbs，希望用它取代 qmake。
2.  **面临 CMake 的激烈竞争**：与此同时，CMake 在 C++ 社区的势头越来越猛，生态越来越完善。
3.  **战略调整**：由于社区采纳度远不及 CMake，Qt 公司后来调整了策略。从 **Qt 6 开始，官方明确将 CMake 作为首选的构建系统**。
4.  **当前定位**：Qbs 目前**不再是 Qt 的默认或推荐构建工具**。它变成了一个由 Qt 公司赞助的**独立开源项目**。它仍然被维护，并且在一些特定领域（如嵌入式开发、需要复杂自定义构建步骤的项目）有其用武之地，但已经不再是主流选择。

### 总结

*   **Qbs 是什么？** 它是一个设计先进、功能强大的**直接构建引擎**，使用类 JavaScript 的语法。
*   **它有什么优点？** 构建模型更精确、配置更灵活、语法更现代。
*   **我应该用它吗？**
    *   对于**大多数新项目，尤其是 Qt 项目，答案是否定的**。你应该选择 **CMake**，因为它是行业标准和 Qt 官方推荐，拥有最广泛的社区和支持。
    *   如果你在一个**特定的、需要高度定制化构建流程**的环境中，并且团队对 Qbs 有研究，那么它可能是一个值得考虑的技术选项。

简单来说，Qbs 是一个“技术上的成功者，但商业/社区上的失败者”。了解它有助于你理解构建工具的发展历程，但为新项目做技术选型时，**CMake 是毫无疑问的首选**。
