## `sync_binlog`

`sync_binlog` 是 MySQL 中的一个系统变量，用于控制 MySQL 服务器将二进制日志（binary log）写入磁盘的同步方式。二进制日志是 MySQL 用来记录所有修改数据库数据的语句（如 INSERT、UPDATE、DELETE 等）和可能更改数据或可能产生数据变化的 DDL 语句（如 CREATE TABLE、ALTER TABLE 等）的日志文件。这些日志对于数据恢复、复制（replication）以及审计等场景非常重要。

`sync_binlog` 的值决定了 MySQL 在将二进制日志的内容写入其内部缓冲区后，多久将其同步到磁盘上。这个设置对于数据库的可靠性和性能有重要影响。

- **`sync_binlog=0`**：默认情况下（在某些 MySQL 版本和配置中可能不是默认的），MySQL 不会将二进制日志同步到磁盘。相反，它依赖于操作系统的调度机制来定期将缓冲区的内容刷新到磁盘。这种方式可以提高性能，因为减少了磁盘 I/O 操作，但在系统崩溃或电源故障时可能会丢失尚未写入磁盘的二进制日志数据，从而导致数据丢失。
- **`sync_binlog=1`**：这是最安全的设置。每当事务提交时，MySQL 都会将二进制日志同步到磁盘。这保证了即使在系统崩溃或电源故障的情况下，也不会丢失已提交事务的二进制日志数据。然而，这种设置可能会降低性能，因为频繁的磁盘 I/O 操作会增加系统的负担。
- **`sync_binlog=N`（N 是大于 1 的整数）**：这是一个折中的设置。MySQL 会在收集了 N 个二进制日志事务的提交后，将二进制日志同步到磁盘。这种设置既提供了一定程度的数据安全性（因为不会每次事务都进行磁盘 I/O），又减少了频繁的磁盘写操作对性能的影响。然而，N 的值需要根据具体的应用场景和硬件性能来权衡。

在配置 `sync_binlog` 时，需要仔细考虑数据库的可靠性和性能需求。对于对数据安全性要求极高的应用场景，建议将 `sync_binlog` 设置为 1。而对于性能要求更高、可以容忍一定程度数据丢失风险的应用场景，则可以考虑将 `sync_binlog` 设置为 0 或一个较大的 N 值。不过，需要注意的是，将 `sync_binlog` 设置为 0 可能会带来较高的数据丢失风险，因此通常不建议在生产环境中这样做。



## `innodb_flush_log_at_trx_commit`

`innodb_flush_log_at_trx_commit` 是 MySQL 中 InnoDB 存储引擎的一个重要参数，它控制着事务提交时重做日志（redo log）的刷新行为。该参数有三个可选值：0、1、2，其中0和2在行为上有着显著的区别，这些区别主要体现在数据的安全性和系统性能上。

**数据安全性**

- **0**：当 `innodb_flush_log_at_trx_commit` 设置为 0 时，事务提交时重做日志不会被立即写入磁盘，而是将日志缓存在内存中。这些日志的写入和同步操作由 InnoDB 的主线程（master thread）每秒执行一次。这意味着，如果系统在这一秒内崩溃，那么这一秒内提交的所有事务的重做日志都可能丢失，从而导致数据的不一致或丢失。
- **1**：在每次事务提交时，重做日志都会被物理写入磁盘，并确保日志的同步（fsync）操作完成。提供了最高的数据持久性，即使在系统崩溃后，也只会丢失1秒内的数据。
- **2**：当设置为 2 时，事务提交时重做日志会被写入到文件系统的缓存中，但并不会立即同步到磁盘。InnoDB 依赖于操作系统的缓存机制来最终将日志写入磁盘。这通常意味着每秒（或更长时间，取决于操作系统的具体行为）会有一次从文件系统缓存到磁盘的同步操作。因此，如果系统崩溃或断电，可能会丢失最近一秒内的事务数据，但相比设置为 0，其数据丢失的风险要小一些。

**系统性能**

- **0**：由于减少了磁盘 I/O 操作，将 `innodb_flush_log_at_trx_commit` 设置为 0 可以显著提高数据库的性能。这对于那些对性能有极高要求，且可以容忍一定数据丢失风险的应用场景非常有用。
- **1**：对性能有较大影响，因为每次事务提交都需要等待磁盘I/O操作完成。
- **2**：虽然设置为 2 也会减少每次事务提交时的磁盘 I/O 操作，因为日志只是被写入到文件系统的缓存中，而不是直接写入磁盘，但相比设置为 0，它在数据安全性上提供了一定的保障。因此，它在性能和安全性之间提供了一个折中的选择。

**注意事项**

- 在选择`innodb_flush_log_at_trx_commit`的值时，需要根据应用的具体需求来权衡数据的安全性和性能。
- 如果对数据的实时性和持久性要求非常高，应该选择值为1，以保证数据的完整性和一致性。
- 如果应用对数据丢失的容忍度较高，并且对性能有较高要求，可以考虑选择值为0或2，以提高数据库的写入性能。
- 在生产环境中，建议谨慎调整该参数的值，并在调整前进行充分的测试和评估。

**查看和设置**

- **查看当前值**：可以使用SQL语句`SELECT @@innodb_flush_log_at_trx_commit;`来查看当前的设置值。
- **设置新值**：可以使用SQL语句`SET GLOBAL innodb_flush_log_at_trx_commit = [新值];`来设置新的值，但请注意，这个设置是全局的，并且会影响所有新的连接，但不会改变已经存在的连接的设置。对于已经存在的连接，需要断开并重新连接才能应用新的设置。



## `query_cache_type`

通过参数`query_cache_type`启用或者禁用`query cache`。

在`sql`性能优化过程中，禁用当前`session query cache`特性以调试`sql`优化后的性能

```sql
set session query_cache_type=0;
```



## `max_binlog_total_size`

>注意：在没有配置 slave 时不会自动删除多余日志，此时需要设置 slave_connections_needed_for_purge 参数。
>
>[参考官方文档](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#max_binlog_total_size)

所有二进制日志的最大可用空间（以字节为单位）。服务器启动、日志轮换、刷新日志或写入二进制日志时会删除多余的日志。默认值为 0，表示没有大小限制。另请参阅 slave_connections_needed_for_purge。

示例：

```
[mysqld]
# 不设置此参数时，在没有配置 slave 时不会自动删除多余日志
slave_connections_needed_for_purge = 0
# 日志总大小限制为 2g
max_binlog_total_size = 2g
```



## `binlog_expire_logs_seconds`

>注意：在没有配置 slave 时不会自动删除多余日志，此时需要设置 slave_connections_needed_for_purge 参数。
>
>[参考官方文档](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#binlog_expire_logs_seconds)

如果非零，二进制日志将在 binlog_expire_logs_seconds 秒后清除。清除操作可能在启动时和二进制日志轮转时进行。从 MariaDB 10.6.1 开始，binlog_expire_logs_seconds 和 expire_logs_days 是别名，因此对其中一个的更改会自动反映在另一个上。

示例：

```
[mysqld]
# 不设置此参数时，在没有配置 slave 时不会自动删除多余日志
slave_connections_needed_for_purge = 0
# 日志过期时间限制为 60 秒
# binlog_expire_logs_seconds = 60
```



## `slave_connections_needed_for_purge`

>[参考官方文档](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#slave_connections_needed_for_purge)

自动清除二进制日志所需的最小连接副本数，由 max_binlog_total_size、binlog_expire_logs_seconds 或 expire_logs_days 决定。更改该值将触发清除尝试，但无需轮换 binlog，清除的文件集需满足上述两个参数以及设置的值。



## `skip-slave-start`

MySQL 从库在启动时，默认会自动启动复制线程（`IO_THREAD` 和 `SQL_THREAD`），从主库同步数据。在 MySQL 配置文件（如 `my.cnf` 或 `my.ini`）中添加该参数后，从库启动时**不会自动启动复制线程**，需手动干预才能开始复制。

```
[mysqld]
skip-slave-start
```



## `replicate-ignore-db`

在MySQL主从复制中，`replicate-ignore-db` 是一个用于配置从库忽略特定数据库复制的参数。

```
replicate-ignore-db="information_schema"
replicate-ignore-db="mysql"
replicate-ignore-db="performance_schema"
replicate-ignore-db="test"
```

## lower_case_table_names

`lower_case_table_names`是 MySQL 的一个重要配置参数，用于控制数据库对象名称的大小写处理方式。

### **1. 参数作用**

#### **核心功能**

控制 MySQL 如何存储和比较**表名、数据库名、表别名**的大小写。

#### **三个可选值**

```
-- 查看当前设置
SHOW VARIABLES LIKE 'lower_case_table_names';

-- 可能的取值
0: 区分大小写（默认）
1: 转换为小写存储，比较时不区分大小写
2: 区分大小写存储，比较时转换为小写
```

------

### **2. 各值的详细说明**

#### **`lower_case_table_names = 0`（默认）**

```
-- Linux/Unix 默认值
- 创建时保留原始大小写
- 查询时区分大小写
- 存储时区分大小写

-- 示例：
CREATE TABLE MyTable (id INT);  -- 创建为 MyTable
SELECT * FROM mytable;           -- 错误：表不存在
SELECT * FROM MyTable;           -- 成功
```

**文件系统表现：**

```
# Linux 文件系统区分大小写
MyTable.frm  # 表定义文件
MyTable.ibd  # 表数据文件
```

#### **`lower_case_table_names = 1`**

```
-- Windows 默认值，推荐跨平台使用
- 创建时自动转换为小写存储
- 查询时不区分大小写
- 存储为小写

-- 示例：
CREATE TABLE MyTable (id INT);  -- 存储为 mytable
SELECT * FROM mytable;           -- 成功
SELECT * FROM MYTABLE;           -- 成功
SELECT * FROM MyTable;           -- 成功
```

**文件系统表现：**

```
# 总是存储为小写
mytable.frm
mytable.ibd
```

#### **`lower_case_table_names = 2`**

```
-- 混合模式
- 创建时保留原始大小写
- 查询时不区分大小写
- 存储时保留大小写

-- 示例：
CREATE TABLE MyTable (id INT);  -- 存储为 MyTable
SELECT * FROM mytable;           -- 成功
SELECT * FROM MYTABLE;           -- 成功
```

**文件系统表现：**

```
# 保留原始大小写
MyTable.frm
MyTable.ibd
```

------

### **3. 为什么需要设置为 1**

#### **A. 跨平台兼容性**

```
-- 场景：从 Windows 迁移到 Linux
Windows（默认=1）：不区分大小写
Linux（默认=0）：区分大小写

-- 问题：迁移后表名可能找不到
解决方案：两边都设置为 1
```

#### **B. 避免大小写敏感问题**

```
-- 开发中的常见错误
-- 代码中大小写不一致
SELECT * FROM users;
SELECT * FROM Users;
SELECT * FROM USERS;

-- 设置为 1 后，这些都指向同一个表
```

#### **C. Docker 和容器化环境**

```
# Docker Compose 示例
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    command: 
      - --lower-case-table-names=1
    volumes:
      - ./my.cnf:/etc/mysql/conf.d/my.cnf
```

------

### **4. 如何设置**

#### **A. 配置文件设置（推荐）**

```
# my.cnf 或 my.ini
[mysqld]
lower_case_table_names = 1
```

#### **B. 启动参数设置**

```
# Linux/Unix
mysqld --lower-case-table-names=1

# Docker
docker run -d \
  --name mysql \
  -e MYSQL_ROOT_PASSWORD=123456 \
  mysql:8.0 \
  --lower-case-table-names=1
```

#### **C. 查看当前设置**

```
-- 方法1：SQL查询
SHOW VARIABLES LIKE 'lower_case_table_names';

-- 方法2：命令行
mysqladmin variables | grep lower_case_table_names

-- 方法3：系统表
SELECT * FROM performance_schema.global_variables 
WHERE VARIABLE_NAME = 'lower_case_table_names';
```

------

### **5. 设置时机和限制**

#### **重要警告 ⚠️**

```
-- 这个参数必须在初始化时设置！
-- 如果已经有数据，修改此参数需要：

1. 备份所有数据
2. 停止 MySQL
3. 修改配置文件
4. 删除数据目录
5. 重新初始化
6. 恢复数据
```

#### **初始化步骤**

```
# 1. 首次安装时设置
mysql_install_db --lower-case-table-names=1

# 2. 或初始化时指定
mysqld --initialize --lower-case-table-names=1
```

------

### **6. 对开发和运维的影响**

#### **对 SQL 语句的影响**

```
-- 设置为 1 时：
-- 以下所有语句都指向同一个表
CREATE TABLE UserInfo (...);
SELECT * FROM userinfo;
INSERT INTO USERINFO VALUES (...);
UPDATE Userinfo SET ...;
DROP TABLE userInfo;
```

#### **对文件系统的影响**

```
# 设置为 1
实际存储：/var/lib/mysql/dbname/mytable.ibd

# 设置为 0
实际存储：/var/lib/mysql/dbname/MyTable.ibd
```

#### **对备份恢复的影响**

```
-- 导出时注意
mysqldump dbname mytable > backup.sql
-- 导入时表名都会变为小写
```

------

### **7. 与应用程序的兼容性**

#### **ORM 框架支持**

```
// JPA/Hibernate
@Entity
@Table(name = "UserInfo")  // 设置为 1 后，实际表名是 userinfo
public class UserInfo {
    // ...
}
# SQLAlchemy
class UserInfo(Base):
    __tablename__ = 'UserInfo'  # 实际使用 userinfo
// Sequelize
const UserInfo = sequelize.define('UserInfo', {  // 表名变为 userinfo
  // ...
});
```

#### **命名规范建议**

```
-- 统一使用小写+下划线
CREATE TABLE user_info ();      -- ✓ 推荐
CREATE TABLE UserInfo ();       -- 不推荐
CREATE TABLE USER_INFO ();      -- 不推荐
```

------

### **8. 与操作系统文件系统的关系**

| 操作系统    | 默认值 | 原因                 | 建议     |
| ----------- | ------ | -------------------- | -------- |
| **Windows** | 1      | 文件系统不区分大小写 | 保持 1   |
| **macOS**   | 2      | APFS 不区分大小写    | 建议 1   |
| **Linux**   | 0      | 文件系统区分大小写   | 建议 1   |
| **Docker**  | 0      | 继承宿主             | 明确设置 |

------

### **9. 常见问题与解决方案**

#### **Q1: 修改后出现 "Table doesn't exist" 错误**

```
-- 原因：现有表名的大小写不匹配
-- 解决方案：
RENAME TABLE OldTable TO oldtable;
-- 或重新导入数据
```

#### **Q2: 主从复制中的问题**

```
-- 主从不一致导致复制中断
-- 确保主从配置相同
SHOW SLAVE STATUS\G
-- 查看 Last_Error
```

#### **Q3: 如何迁移现有数据库**

```
# 迁移步骤
1. mysqldump --all-databases > backup.sql
2. 修改配置为 lower_case_table_names=1
3. 重新初始化 MySQL
4. mysql < backup.sql
5. 检查并修复大小写问题
```

#### **Q4: 导入导出注意事项**

```
-- 导出时指定小写
mysqldump --compatible=mysql40 --skip-extended-insert dbname

-- 或在导出脚本中转换
sed -i 's/`\([^`]*\)`/`\L\1`/g' backup.sql
```

------

### **10. 最佳实践**

#### **开发环境**

```
# 所有环境统一设置为 1
[mysqld]
lower_case_table_names = 1
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
```

#### **Docker 部署**

```
# docker-compose.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    command: 
      - --lower-case-table-names=1
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
    environment:
      - MYSQL_ROOT_PASSWORD=yourpassword
```

#### **应用程序代码**

```
-- 始终使用小写命名
CREATE TABLE user_account (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) COMMENT='用户账户表';

-- 创建索引
CREATE INDEX idx_username ON user_account(username);
```

------

### **11. 与其他参数的关联**

#### **与字符集的关系**

```
-- utf8mb4 字符集通常与 lower_case_table_names=1 配合使用
SHOW VARIABLES LIKE 'character_set%';
SHOW VARIABLES LIKE 'collation%';

-- 建议配置
character_set_server = utf8mb4
collation_server = utf8mb4_unicode_ci
lower_case_table_names = 1
```

#### **与 SQL 模式的关系**

```
-- 某些 SQL 模式可能影响大小写处理
SHOW VARIABLES LIKE 'sql_mode';

-- 推荐设置
sql_mode = ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
```

------

### **总结**

**`lower_case_table_names = 1`的主要作用**：

1. **统一存储**：所有表名、数据库名存储为小写
2. **不区分大小写**：查询时忽略大小写差异
3. **跨平台兼容**：解决不同操作系统的大小写敏感问题

**使用建议**：

- ✅ **新项目**：始终设置为 1
- ✅ **跨平台项目**：必须设置为 1
- ✅ **团队协作**：统一设置为 1
- ⚠️ **已有项目**：谨慎评估，需要数据迁移
- ❌ **不能动态修改**：必须在初始化时设置

**一句话总结**：设置为 1 可以避免因操作系统文件系统差异导致的表名大小写问题，是保证跨平台兼容性的最佳实践。
