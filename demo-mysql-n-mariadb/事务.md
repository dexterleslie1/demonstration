## 什么是事务呢？

在MySQL中，**事务（Transaction）**是一系列数据库操作，这些操作要么全部执行，要么全部不执行，从而保证数据库的完整性和一致性。事务是一个不可分割的工作单位，它包含了对数据库的一组更改。

## 事务四大特性`ACID`

- 原子性（Atomicity）

  事务是不可分割的最小操作单元，要么全部成功，要么全部失败。转账交易场景，要么A账户扣款成功并且B帐户加款成功，要么A帐号不扣款并且B账户不加款。

- 一致性（Consistency）

  事务完成时，必须使所有数据都保持一致状态。转账交易场景，无论事务提交还是回滚，事务结束后A账户+B账户的总余额等于交易开始前的总余额。

- 隔离性（Isolation）

  在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的隔离空间，一个事务的内部操作对其他事务是不可见的。

- 持久性（Durability）

  事务一但提交或者回滚，它对数据库中的数据的改变就是永久的。

## 事务异常回滚

准备测试环境数据

```sql
CREATE DATABASE IF NOT EXISTS testdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

use testdb;

create table if not exists t_balance(
    id bigint primary key auto_increment,
    name varchar(64) default '' not null,
    amount int default 0 not null
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 collate=utf8mb4_general_ci;

insert into t_balance(name,amount) values ('zhangsan', 10000),('lisi', 10000);
```

测试事务异常回滚

```shell
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> update t_balance set amount=amount-1000 where name='zhangsan';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |   9000 |
|  2 | lisi     |  10000 |
+----+----------+--------+
2 rows in set (0.00 sec)

# 事务回滚
mysql> rollback;
Query OK, 0 rows affected (0.01 sec)

# 事务回滚后余额恢复原值
mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |  10000 |
|  2 | lisi     |  10000 |
+----+----------+--------+
2 rows in set (0.00 sec)
```

## 事务隔离级别 - 作用

说得非常好！这是一个数据库核心的概念。简单来说，MySQL事务隔离级别的主要作用是**在数据库处理多个并发事务时，在“数据一致性”和“性能”之间进行权衡和取舍**。

它定义了一个事务可能受其他并发事务影响的程度，解决了多个事务同时运行时可能引发的经典问题。

------

### 1. 它要解决什么问题？（并发问题）

在没有隔离的情况下，并发事务会引发以下问题：

1. **脏读**：一个事务读到了另一个**未提交事务**修改的数据。如果那个事务被回滚，那么第一个事务读到的数据就是无效的“脏数据”。
   - **例子**：事务A将余额从100改为200（但未提交），事务B读到了200。随后事务A回滚，余额变回100，但事务B使用的200就是脏数据。
2. **不可重复读**：一个事务内，**多次读取同一条数据**，结果不一致。这是因为在两次读取之间，另一个事务**修改并提交**了该数据。
   - **例子**：事务A第一次读取余额为100，此时事务B将余额修改为200并提交。事务A再次读取余额，发现变成了200，无法“重复”读到一开始的结果。
3. **幻读**：一个事务内，**多次查询符合条件的记录数量**，结果集的行数不一致。这是因为在两次查询之间，另一个事务**插入或删除**了符合条件的记录并提交。
   - **例子**：事务A查询年龄<30的员工有10人。此时事务B插入了一名25岁的新员工并提交。事务A再次查询，发现变成了11人，就像产生了“幻觉”一样。

**不可重复读和幻读的区别**：不可重复读针对的是**已存在数据的更新**，幻读针对的是**数据条目的增删**。

------

### 2. MySQL的四种隔离级别

为了解决以上问题，SQL标准定义了4种隔离级别，隔离级别由低到高，并发性能由高到低。

| 隔离级别     | 脏读 | 不可重复读 | 幻读 | 说明                                                         |
| ------------ | :--: | :--------: | :--: | ------------------------------------------------------------ |
| **读未提交** |  ❌   |     ❌      |  ❌   | 事务可以读取其他事务**未提交**的修改。性能最高，但问题最多，很少使用。 |
| **读已提交** |  ✅   |     ❌      |  ❌   | 事务只能读取其他事务**已提交**的修改。解决了脏读，是Oracle等数据库的默认级别。 |
| **可重复读** |  ✅   |     ✅      |  ❌   | 确保在一个事务中，多次读取同一数据的结果是一致的。**MySQL的默认级别**。 |
| **串行化**   |  ✅   |     ✅      |  ✅   | 最严格的隔离级别。所有事务逐个执行，完全避免并发问题，但性能最低。 |

- ✅ 代表**不会发生**该问题
- ❌ 代表**会发生**该问题

------

### 3. MySQL如何实现可重复读（默认级别）

MySQL的默认级别是**可重复读**，并且MySQL在这个级别通过 **MVCC（多版本并发控制）** 机制，**很大程度上避免了幻读**。

- **原理**：InnoDB存储引擎会在每行数据后添加两个隐藏字段：`创建版本号`和`删除版本号`。每个事务在开始时都会得到一个唯一的、自增的事务ID。
- **如何工作**：
  1. **SELECT**：InnoDB只会查找创建版本号早于当前事务ID、且（删除版本号未定义或晚于当前事务ID）的数据行。这样就确保事务读到的数据，是在它开始时就已经存在的“快照”，不受其他已提交事务的影响。
  2. **INSERT/UPDATE/DELETE**：这些操作会为数据行创建新的版本，并标记上当前事务的版本号。

正因为这种“快照读”的机制，在同一个事务中，无论查询多少次，看到的都是事务开始时的那个数据快照，从而实现了**可重复读**，并且避免了大部分**幻读**情况。

> **注意**：在“当前读”（如 `SELECT ... FOR UPDATE`）的情况下，依然有可能遇到幻读。但MySQL通过**Next-Key Lock**（临键锁）机制，将间隙锁和行锁结合起来，锁住一个范围，从而防止其他事务在这个范围内插入新数据，彻底解决了幻读问题。

------

### 总结

- **作用核心**：事务隔离级别是数据库在**并发性能**和**数据可靠性/一致性**之间设置的**控制阀**。
- **级别选择**：
  - 级别越低，并发性越好，但数据一致性问题风险越高。
  - 级别越高，数据越安全可靠，但并发性能越差。
- **MySQL默认**：**可重复读**。这是一个非常实用的选择，它通过MVCC在保证高性能的同时，为绝大多数应用场景提供了足够的数据一致性保证。你通常不需要修改它，除非你有非常特殊的业务需求。

你可以通过以下命令查看和设置隔离级别：

```
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 设置当前会话隔离级别为读已提交
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```



## 事务隔离级别 - 分类

> [Mysql-详解脏读、不可重复读、幻读](https://blog.csdn.net/ahuangqingfeng/article/details/124407846)
>
> 提示：读未提交性能最好，可串行化性能最差。

事务隔离级别用于解决并发事务所引发的问题：

- 读未提交（read uncommitted）：脏读存在、不可重复读存在、幻读存在。
- 读已提交（read committed）：不可重复读存在、幻读存在。
- 可重复读（repeatable read 默认级别）：幻读存在。
- 串行化（serializable）：所有都不存在。



## 事务隔离级别 - 并发事务的问题

>[参考链接](https://blog.csdn.net/ahuangqingfeng/article/details/124407846)

MySQL并发事务中可能存在的问题主要有以下几个方面：

1. 脏读（Dirty Read）：
   - 定义：一个事务读取到另一个事务尚未提交的数据。
   - 示例：事务B正在更新某个字段但尚未提交，此时事务A读取这个字段的值。如果事务B发生错误并执行回滚操作，那么事务A读取到的就是脏数据（即最终不会生效的数据）。
   - 解决方法：提高事务的隔离级别，例如使用“Read committed”或更高的隔离级别。
   - 原理：`mysql`通过`mvcc`机制解决此问题。
2. 不可重复读（Non-repeatable Read）：
   - 定义：一个事务内多次读取同一数据但读取结果不同，因为读取到另一个事务已提交的数据。
   - 示例：事务A两次读取同一数据，在两次读取之间，事务B修改了该数据并提交。因此，事务A两次读取到的数据不同。
   - 解决方法：同样可以通过提高事务的隔离级别来避免，如使用“Repeatable Read”或更高的隔离级别。MySQL的默认隔离级别就是“Repeatable Read”。MySQL底层使用行锁解决此问题。
   - 原理：`mysql`通过`mvcc`机制解决此问题。
3. 幻读（Phantom Read）：
   - 定义：一个事务按照某个条件读取数据时，没有数据符合该条件，但之后另一个事务插入数据，使得第一个事务再次按照该条件查询时出现了新的数据，就像出现了幻影一样。
   - 示例：事务A查询满足某条件的记录，发现没有记录。此时，事务B插入了一条满足该条件的记录并提交。然后事务A再次查询，发现有一条记录满足条件。
   - 解决方法：使用最高级别的隔离级别“Serializable”，它会对每一行数据加锁，从而解决幻读问题。但需要注意的是，这种级别的并发性能较低。
   - 原理：MVCC通过为每个事务提供一个Read View来确保事务在读取数据时的一致性和隔离性，从而解决了幻读问题。



## 事务隔离级别 - 并发事务的问题演示



### 准备测试环境

```sql
CREATE DATABASE IF NOT EXISTS testdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

use testdb;

create table if not exists t_balance(
    id bigint primary key auto_increment,
    name varchar(64) default '' not null,
    amount int default 0 not null
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 collate=utf8mb4_general_ci;

insert into t_balance values(1,'zhangsan',10000);
```



### 读未提交隔离级别

```bash
# session1开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session1修改金额
mysql> update t_balance set amount=amount-1000 where name='zhangsan';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

# session2查看当前事务隔离级别
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)

# session2设置当前事务隔离级别为read uncommitted
mysql> set session transaction isolation level read uncommitted;
Query OK, 0 rows affected (0.00 sec)

mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| READ-UNCOMMITTED        |
+-------------------------+
1 row in set (0.00 sec)

# session2开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session2能够读取session1未提交的修改
mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |   9000 |
+----+----------+--------+
1 row in set (0.00 sec)

# session1 回滚修改
mysql> rollback;
Query OK, 0 rows affected (0.00 sec)

# session2查询到session1回滚后的数据
mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |  10000 |
+----+----------+--------+
1 row in set (0.00 sec)

# session2提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```



### 读已提交隔离级别

```bash
# session1设置当前事务隔离级别为read committed
mysql> set session transaction isolation level read committed;
Query OK, 0 rows affected (0.00 sec)
# session1开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session1在session2操作前查询数据
mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |  10000 |
+----+----------+--------+
1 row in set (0.00 sec)

# session2开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session2修改数据
mysql> update t_balance set amount=amount-1000 where name='zhangsan';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
# session2提交修改
mysql> commit;
Query OK, 0 rows affected (0.01 sec)

# session1再次查询数据，发现金额被修改为9000
mysql> select * from t_balance;
+----+----------+--------+
| id | name     | amount |
+----+----------+--------+
|  1 | zhangsan |   9000 |
+----+----------+--------+
1 row in set (0.00 sec)
# session1提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```



### 可重复读隔离级别

```bash
# session1设置当前事务隔离级别为repeatable read
mysql> set session transaction isolation level repeatable read;
Query OK, 0 rows affected (0.00 sec)
# session1开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

# session2开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session2插入id=2的记录
mysql> insert into t_balance values(2,'王五',10000);
Query OK, 1 row affected (0.01 sec)
# session2提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

# session1查询没有id=2的记录，因为mvcc机制
mysql> select * from t_balance;
Empty set (0.00 sec)
# 但是session1插入id=1的记录提示主键冲突错误，这就是幻读现象了
mysql> insert into t_balance values(2,'王五',10000);
ERROR 1062 (23000): Duplicate entry '2' for key 't_balance.PRIMARY'

# session1提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

# session1再次查询却能够看到id=2的数据
mysql> select * from t_balance;
+----+--------+--------+
| id | name   | amount |
+----+--------+--------+
|  2 | 王五   |  10000 |
+----+--------+--------+
1 row in set (0.00 sec)
```



### 串行化隔离级别

```bash
# session1设置当前事务隔离级别为serializable
mysql> set session transaction isolation level serializable;
Query OK, 0 rows affected (0.00 sec)
# session1开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
mysql> select * from t_balance;
Empty set (0.00 sec)

# session2开启事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
# session2执行下面insert语句一直等待状态
mysql> insert into t_balance values(3,'lisi',10000);

# session1提交事务后，session2的insert语句才能继续执行
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

# session2提交事务
mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```



## 事务隔离级别 - 性能测试

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-mysql-n-mariadb/demo-transaction-isolation) 协助测试

测试环境配置：`Hypervisor:VMware ESXi, 7.0.3, 20328353`、`Model:PowerEdge R740xd`、`Processor Type:Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`、数据库实例`8C8G`、其他实例资源充足。

编译镜像

```sh
./build.sh && ./push.sh
```

复制部署文件

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

启动测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

检查测试目标是否正常运行

```sh
curl http://192.168.1.185/api/v1/selectByValueRangeWithIsolationReadUncommitted
```

模拟并发写

```sh
wrk2 --rate 128 -t4 -c16 -d300000000000000000s --latency --timeout 60 http://192.168.1.185/api/v1/updateValue
```

测试 `read uncommitted`

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/selectByValueRangeWithIsolationReadUncommitted
Running 30s test @ http://192.168.1.185/api/v1/selectByValueRangeWithIsolationReadUncommitted
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   169.64ms  205.80ms   3.35s    91.03%
    Req/Sec     2.09k   419.24     3.44k    87.54%
  Latency Distribution
     50%  115.57ms
     75%  157.02ms
     90%  340.26ms
     99%    1.17s 
  482440 requests in 30.09s, 114.10MB read
Requests/sec:  16032.84
Transfer/sec:      3.79MB
```

测试 `read committed`

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/selectByValueRangeWithIsolationReadCommitted
Running 30s test @ http://192.168.1.185/api/v1/selectByValueRangeWithIsolationReadCommitted
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   166.33ms  174.55ms   2.35s    91.34%
    Req/Sec     2.00k   400.08     3.15k    85.95%
  Latency Distribution
     50%  120.82ms
     75%  160.45ms
     90%  304.31ms
     99%    1.02s 
  459573 requests in 30.09s, 108.69MB read
Requests/sec:  15273.27
Transfer/sec:      3.61MB
```

测试 `repeatable read`

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/selectByValueRangeWithIsolationRepeatableRead
Running 30s test @ http://192.168.1.185/api/v1/selectByValueRangeWithIsolationRepeatableRead
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   105.78ms   84.42ms   2.75s    94.96%
    Req/Sec     2.59k   318.92     3.59k    87.71%
  Latency Distribution
     50%   96.89ms
     75%  113.94ms
     90%  133.39ms
     99%  365.12ms
  617934 requests in 30.08s, 146.15MB read
Requests/sec:  20539.74
Transfer/sec:      4.86MB
```

测试 `serializable`

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/selectByValueRangeWithIsolationSerializable
Running 30s test @ http://192.168.1.185/api/v1/selectByValueRangeWithIsolationSerializable
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    16.82s     8.03s   29.93s    58.15%
    Req/Sec    19.91     30.97   333.00     93.73%
  Latency Distribution
     50%   17.90s 
     75%   22.60s 
     90%   28.30s 
     99%   29.29s 
  2600 requests in 30.05s, 629.69KB read
Requests/sec:     86.52
Transfer/sec:     20.96KB
```

结论：`repeatable read` > `read uncommitted` > `read committed` > `serializable` 性能，实际测试结果为何和理论不一致呢？这是因为 `MySQL` 的 `InnoDB` 引擎在所有隔离级别下都使用多版本并发控制（`MVCC`），这导致 `READ_UNCOMMITTED`实际上也被 `MVCC` 处理：虽然标准定义允许脏读，但 `InnoDB` 实现中`READ_UNCOMMITTED` 的行为与 `READ_COMMITTED` 几乎相同，`REPEATABLE_READ` 优化：`MySQL` 对 `REPEATABLE_READ` 有特殊优化，可能比 `READ_COMMITTED` 更高效。
