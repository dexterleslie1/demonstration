## 二叉树（`Binary Tree`）- 概念

二叉树算法是围绕**二叉树（Binary Tree）**这种数据结构设计的各种操作方法和逻辑，广泛应用于计算机科学中的排序、查找、数据库索引、编译器优化等领域。以下从基础概念、常见类型、核心算法到实际应用，系统梳理二叉树算法的关键内容。


### 一、二叉树的基础定义
**二叉树**是一种非线性数据结构，每个节点最多有**两个子节点**（左子节点和右子节点），且子节点有明确的左右顺序（左子树≠右子树）。其结构特点如下：  
- 每个节点包含：数据值、左子节点指针、右子节点指针。  
- 叶子节点：无左右子节点的节点。  
- 深度/高度：从根节点到最远叶子节点的边数（或节点数，不同教材定义可能不同）。  


### 二、常见二叉树类型
根据结构特性，二叉树可分为多种类型，每种类型对应不同的算法设计目标：  

#### 1. 满二叉树（Full Binary Tree）  
所有非叶子节点都有**两个子节点**，且所有叶子节点位于**同一层**。  
例如：深度为3的满二叉树共有 \(2^3 - 1 = 7\) 个节点。  

#### 2. 完全二叉树（Complete Binary Tree）  
除最后一层外，其他层的节点都是“满”的；最后一层的节点从左到右依次填充，中间无空缺。  
**特点**：可用数组高效存储（通过下标计算父子节点位置）。堆（Heap）通常用完全二叉树实现。  

#### 3. 二叉搜索树（Binary Search Tree, BST）  
- **核心性质**：对于任意节点，左子树所有节点的值 ≤ 当前节点值 ≤ 右子树所有节点的值。  
- **作用**：支持高效的查找、插入、删除操作（平均时间复杂度 \(O(\log n)\)）。  

#### 4. 平衡二叉树（Balanced Binary Tree）  
为避免普通BST在极端情况下（如插入有序数据）退化为链表（时间复杂度 \(O(n)\)），通过约束左右子树的高度差来保持平衡。  
- **AVL树**：严格平衡，任意节点的左右子树高度差（平衡因子）绝对值 ≤1。插入/删除时通过旋转恢复平衡。  
- **红黑树**：弱平衡（通过颜色标记规则间接保证平衡），最长路径不超过最短路径的2倍。Java的`TreeMap`/`TreeSet`即基于红黑树实现。  


### 三、二叉树的核心算法：遍历
遍历是二叉树最基础的操作，指按某种规则访问所有节点（每个节点仅访问一次）。常见遍历方式分为**深度优先（DFS）**和**广度优先（BFS）**两类。  

#### 1. 深度优先遍历（DFS）  
沿着树的深度逐层访问，分为三种顺序：  

- **前序遍历（Pre-order）**：根 → 左子树 → 右子树。  
  示例：对于树  
  ```
      A
     / \
    B   C
   /
  D
  ```
  前序结果：`A → B → D → C`。  

- **中序遍历（In-order）**：左子树 → 根 → 右子树。  
  示例（同上树）：中序结果：`D → B → A → C`。  

- **后序遍历（Post-order）**：左子树 → 右子树 → 根。  
  示例（同上树）：后序结果：`D → B → C → A`。  


**实现方式**：  
- **递归**：代码简洁，但可能受栈深度限制（适用于小规模树）。  
- **迭代**：用显式栈模拟递归过程（适用于大规模树）。  

**前序遍历迭代示例（Java）**：  
```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            res.add(root.val);
            stack.push(root);
            root = root.left; // 先访问左子树
        }
        root = stack.pop().right; // 回溯到父节点，处理右子树
    }
    return res;
}
```


#### 2. 广度优先遍历（BFS，层序遍历）  
按层次从上到下、每层从左到右访问节点，通常用**队列**实现。  

示例（同上树）：层序结果：`A → B → C → D`。  

**实现方式（Java）**：  
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(level);
    }
    return res;
}
```


### 四、二叉搜索树（BST）的关键操作
BST的核心优势是**有序性**，支持高效的查找、插入和删除。以下是其核心操作：  

#### 1. 查找（Search）  
从根节点开始，若当前节点值等于目标值则返回；若目标值更小，则递归查找左子树；否则递归查找右子树。时间复杂度 \(O(\log n)\)（平衡BST）。  


#### 2. 插入（Insert）  
找到第一个满足“左子树≤当前节点<右子树”的空位置，插入新节点。插入后可能破坏平衡（如AVL树需调整）。  


#### 3. 删除（Delete）  
分三种情况处理：  
- **无左右子节点**：直接删除，父节点指向`null`。  
- **只有一个子节点**：用子节点替换当前节点。  
- **有两个子节点**：找到右子树的最小节点（后继）或左子树的最大节点（前驱），用其值替换当前节点，再删除后继/前驱节点。  


### 五、平衡二叉树的调整算法（以AVL树为例）  
AVL树通过**旋转操作**恢复平衡，当插入/删除导致某个节点的平衡因子（左子树高度 - 右子树高度）绝对值超过1时，触发旋转：  

- **左旋（LL旋转）**：右子树过高，将右子节点作为新根，原根变为左子节点。  
- **右旋（RR旋转）**：左子树过高，将左子节点作为新根，原根变为右子节点。  
- **左右旋（LR旋转）**：左子树的右子树过高，先对左子树左旋，再对原根右旋。  
- **右左旋（RL旋转）**：右子树的左子树过高，先对右子树右旋，再对原根左旋。  


### 六、二叉树的实际应用场景  
二叉树算法在实际开发中广泛应用，例如：  
- **数据库索引**：B树/B+树（多叉树变体）用于快速查找数据。  
- **优先队列**：堆（完全二叉树）实现最大/最小堆，支持高效取最值。  
- **编译器语法树**：用二叉树表示代码的语法结构，辅助代码分析。  
- **哈夫曼编码**：带权路径最短的二叉树，用于数据压缩。  
- **系统文件目录**：树形结构组织文件和子目录。  


### 总结  
二叉树算法的核心是**利用树的结构特性高效处理有序数据**，其遍历、查找、插入、删除等操作是算法设计的基础。平衡二叉树（如AVL、红黑树）通过调整机制解决了普通BST的性能退化问题，成为工业级数据结构（如Java集合框架）的核心。理解二叉树算法是掌握高级数据结构（如B树、Trie树）和算法优化（如分治、回溯）的重要基础。



## 二叉树（`Binary Tree`）- 缺点

>提示：普通二叉搜索树（`BST`）的致命缺陷：易退化为链表。

二叉树作为一种非线性数据结构，虽然在许多场景（如有序数据存储、高效查找）中表现优异，但也存在一些固有的缺点，具体取决于其类型（如普通BST、平衡BST）和使用场景。以下是二叉树的主要缺点分析：


### 一、普通二叉搜索树（BST）的致命缺陷：易退化为链表
普通的二叉搜索树（无平衡约束）的性能高度依赖**数据的插入顺序**。若数据**有序插入**（如升序或降序），BST会退化为**链表**（所有节点只有左子节点或右子节点），导致以下问题：  
- **时间复杂度退化**：插入、查找、删除的时间复杂度从平均 \(O(\log n)\) 恶化为最坏 \(O(n)\)（例如，插入1、2、3、4、5时，树的高度为5，操作需遍历所有节点）。  
- **空间利用率低**：链表结构无法利用“局部性原理”（内存连续存储），缓存命中率低，访问效率下降。  


### 二、平衡二叉树的额外开销
为解决普通BST的退化问题，引入了平衡二叉树（如AVL树、红黑树），但它们也带来了新的缺点：  

#### 1. 实现复杂度高  
平衡二叉树需要通过**旋转操作**（如AVL树的LL/RR/LR/RL旋转）或**颜色调整规则**（如红黑树）维持平衡，这些逻辑的代码实现复杂，调试和维护成本高。例如，红黑树的插入/删除操作可能需要多次旋转和颜色修正，逻辑繁琐。  

#### 2. 时间开销增加  
平衡操作（如旋转）虽然保证了树的平衡，但每次插入/删除时可能需要额外的调整步骤。例如：  
- AVL树的旋转操作时间复杂度为 \(O(1)\)，但调整可能发生在插入/删除路径上的多个节点；  
- 红黑树的调整（如颜色翻转、旋转）虽然次数较少，但仍需遍历部分树结构。  
这些操作会增加单次操作的实际运行时间（尽管均摊时间复杂度仍为 \(O(\log n)\)）。  


### 三、空间效率问题  
二叉树的每个节点需要存储**左右子节点的指针（或引用）**，这会额外占用内存空间。例如：  
- 一个存储整数的二叉树节点，除了整数值本身（4字节），还需两个指针（各8字节，64位系统），总空间为20字节；  
- 相比之下，数组存储整数仅需4字节（不考虑扩容开销），链表存储整数需16字节（值+前后指针）。  
对于大规模数据（如百万级节点），二叉树的指针开销会导致**内存利用率显著降低**。  


### 四、遍历与操作的辅助结构依赖  
二叉树的遍历（如前序、中序、后序）或复杂操作（如路径查找、子树复制）通常需要**递归**或**显式栈/队列**辅助：  
- 递归实现可能导致**栈溢出**（如深度为10万层的树，递归调用栈可能超出JVM栈深度限制）；  
- 显式栈/队列需要额外的内存空间（最坏情况下与树的高度成正比，如链表的栈空间为 \(O(n)\)）。  


### 五、结构灵活性不足  
二叉树的核心限制是**每个节点最多有两个子节点**（左、右）。对于需要更多分支的场景（如表示多叉关系，如文件系统的目录结构可能有子目录、文件、快捷方式等多个关联项），二叉树需要通过“多叉树转二叉树”的技巧（如左孩子右兄弟表示法）间接实现，增加了结构的复杂性和理解成本。  


### 六、缓存不友好  
二叉树的节点通常通过指针（或引用）连接，节点在内存中**分散存储**（非连续）。而数组或链表（连续或部分连续）的内存布局更符合CPU缓存机制（缓存预取连续内存块），因此二叉树的节点访问可能面临**缓存未命中**问题，导致实际访问速度低于理论时间复杂度。  


### 总结：二叉树的适用场景与避坑建议  
二叉树的缺点提示我们，它并非“万能数据结构”，需根据具体场景选择：  
- **适合场景**：数据需要动态有序存储、频繁查找但插入/删除较少（如配置项管理）、或平衡树优化后的场景（如Java的`TreeSet`）。  
- **避坑建议**：  
  - 若数据可能有序插入，优先选择平衡二叉树（如红黑树）或跳表（Skip List）；  
  - 若内存敏感，考虑数组或紧凑结构的树（如B树/B+树，多叉树减少高度）；  
  - 若需要高频遍历或局部性访问，优先选择数组或链表。  

总之，二叉树的缺点本质上是**结构特性与操作需求的权衡**，理解这些局限性有助于在实际开发中选择更合适的数据结构。



## 二叉树（`Binary Tree`）- 性能测试

>说明：在`100`万元素的情况下，对比 `TreeSet`（<a href="/java/README.html#treeset-底层算法" target="_blank">底层使用红黑树算法</a>）的 `contains` 和 `int` 数值遍历查找元素的性能区别，以直观地感受二叉树算法的检索性能是极高的。
>
>详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/demo-binary-tree)

`JMH` 测试结果：

```
Benchmark                              Mode  Cnt         Score           Error  Units
PerformanceTests.testIntArraySearch   thrpt    3      6252.344 ±      5860.978  ops/s
PerformanceTests.testTreeSetContains  thrpt    3  23212144.759 ± 149383123.046  ops/s
```

可以看出在数据量大时，二叉树的检索性能远高于数组的遍历查找性能。



## 红黑树 - 概念

红黑树（Red-Black Tree）是一种**自平衡的二叉搜索树（Self-Balancing Binary Search Tree）**，通过在每个节点中增加一个**颜色属性（红色或黑色）**，并定义严格的规则来约束树的结构，从而保证树在动态操作（插入、删除、查找）中始终保持**近似平衡**，避免退化为链表（时间复杂度从 \(O(n)\) 优化到 \(O(\log n)\)）。


### 一、红黑树的核心定义：颜色与规则
红黑树的每个节点包含以下信息：  
- 数据值（Key）  
- 左右子节点指针（Left/Right）  
- 父节点指针（Parent）  
- 颜色标记（Color，红色或黑色）  

其平衡的核心由以下**五大规则**保证：  

#### 1. 节点颜色规则  
每个节点要么是红色，要么是黑色。  

#### 2. 根节点规则  
根节点必须是黑色。  

#### 3. 叶子节点规则  
所有叶子节点（NIL节点，即空节点，用于表示树的末端）视为黑色。  

#### 4. 红节点规则（无连续红节点）  
红色节点的两个子节点必须是黑色（即不存在父节点和子节点均为红色的情况）。  

#### 5. 黑高规则（路径平衡）  
从任一节点到其所有后代叶子节点的路径中，**黑色节点的数量相同**（这个数量称为该节点的“黑高”，Black Height）。  


### 二、红黑树的“近似平衡”特性
红黑树通过上述规则，确保了树的**高度不会超过 \(2\log(n+1)\)**（\(n\) 为节点数），从而保证插入、删除、查找操作的时间复杂度稳定在 \(O(\log n)\)。  

#### 对比普通BST与AVL树：  
- **普通BST**：无平衡约束，有序插入时退化为链表（高度 \(O(n)\)）。  
- **AVL树**：严格平衡（任意节点左右子树高度差绝对值 ≤1），高度 \(O(\log n)\)，但插入/删除时可能需要多次旋转（最多 \(O(\log n)\) 次）。  
- **红黑树**：弱平衡（通过颜色规则间接保证），高度最多为 \(2\log(n+1)\)，但插入/删除时仅需 \(O(1)\) 次旋转（平均情况），维护成本更低。  


### 三、红黑树的关键操作：插入、删除与调整
红黑树的核心操作（插入、删除）需要同时维护二叉搜索树的性质（有序性）和红黑树的颜色规则。若插入/删除后破坏了颜色规则，需通过**颜色翻转**和**旋转操作**恢复平衡。  


#### 1. 插入操作  
插入新节点时，默认设为红色（避免破坏黑高规则），然后检查是否违反红黑树规则（主要是红节点规则）。若违反，通过以下三种情况调整：  

- **情况1：叔叔节点是红色**  
  父节点和叔叔节点均为红色 → 将父、叔节点染黑，祖父节点染红，然后将祖父节点作为新节点继续向上检查。  

- **情况2：叔叔节点是黑色（或NIL），且新节点是父节点的右子节点（父节点是祖父的左子节点）**  
  通过左旋父节点，将问题转换为情况3。  

- **情况3：叔叔节点是黑色（或NIL），且新节点是父节点的左子节点（父节点是祖父的左子节点）**  
  将父节点染黑，祖父节点染红，然后右旋祖父节点。  


#### 2. 删除操作  
删除节点时，若被删节点是黑色，会破坏黑高规则（路径黑色节点数减少），需通过调整恢复。删除调整比插入更复杂，分为四种情况（涉及兄弟节点、兄弟的子节点颜色等），最终通过颜色翻转和旋转恢复平衡。  


#### 3. 旋转操作  
旋转是红黑树调整结构的核心手段，分为**左旋**和**右旋**：  
- **左旋**：将某个节点的右子节点提升为新根，原节点变为左子节点（用于调整右子树过高的情况）。  
- **右旋**：将某个节点的左子节点提升为新根，原节点变为右子节点（用于调整左子树过高的情况）。  


### 四、红黑树的实际应用
红黑树因兼顾平衡效率与实现复杂度（相比AVL树更简单），被广泛应用于需要**高效动态有序存储**的场景：  

#### 1. Java集合框架  
- `java.util.TreeMap`：基于红黑树实现的有序键值对集合（按键的自然顺序或自定义`Comparator`排序）。  
- `java.util.TreeSet`：基于`TreeMap`实现的有序无重复集合（键为元素，值为静态空对象`PRESENT`）。  


#### 2. C++标准库  
- `std::map`：有序键值对容器（默认按键升序排列），底层为红黑树。  
- `std::set`：有序无重复集合，底层同样基于红黑树。  


#### 3. 数据库索引  
部分数据库（如MySQL的InnoDB）的辅助索引（Secondary Index）使用红黑树（或B+树变体）优化查询效率。  


#### 4. 系统工具  
操作系统的进程调度、内存管理等场景中，红黑树可用于高效管理动态有序的任务或资源。  


### 五、红黑树的优势与局限
#### 优势：  
- **平衡效率高**：插入/删除时仅需少量旋转（平均 \(O(1)\) 次），优于AVL树的多次旋转。  
- **时间复杂度稳定**：所有操作的最坏时间复杂度为 \(O(\log n)\)，适合高频动态操作场景。  
- **空间开销低**：仅需额外存储一个颜色标记（1位），相比AVL树的平衡因子（需存储整数），空间更节省。  


#### 局限：  
- **查找略慢于AVL树**：红黑树的平衡是“弱平衡”，树的高度可能略高于AVL树（最多 \(2\log(n+1)\) vs AVL的 \(\log(n+1)\)），因此查找操作的最坏时间复杂度稍高（但实际中差异可忽略）。  


### 总结  
红黑树是一种**通过颜色规则实现自平衡的二叉搜索树**，在动态有序数据管理中表现优异，兼顾了平衡效率与实现复杂度。它是工业级数据结构的首选之一，广泛应用于Java、C++等语言的标准库及数据库系统中。理解红黑树的核心规则和调整逻辑，是掌握高级数据结构与算法的关键一步。



## 红黑树 - 缺点

红黑树作为一种高效的自平衡二叉搜索树，虽然在动态有序数据管理中表现优异，但其设计和特性也带来了一些固有的缺点。以下从实现复杂度、平衡特性、空间与缓存、特定操作限制等角度，详细分析红黑树的缺点：


### 一、实现复杂度高：调整逻辑繁琐  
红黑树的平衡依赖于**颜色规则**和**旋转操作**，插入/删除时需通过复杂的条件判断和调整（颜色翻转、旋转）来恢复平衡。其调整逻辑涉及多种情况（如插入时的“叔叔节点颜色”“父子节点位置关系”，删除时的“兄弟节点颜色”“兄弟子节点颜色”等），代码实现难度大，调试和维护成本高。  

**示例**：红黑树插入操作需处理3种调整情况（叔叔红/黑+节点位置），删除操作更需处理4种调整情况（兄弟红/黑+兄弟子节点颜色组合）。相比之下，AVL树的调整逻辑（仅旋转）更简单，但红黑树的平衡规则更隐晦，容易因代码错误导致平衡破坏。  


### 二、弱平衡导致树高相对更高  
红黑树通过颜色规则实现“弱平衡”，仅保证**最长路径不超过最短路径的2倍**（树高最多为 \(2\log(n+1)\)），而AVL树要求**任意节点左右子树高度差绝对值≤1**（树高为 \(\log(n+1)\)）。因此：  
- **查找效率略低**：红黑树的最坏查找时间复杂度虽仍为 \(O(\log n)\)，但实际中可能比AVL树多几次比较（因树高更高）。  
- **极端场景性能差异**：对于需要频繁查找的场景（如实时系统），AVL树的严格平衡可能更优，但红黑树通过牺牲部分平衡性换取了更低的插入/删除调整成本。  


### 三、缓存不友好：节点分散存储  
红黑树的节点通过指针（或引用）连接，内存中**节点分布不连续**（非数组的连续存储）。而CPU缓存机制倾向于预取连续内存块（局部性原理），因此红黑树的节点访问可能面临**缓存未命中**问题，导致实际访问速度低于理论时间复杂度。  

**对比**：数组或紧凑结构的树（如B树/B+树，节点存储多个键值）更利于缓存预取，适合高频访问或磁盘存储场景（如数据库索引）。  


### 四、范围查询效率相对较低  
红黑树支持高效的单点查找、插入和删除，但**范围查询（如查找所有在区间 \([a,b]\) 内的节点）**的效率不如B树或B+树：  
- 红黑树的范围查询需通过中序遍历逐个访问节点，时间复杂度为 \(O(k + \log n)\)（\(k\) 为结果数量）。  
- B+树的节点存储多个键值，且叶子节点通过链表连接，范围查询可通过遍历叶子节点链表快速完成（时间复杂度 \(O(k + \log n)\)，但常数更小）。  


### 五、空间开销：额外颜色标记的累积成本  
每个红黑树节点需额外存储一个**颜色标记**（通常用1位表示，如用布尔值或整数的最低位）。虽然单个节点的开销很小（约1位），但在大规模数据场景下（如十亿级节点），累积的空间开销可能不可忽视。  

**对比**：AVL树需存储平衡因子（通常为整数，占4字节），红黑树的颜色标记空间更小；但相比数组或哈希表（无额外指针），红黑树的指针（左右子节点+父节点）和颜色标记的总空间开销仍较高。  


### 六、不适合磁盘存储场景  
红黑树是内存数据结构的典型代表，其节点通过指针连接，依赖内存的高随机访问速度。但在**磁盘存储**（如数据库索引）中，红黑树的缺点更突出：  
- 磁盘的I/O操作是块级别的（每次读取一个页，通常4KB），红黑树的单个节点大小可能小于页大小，导致**页利用率低**（一个页仅存储少量节点）。  
- 红黑树的高度较高（如百万节点的树高约20层），每次查找需进行20次磁盘I/O，而B树/B+树通过多叉设计降低树高（如百万节点的B+树高约3层），显著减少I/O次数。  


### 总结：红黑树的适用场景与避坑建议  
红黑树的缺点提示我们，它并非“万能数据结构”，需根据具体需求选择：  

#### 适合场景：  
- **内存中的动态有序数据**（如Java的`TreeMap`、C++的`std::map`），需频繁插入、删除和单点查找，但对范围查询要求不高。  
- **对实现复杂度容忍度较高的场景**（如标准库或框架，开发者无需手动维护）。  

#### 避坑建议：  
- 若需**高效范围查询**或**磁盘存储**，优先选择B树/B+树（如MySQL的InnoDB索引）。  
- 若数据**严格有序且插入顺序可控**（如按时间戳递增插入），可考虑跳表（Skip List，实现更简单且范围查询高效）。  
- 若内存敏感且数据量极大，可考虑压缩树结构（如压缩红黑树）或使用数组替代（如有序数组+二分查找，但插入/删除效率低）。  

**核心结论**：红黑树的缺点本质上是**平衡策略、内存模型与操作需求权衡的结果**。理解这些局限性有助于在实际开发中选择更适配的数据结构，避免“为了用红黑树而用红黑树”的误区。



## 红黑树 - 性能测试

>说明：在`100`万元素的情况下，对比 `TreeSet`（<a href="/java/README.html#treeset-底层算法" target="_blank">底层使用红黑树算法</a>）的 `contains` 和 `int` 数值遍历查找元素的性能区别，以直观地感受红黑树算法的检索性能是极高的。
>
>详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/demo-binary-tree)

`JMH` 测试结果：

```
Benchmark                              Mode  Cnt         Score           Error  Units
PerformanceTests.testIntArraySearch   thrpt    3      6252.344 ±      5860.978  ops/s
PerformanceTests.testTreeSetContains  thrpt    3  23212144.759 ± 149383123.046  ops/s
```

可以看出在数据量大时，红黑树的检索性能远高于数组的遍历查找性能。



## `B`树 - 概念

B树（B-Tree，全称“平衡多路搜索树”）是一种**自平衡的多叉树数据结构**，专为**磁盘等外部存储设备的高效数据检索**设计。它通过增加每个节点的子节点数量（即“阶数”），大幅降低树的高度，从而减少磁盘I/O次数，适用于大规模数据的存储与查找。


### 一、B树的核心定义与结构  
B树的核心特性是通过**多叉分支**和**平衡约束**，在磁盘中组织数据，使得每次查找、插入、删除操作仅需访问少量磁盘块（节点）。其结构定义如下：  


#### 1. 阶数（Order）  
B树的“阶数”（记为 \( m \)）表示一个节点**最多可以拥有的子节点数量**。例如，3阶B树（\( m=3 \)）的节点最多有3个子节点。  


#### 2. 节点的键（Key）与子节点关系  
对于 \( m \) 阶B树的任意节点：  
- **键的数量**：最少 \( \lceil m/2 \rceil - 1 \) 个（向上取整），最多 \( m-1 \) 个（根节点除外，根节点最少0个键）。  
- **子节点数量**：子节点数 = 键数 + 1。因此，子节点数量范围为：  
  - 最少 \( \lceil m/2 \rceil \) 个（根节点最少2个子节点，除非树为空）；  
  - 最多 \( m \) 个。  


#### 3. 平衡性约束  
B树是**严格平衡的多叉树**，所有叶子节点位于**同一层**，确保了树的高度最小化。  


### 二、B树的典型结构示例  
以3阶B树（\( m=3 \)）为例，其节点结构如下：  

#### 1. 根节点  
- 最少0个键（树为空时），最多2个键（\( m-1=2 \)）。  
- 若根节点非空且有子节点，则至少有2个子节点（\( \lceil 3/2 \rceil=2 \)）。  


#### 2. 内部节点（非根、非叶子）  
- 最少1个键（\( \lceil 3/2 \rceil -1=1 \)），最多2个键。  
- 子节点数 = 键数 + 1，因此最少2个子节点，最多3个子节点。  


#### 3. 叶子节点  
- 结构与内部节点相同（存储键），但无子节点。  
- 所有叶子节点位于同一层。  


**示例图**（3阶B树）：  
```
        [10, 20]       ← 根节点（2个键，3个子节点）
       /    |    \
[5]      [15,18]  [25,30]  ← 内部节点（左：1键2子；中：2键3子；右：2键3子）
       /  \       /  \     /  \
[1,3] [6,7] [12,14] [16,17] [19,21] [23,24] [26,28,29] [31,32]  ← 叶子节点（同一层）
```


### 三、B树的核心操作：查找、插入、删除  
B树的操作需严格遵循平衡约束，确保插入/删除后仍保持多叉平衡结构。  


#### 1. 查找操作  
B树的查找过程类似于二叉搜索树，但每个节点需按顺序比较多个键，找到对应的子节点继续查找，直到叶子节点或找到目标键。  

**步骤**（以3阶B树查找键17为例）：  
1. 根节点为 `[10,20]`，比较17与10、20，确定17在10和20之间，进入中间子节点 `[15,18]`。  
2. 中间节点 `[15,18]` 包含键15、18，比较17与15、18，确定17在15和18之间，进入右侧子节点（假设子节点为 `[16,17]`）。  
3. 最终在叶子节点 `[16,17]` 中找到键17。  

**时间复杂度**：\( O(\log_m n) \)（\( m \) 为阶数，\( n \) 为数据量），树高极低（如百万数据量时，树高仅约3层），因此磁盘I/O次数极少。  


#### 2. 插入操作  
插入键时，需找到对应的叶子节点，若该节点未满（键数 \( < m-1 \)），则直接插入；若已满（键数 \( = m-1 \)），则触发**分裂**操作：  

- **分裂过程**：将满节点的中间键提升到父节点，剩余键均分为左右两部分，形成两个新节点。若父节点因此变满，则继续向上分裂，直至根节点（根节点分裂会生成新根，树高增加1）。  

**示例**（3阶B树插入键19）：  
假设叶子节点 `[16,17]` 已满（键数=2=m-1），插入19后需分裂：  
- 中间键为17（或16，取决于具体实现），提升到父节点；  
- 原节点分裂为 `[16]` 和 `[19]`（假设提升17）。  


#### 3. 删除操作  
删除键时，若键所在节点是叶子节点且键数 \( > \lceil m/2 \rceil -1 \)，则直接删除；若键数不足（\( \leq \lceil m/2 \rceil -1 \)），则需通过**借用**或**合并**兄弟节点的键来补充，以保持平衡。  


### 四、B树的特性与优势  
B树的设计针对磁盘存储优化，核心优势如下：  


#### 1. 低树高，减少磁盘I/O  
通过多叉分支（高阶数 \( m \)），B树的树高远低于二叉树或红黑树。例如，存储100万条数据时，3阶B树的高度仅需 \( \log_3(10^6) \approx 12 \) 层（实际因节点键数更多，树高更低），每次查找仅需12次磁盘I/O，效率极高。  


#### 2. 平衡性保证稳定性能  
所有叶子节点位于同一层，避免了普通树结构的退化问题（如二叉树退化为链表），确保插入、删除、查找的时间复杂度均为 \( O(\log_m n) \)。  


#### 3. 适配磁盘块存储  
B树的节点大小通常与磁盘块大小（如4KB、8KB）严格匹配，每次I/O可读取一个完整的节点，充分利用磁盘的块访问特性，减少I/O浪费。  


### 五、B树的局限性与应用场景  
尽管B树性能优异，但它在**范围查询**和**顺序访问**场景中存在不足（后续B+树对其进行了优化）：  

- **范围查询效率低**：B树的叶子节点之间无链表连接，范围查询（如查找区间 \([a,b]\) 内的所有键）需递归遍历多个子树，无法通过顺序遍历快速获取结果。  


**典型应用场景**：  
- 早期数据库系统（如Oracle 7之前的版本）的索引；  
- 文件系统（如NTFS、ReiserFS）的目录管理；  
- 需要高效随机查找但范围查询较少的场景。  


### 总结  
B树是一种专为磁盘存储设计的多叉平衡树，通过高阶数分支降低树高，减少磁盘I/O次数，保证了插入、查找、删除操作的高效性和稳定性。尽管其范围查询能力弱于B+树，但其设计思想（多叉平衡、节点与磁盘块匹配）为后续数据结构（如B+树）奠定了基础，仍是理解外部存储索引的重要基础。



## `B`树 - 缺点

B树（B-Tree）作为一种经典的多叉平衡树，虽在磁盘存储场景中通过降低树高提升了查询效率，但其设计和特性也存在一些固有的缺点，尤其在现代数据库和文件系统的需求下，这些缺点逐渐被B+树等变体优化。以下是B树的主要缺点分析：


### 一、范围查询效率低：缺乏叶子节点链表  
B树的**叶子节点之间无链表连接**，这是其与B+树最核心的差异之一。这一特性导致范围查询（如查找区间 \([a, b]\) 内的所有键）时效率显著低于B+树：  

- **B树的范围查询逻辑**：需从根节点开始递归查找每个可能的子树，找到符合条件的键后，再回溯到父节点继续查找其他可能的子树。例如，查找 `[100, 200]` 的区间时，可能需要多次访问不同的子树分支，无法通过顺序遍历快速完成。  
- **对比B+树**：B+树的所有叶子节点通过双向链表连接，形成有序序列，范围查询只需遍历叶子节点链表即可，时间复杂度为 \(O(k + \log n)\)（\(k\) 为结果数量），而B树的范围查询时间复杂度虽同为 \(O(k + \log n)\)，但常数因子更大（需多次递归跳转）。  


### 二、节点结构复杂，操作难度高  
B树的每个节点（包括内部节点和叶子节点）均需存储**键（Key）**和**子节点指针**，且插入、删除时需严格维护节点的平衡约束（如键数范围、子节点数匹配）。这一特性导致：  

- **实现复杂度高**：插入时需处理节点分裂（满节点拆分），删除时需处理节点合并或借用兄弟节点的键，逻辑涉及多种边界条件（如根节点的特殊处理、非叶子节点的键与子节点指针的同步调整）。  
- **调试与维护成本高**：节点结构的复杂性增加了代码调试的难度，尤其在处理大规模数据时，错误可能引发树的不平衡，导致性能下降。  


### 三、空间利用率相对较低（对比B+树）  
B树的**内部节点存储完整数据**（或指向数据的指针），而B+树的非叶子节点仅存储键和子节点指针。这一差异导致：  

- **单节点键数量减少**：B树的内部节点需为数据预留空间，因此每个节点能存储的键数量更少（例如，若数据占100字节，磁盘块大小为16KB，B树节点可能仅能存储约140个键；而B+树节点仅存键和指针，可存储约1024个键）。  
- **树高可能更高**：单节点键数量的减少会直接导致树高增加（树高 \(h \approx \log_m n\)，\(m\) 为单节点键数），进而增加磁盘I/O次数，降低查询效率。  


### 四、不支持高效的顺序访问  
B树的叶子节点与内部节点结构相同，且无链表连接，因此**顺序访问（如全表扫描）**需通过递归遍历所有子树，无法像B+树那样通过叶子链表直接顺序读取。这一特性在需要频繁全表扫描或顺序处理的场景（如日志分析、批量数据导出）中效率较低。  


### 五、插入/删除的调整范围可能更广  
B树的插入和删除操作可能触发节点的分裂或合并，且调整可能涉及**从叶子节点到根节点的路径上的多个节点**。例如：  
- 插入时若叶子节点分裂，中间键需提升到父节点，若父节点因此变满，需继续向上分裂，直至根节点（根节点分裂会生成新根，树高增加1）。  
- 删除时若键数不足，需从兄弟节点借用键或合并节点，同样可能涉及多层父节点的调整。  

相比之下，B+树的插入/删除操作主要集中在叶子节点（非叶子节点仅作为索引），调整范围更小，操作更高效。  


### 总结：B树的适用场景与替代方案  
B树的缺点使其在现代数据库索引中逐渐被B+树取代，但其设计思想（多叉平衡、节点与磁盘块匹配）仍是外部存储索引的基础。B树的典型适用场景包括：  

- **早期数据库系统**（如Oracle 7之前的版本）；  
- **文件系统的目录管理**（如NTFS、ReiserFS），需高效随机查找但范围查询需求较低；  
- **对空间利用率要求不高的场景**（如嵌入式系统的本地存储）。  

**核心结论**：B树的缺点本质上是**多叉平衡设计与磁盘存储需求权衡的结果**。尽管其在范围查询、顺序访问等场景中存在不足，但其低树高、平衡性稳定的特性仍使其在特定场景中不可替代。理解这些局限性有助于在实际开发中选择更适配的数据结构（如B+树）。



## `B`树 - 性能测试

>`todo` 做实验测试。



## `B+`树 - 概念

B+树（B+ Tree）是B树（B-Tree）的变种，属于**多叉平衡树**，通过优化节点结构和存储方式，进一步提升了磁盘存储场景下的查询效率，尤其适合**范围查询**和**顺序访问**。它是现代数据库（如MySQL、Oracle）和文件系统中最常用的索引数据结构。


### 一、B+树的核心定义与结构  
B+树的核心设计思想是：**将数据集中存储在叶子节点，非叶子节点仅作为索引**，并通过叶子节点的链表连接实现高效的顺序访问。其结构定义如下：  


#### 1. 阶数（Order）  
B+树的“阶数”（记为 \( m \)）表示一个节点**最多可以拥有的子节点数量**（与B树相同）。例如，3阶B+树（\( m=3 \)）的节点最多有3个子节点。  


#### 2. 节点类型：非叶子节点 vs 叶子节点  
B+树的节点分为两类，功能差异显著：  

- **非叶子节点（内部节点）**：  
  仅存储**键（Key）**和**子节点指针**，不存储完整数据记录。键用于索引，子节点指针指向下一层子树。  
  键的数量范围：最少 \( \lceil m/2 \rceil - 1 \) 个（根节点最少0个），最多 \( m-1 \) 个（与B树类似）。  

- **叶子节点**：  
  存储**所有键（Key）**和**完整数据记录（或指向数据的指针）**，且所有叶子节点通过**双向链表**连接，形成有序序列。  
  键的数量范围：与非叶子节点相同（最少 \( \lceil m/2 \rceil - 1 \) 个，最多 \( m-1 \) 个）。  


#### 3. 平衡性约束  
B+树是**严格平衡的多叉树**，所有叶子节点位于**同一层**，确保树的高度最小化。  


### 二、B+树的典型结构示例  
以3阶B+树（\( m=3 \)）为例，其结构如下：  

```
        [10, 20]       ← 非叶子节点（2个键，3个子节点指针）
       /    |    \
[5,8]    [15,18]  [25,30]  ← 叶子节点（每个存储2个键+数据指针，通过链表连接）
       \    /       \  /
        [数据1] [数据2] [数据3]...  ← 实际数据记录（或指针）
```

- **非叶子节点**：仅存储键（10、20）和子节点指针，不包含数据。  
- **叶子节点**：存储键（如5、8）和对应的数据记录（或指针），且通过双向链表连接（如 `[5,8]` 的右指针指向 `[15,18]`，左指针指向更前的叶子节点）。  


### 三、B+树的核心操作：查找、插入、删除  
B+树的操作逻辑与B树类似，但因节点结构不同（非叶子节点不存数据），调整策略更简单。  


#### 1. 查找操作  
B+树的查找过程**始终从根节点到叶子节点**，最终在叶子节点中定位目标键（或在叶子节点的链表中范围查找）。  

**步骤**（以3阶B+树查找键17为例）：  
1. 根节点为 `[10,20]`，比较17与10、20，确定17在10和20之间，进入中间子节点 `[15,18]`（叶子节点）。  
2. 在叶子节点 `[15,18]` 中查找17，找到对应的数据记录。  

**时间复杂度**：\( O(\log_m n) \)（\( m \) 为阶数，\( n \) 为数据量），树高极低（如百万数据量时，树高仅约3层），磁盘I/O次数极少。  


#### 2. 插入操作  
插入键时，需找到对应的叶子节点：  
- 若叶子节点未满（键数 \( < m-1 \)），直接插入并保持有序；  
- 若叶子节点已满（键数 \( = m-1 \)），触发**分裂**操作：  
  - 将叶子节点的中间键（或最后一个键）复制到父节点（非叶子节点）作为索引；  
  - 原叶子节点分裂为两个新节点，通过链表连接；  
  - 若父节点因插入变满，则继续向上分裂，直至根节点（根节点分裂会生成新根，树高增加1）。  

**示例**（3阶B+树插入键19）：  
假设叶子节点 `[15,18]` 已满（键数=2=m-1），插入19后：  
- 中间键18被复制到父节点；  
- 原节点分裂为 `[15]` 和 `[19]`，通过链表连接。  


#### 3. 删除操作  
删除键时，若键所在叶子节点键数 \( > \lceil m/2 \rceil - 1 \)，直接删除；若键数不足（\( \leq \lceil m/2 \rceil - 1 \)），需通过**借用**或**合并**兄弟节点的键来补充：  
- **借用**：从相邻兄弟节点（左或右）借用一个键，同时更新父节点的索引键；  
- **合并**：若兄弟节点也无多余键，则将当前节点与兄弟节点合并，父节点删除对应的索引键；  
- 若父节点因合并变空（键数为0），则删除父节点并合并到更上层。  


### 四、B+树的核心特性与优势  
B+树的设计针对磁盘存储和数据库需求优化，核心优势如下：  


#### 1. 高效范围查询：叶子节点链表化  
B+树的所有叶子节点通过双向链表连接，形成有序序列。范围查询（如 `SELECT * FROM table WHERE id BETWEEN 100 AND 200`）只需遍历叶子节点链表，无需回溯到上层节点，时间复杂度为 \( O(k + \log n) \)（\( k \) 为结果数量），效率远高于B树（需递归遍历多个子树）。  


#### 2. 低树高，减少磁盘I/O  
B+树的非叶子节点仅存储键和指针，不存储数据，因此每个磁盘块（节点）能存储的键数量更多（例如，磁盘块大小16KB，键占8字节，指针占8字节，3阶B+树节点可存储 \( 16KB / (8+8) = 1024 \) 个键）。树高 \( h \approx \log_m n \)（\( m \) 为单节点键数），百万数据量时树高仅约3层，每次查找仅需3次磁盘I/O。  


#### 3. 空间利用率高  
非叶子节点不存储数据，所有空间用于存储索引键和指针，因此单节点能存储更多键，进一步提升树高降低和空间利用率。  


#### 4. 稳定的插入/删除性能  
插入和删除操作主要调整叶子节点及其父节点的索引键，逻辑比B树更简单（无需修改非叶子节点的数据），且调整范围更小（仅涉及叶子节点到父节点的路径）。  


#### 5. 适配磁盘块存储  
B+树的节点大小通常与磁盘块大小（如4KB、8KB、16KB）严格匹配，每次I/O可读取一个完整的节点，充分利用磁盘的块访问特性（局部性原理），减少I/O浪费。  


### 五、B+树的典型应用场景  
B+树因其特性完美契合数据库和文件系统的需求，被广泛使用：  


#### 1. 数据库索引  
- **MySQL**：InnoDB和MyISAM引擎均使用B+树作为主键索引和辅助索引的底层结构。  
- **Oracle**：B+树是索引的默认选择，支持高效的等值查询和范围查询。  


#### 2. 文件系统  
- **NTFS**（Windows）：使用B+树管理文件目录和元数据，支持快速文件查找。  
- **ReiserFS**（Linux）：通过B+树优化文件存储，提升大文件读写效率。  


#### 3. 全文检索与日志系统  
- 全文检索引擎（如Elasticsearch）的倒排索引底层常用B+树变体，支持高效的关键词范围查询。  
- 日志系统（如Kafka）的偏移量索引使用B+树，支持快速的偏移量查找和范围扫描。  


### 总结  
B+树是B树的优化变体，通过**非叶子节点仅存索引、叶子节点链表化**等设计，显著提升了范围查询效率和磁盘I/O性能，是现代数据库和文件系统的核心数据结构。其核心价值在于：**在保持平衡树低树高的同时，完美适配了磁盘存储的块访问特性，并高效支持顺序访问和范围查询**。



## `B+`树 -性能测试

>`todo` 做实验测试。