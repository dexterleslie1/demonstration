# `java`场景题目

## 如何设计一个分布式缓存系统？

设计一个分布式缓存系统需要考虑以下几个方面：

- 数据分片：将缓存数据分散存储在多个节点上，每个节点负责一部分数据，以提高并发读写操作的吞吐量。
- 数据一致性：为了保证数据的一致性，可以采用一致性哈希算法来确认数据在哪个节点上存储，并使用分布式锁来控制并发写操作。
- 缓存失效策略：可以采用时间过期策略或基本`LRU`（最近最少使用）算法来淘汰缓存数据，以避免缓存空间被耗尽。
- 缓存更新策略：可以采用写回（Write Back）策略，即先将更新操作记录在缓存中，然后异步更新到持久化存储中，以提高写操作的性能。
- 缓存命中率优化：可以使用布隆过滤器来判断一个数据是否存在于缓存中，以减少缓存命中的情况。
- 数据备份和容错：可以使用数据复制或数据备份的方式来提高系统的容错性，以防止节点故障导致数据丢失。
- 负载均衡：可以使用负载均衡算法将请求均匀地分发到各个缓存节点上，以提高系统的整体性能和可扩展性。

以上是设计一个分布式缓存系统的一些关键考虑点，具体的实现方式会根据具体的需求和场景而有所不同。在设计过程中，还需要考虑系统的可用性、性能、扩展性和安全性等方面的需求，并进行合理的权衡和折衷。

## 数据库死锁问题如何排查？

todo 编写一个完整的模拟实际排查过程

## `MySQL`事务隔离级别？

## `JVM CPU`飙高问题如何排查？

## `OOM`问题如何排查？

## 频繁`FullGC`问题如何排查？

1. 查看内存使用情况和`GC`信息
2. 通过`GC`信息分析是否有内存泄漏情况
   - 内存泄漏情况
   - 非内存泄漏情况

## 慢`SQL`问题如何排查？

todo

## `MySQL CPU`使用率高如何排查？

todo

## 电商平台中订单未支付过期如何实现自动关单？

电商平台中订单未支付过期自动关单的实现，可以通过多种技术方案来完成。以下是一些常见的实现方案：

### 1. 定时任务检测

这是最常见的实现方式之一，其基本思路是通过定时任务来检测订单的支付状态。

**实现步骤**：

- 在订单创建时，记录订单的创建时间和设定的超时时间。
- 定时任务（如每分钟或每几分钟执行一次）扫描数据库中的订单记录。
- 对于已超时且未支付的订单，将其状态更新为关闭，并执行相应的后续处理逻辑（如释放库存、发送通知等）。

**优点**：

- 实现简单，易于理解和维护。
- 成本较低，基本不需要引入额外的技术组件。

**缺点**：

- 定时任务的执行间隔会影响订单关闭的精确性。
- 随着订单数量的增加，数据库扫描的压力也会增大。

### 2. 消息队列（延时消息）

消息队列提供了一种解耦合、异步处理的方式，可以实现订单超时自动关单的功能。

**实现步骤**：

- 在订单创建时，向消息队列发送一个带有延时（超时时间）的消息。
- 消息队列在延时时间到达后，将消息投递给消费者。
- 消费者接收到消息后，检查对应订单的支付状态。如果订单未支付且已超时，则将其状态更新为关闭，并执行后续处理逻辑。

**优点**：

- 系统解耦，提高系统的可伸缩性和可靠性。
- 延时消息可以精确控制订单关闭的时间。

**缺点**：

- 需要引入消息队列组件，增加系统的复杂性。
- 需要确保消息队列的可靠性和可用性。

### 总结

在实际应用中，电商平台通常会根据自身的业务需求和系统架构选择合适的实现方案。对于大多数电商平台来说，定时任务检测和消息队列（延时消息）是两种较为常见且有效的实现方式。同时，也需要注意定时任务的精确性、系统性能和可维护性等方面的问题。



## 如何设计一个秒杀系统？

## 如果你的系统的`QPS`突然提升10倍你会怎么设计？

当系统的`QPS`（每秒查询率）突然提升10倍时，这要求系统能够迅速扩展并处理这种增加的负载，同时保持低延迟和高可用性。

- 使用`kubernetes`、`terraform`、`ansible`等相关技术根据监控指标自动扩展系统的基础设施。
- 开发后期，在模拟环境中压力测试10倍的`QPS`，通过监控和告警各项指标分析和判断系统的性能瓶颈位置。再各个调优瓶颈位置并实现瓶颈位置的横向扩展能力
- 例如：`nginx`调优和横向扩展、`springboot`（应用服务器）调优和横向扩展、`redis`缓存的调优和横向扩展、`MySQL`的调优和横向扩展



## 如何设计一个支持10万`QPS`的会员系统？

## 设计一个支持10万`QPS`的评论中台，你会怎么设计？

## 短`URL`生成器设计：百亿短`URL`怎样做到无冲突？

### 短`URL`原理

1. **输入长URL**：用户向短URL服务提供原始的长URL。
2. **生成短URL**：短URL服务利用上述算法或其他算法生成对应的短URL。
3. **存储映射关系**：将长URL与生成的短URL之间的映射关系存储在数据库中。
4. **返回短URL**：将生成的短URL返回给用户。
5. **访问短URL**：当用户或其他用户点击短URL时，短URL服务会查找数据库中对应的映射关系，将请求重定向到原始的长URL。

**预生成算法（预先生成短`URL`）**：

- **随机数+布隆过滤器**：采用随机数生成短URL，并在生成过程中使用布隆过滤器来检查是否已存在，确保生成的URL唯一。这种方法可以离线进行，生成后存储在文件系统中，避免了在线生成时的性能问题。
- 根据实际需求选择合适的短URL长度。例如，使用Base64编码时，6个字符的短URL可以编码约680亿个不同的URL，足以满足百亿级别的需求。



## 如何设计一个支持万亿`GB`网盘实现秒传与限速的系统？

## 如何设计一个支持三千万用户同时在线的短视频系统？

## 微博系统设计：怎么应对热点事件的突发访问压力？

## 如何避免超预期的高并发压力压跨系统？

## 设计一个支持敏感数据存储和传输安全的加解密平台？

## 如何设计一个支持5亿用户规模的网约车系统？

## 如何让系统抗住双十一的预约抢购活动？

## 如果让你设计一个支持千万级流量的架构，你会怎么设计？（包括前端和后端优化）

## 如何设计`RPC`框架在10万`QPS`下实现毫秒级的服务调用？

## 在你上一家公司中是如何实现蓝绿发布的？

## 如何根据应用场景选择合适的消息中间件？

## 如何提升`RocketMQ`顺序消费性能？

## 使用分布式调度框架该考虑那些问题？

## 在做同城多或方案中如何实现机房之间的数据同步？

## 你们采用微服务架构，请问你是什么做系统拆分的？