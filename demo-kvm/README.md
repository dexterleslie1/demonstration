## 概念

### 一句话概括

**KVM 是一个开源的、内置于 Linux 操作系统内核的虚拟化技术，它能让 Linux 本身变成一个** **Hypervisor（虚拟机监控器）**，从而可以在一台物理服务器上运行多个相互隔离的虚拟服务器（即虚拟机）。

---

### 详细解释

#### 1. 核心概念：什么是虚拟化？

想象一下，你有一台性能非常强大的物理服务器（比如 128 核 CPU，512G 内存）。如果你只在这台服务器上运行一个网站，那绝大部分计算资源都被浪费了。

虚拟化技术就是解决这个浪费问题的。它通过软件（即 Hypervisor）将这台强大的物理服务器“分割”成多个独立的、虚拟的“小服务器”。每个“小服务器”都可以运行自己的操作系统（如 Windows, Linux）和应用程序，就像一台真正的计算机一样。这些“小服务器”就是**虚拟机**。

#### 2. KVM 的工作原理

KVM 的全称是 **Kernel-based Virtual Machine**，即**基于内核的虚拟机**。这个名字精准地描述了它的本质：

*   **基于内核**：KVM 不是一个独立的应用程序，它是以一个**可加载内核模块**（`kvm.ko`）的形式直接构建在 Linux 内核中的。这使得它能够直接利用 Linux 内核已经完善的功能，如进程调度、内存管理、硬件驱动等，从而非常高效和稳定。
*   **硬件辅助虚拟化**：KVM 本身并不执行任何模拟（比如模拟一个虚拟的 CPU）。相反，它需要 CPU 硬件的支持（Intel 的 **VT-x** 或 AMD 的 **AMD-V** 技术）。这些技术为虚拟化提供了硬件层面的加速。KVM 的作用是**暴露 `/dev/kvm` 这个接口**，让其他程序（如 QEMU）能够利用这些硬件特性来创建和管理虚拟机。

**简单的工作流程：**
1.  Linux 系统在启动时加载了 KVM 内核模块。
2.  当一个虚拟机管理程序（如 `libvirt`）请求启动一个虚拟机时，KVM 会通过硬件虚拟化扩展，将 Linux 内核本身切换成 Hypervisor 模式。
3.  然后，原本的 Linux 操作系统就变成了运行虚拟机的一个“宿主”（Host），而每个虚拟机则作为主机上的一个**普通进程**被调度和管理。
4.  这样，虚拟机可以直接在物理 CPU 上执行大部分指令，获得了接近原生硬件的性能。

#### 3. KVM 的组成部分

通常我们所说的 “KVM” 实际上指的是一个技术栈，核心包括：

1.  **KVM 内核模块**：提供核心虚拟化基础设施和 CPU 调度。
2.  **QEMU**：一个通用的、开源的机器模拟器和虚拟化器。KVM 负责 CPU 和内存的高效虚拟化，而 **QEMU 则负责 I/O 设备（如硬盘、网卡、显卡）的模拟**。QEMU 通过 `/dev/kvm` 接口与 KVM 交互，这种组合通常被称为 **QEMU-KVM**。它提供了完整的硬件虚拟化解决方案。

#### 4. KVM 的主要优势

*   **高性能、低开销**：由于直接集成在内核中并利用硬件辅助虚拟化，虚拟机的性能损失极小，接近物理机性能。
*   **开源免费**：作为 Linux 内核的一部分，KVM 是完全开源和免费的，这降低了总体拥有成本。
*   **安全性**：虚拟机被作为 Linux 的进程运行，可以利用 Linux 成熟的安全模型（如 SELinux）进行隔离和保护。
*   **可扩展性**：能够支持非常多的虚拟机和庞大的硬件配置，非常适合大型数据中心和云环境。
*   **与 Linux 生态完美集成**：管理工具链非常成熟，例如 `libvirt`、`virt-manager` 等。

#### 5. KVM 的应用场景

KVM 是当今企业级虚拟化和云计算基础设施的绝对主力：

*   **数据中心服务器整合**：将多台旧服务器整合到一台更强大的物理服务器上，节省空间、电力和维护成本。
*   **公有云和私有云**：**OpenStack**、**oVirt**、**Proxmox VE** 等主流云平台都默认或将 KVM 作为底层的虚拟化引擎。许多大型云服务商（如 Google Cloud, Amazon AWS, 阿里云）都在大规模使用 KVM。
*   **虚拟桌面基础架构**：在服务器上运行虚拟桌面，用户通过瘦客户端远程访问。
*   **软件开发和测试**：开发人员可以快速创建多个独立的测试环境。

### 总结

你可以将 KVM 理解为一个**高效、现代的虚拟化引擎**。它把 Linux 内核变成了一个强大的虚拟机监控器，通过与 QEMU 等工具配合，能够创建出性能卓越、隔离性好的虚拟机。它是构建当今云计算世界的基石技术之一。



## 运行原理

KVM 的核心运行原理可以概括为：**它利用 Linux 内核作为管理程序，并依赖现代 CPU 的硬件虚拟化扩展，将虚拟机转换为标准的 Linux 进程，从而由内核直接进行调度和管理。**

下面我们从几个关键点来分解这个原理。

### 1. 基石：硬件辅助虚拟化

在没有硬件辅助虚拟化之前，软件虚拟化（如 QEMU）需要通过复杂的“二进制翻译”和“陷阱-模拟”技术来运行客户机操作系统的指令，这会导致巨大的性能开销。

KVM 的诞生和高效运行，完全依赖于现代 CPU 提供的硬件虚拟化扩展：
*   **Intel** 的 **VT-x** 技术
*   **AMD** 的 **AMD-V** 技术

这些技术为 CPU 引入了新的执行模式，使得虚拟机可以直接在物理 CPU 上安全地执行绝大多数指令，只有少数特权指令才会“陷入”到 Hypervisor 中进行处理。这极大地提升了性能。

### 2. 核心机制：两种执行模式

在支持 VT-x 的 Intel CPU 上，KVM 引入了两种关键的操作模式：

1.  **根模式**：Hypervisor（即 KVM）运行在此模式下。它拥有最高的权限，相当于传统意义上的“内核态”。当虚拟机需要执行特权操作（如访问硬件）时，会退出到此模式，由 KVM 进行处理。
2.  **非根模式**：**客户机操作系统**运行在此模式下。它感觉自己在“内核态”运行，但实际上它的特权指令会受到 CPU 的监控。大部分非特权指令直接在物理 CPU 上全速运行。

这两种模式的切换是由 CPU 硬件直接完成的，非常高效。这个切换过程称为 **VMX 切换**。

### 3. KVM 如何工作：从内核模块到进程

KVM 的运行流程可以分解为以下几个步骤：

**步骤一：加载 KVM 内核模块**
当你在 Linux 主机上加载 `kvm.ko`（以及针对具体 CPU 的 `kvm-intel.ko` 或 `kvm-amd.ko`）模块后，Linux 内核就具备了 Hypervisor 的能力。此时，内核暴露了一个名为 `/dev/kvm` 的字符设备。

**步骤二：用户空间工具（如 QEMU）介入**
像 QEMU 这样的虚拟机监控器（VMM）会通过 `ioctl` 系统调用与 `/dev/kvm` 设备进行交互。它的作用是：
*   模拟虚拟机的硬件设备（如 BIOS、网卡、硬盘控制器、显卡）。
*   提供虚拟机镜像文件。
*   通过 `/dev/kvm` 接口向 KVM 发起创建和运行虚拟机的请求。

**步骤三：创建虚拟机**
1.  QEMU 打开 `/dev/kvm` 设备。
2.  通过 `ioctl` 指令，QEMU 向 KVM 发起一个 `KVM_CREATE_VM` 请求。
3.  KVM 在内核中创建一个代表该虚拟机的数据结构。**此时，这个虚拟机在内核看来，即将成为一个可以被调度的“线程”或“进程”。**

**步骤四：映射内存**
1.  QEMU 为虚拟机分配一块内存（客户机物理内存）。
2.  QEMU 通过 `KVM_SET_USER_MEMORY_REGION` 命令告诉 KVM，将虚拟机的这块内存区域映射到其进程的虚拟地址空间中。
3.  KVM 会维护一个影子页表或直接使用 CPU 的扩展（EPT 或 NPT）来高效地管理客户机虚拟地址 -> 客户机物理地址 -> 主机物理地址的两次转换。

**步骤五：创建 vCPU**
1.  QEMU 为虚拟机创建一个或多个虚拟 CPU（vCPU），每个 vCPU 对应一个 `KVM_CREATE_VCPU` 的 `ioctl` 调用。
2.  KVM 在内核中为每个 vCPU 创建一个内核线程。**这是最关键的一点：每个 vCPU 实际上就是一个标准的 Linux 调度实体（线程）**。你可以使用 `ps aux | grep kvm` 命令看到这些线程。

**步骤六：运行虚拟机**
1.  QEMU 通过 `KVM_RUN` 的 `ioctl` 调用启动 vCPU 线程。
2.  该线程在非根模式下开始执行客户机操作系统的代码。
3.  当发生以下事件时，vCPU 会退出到根模式：
    *   **I/O 请求**：虚拟机要读写硬盘、网络等模拟设备。
    *   **访问特权状态**：如修改 CR3 寄存器（页表基址）。
    *   **外部中断**：宿主机上发生了需要处理的事件。
4.  KVM 处理这次退出。如果是 I/O 请求，它会将控制权交还给用户空间的 QEMU，由 QEMU 来模拟这个硬件设备操作（例如，将数据写入一个镜像文件）。处理完毕后，再次通过 `KVM_RUN` 让 vCPU 重新进入非根模式继续执行。

### 原理示意图与类比

```
+---------------------------------------------------------------+
|                用户空间                                       |
|  +-------------------+          +-----------------------+    |
|  |      QEMU进程     |<---ioctl--|   虚拟机监控器(VMM)   |    |
|  | (模拟I/O设备)     |---------->|   (例如：libvirt)     |    |
|  +-------------------+          +-----------------------+    |
+---------------------------------------------------------------+
                                | 通过 /dev/kvm 接口
+---------------------------------------------------------------+
|                Linux 内核 (作为 Hypervisor)                   |
|  +---------------------------------------------------------+  |
|  | vCPU线程 (客户机内核态) | vCPU线程 (客户机用户态) | ... |  |
|  +---------------------------------------------------------+  |
|  |                  KVM 内核模块                            |  |
|  |              (处理VMX切换、内存虚拟化)                   |  |
|  +---------------------------------------------------------+  |
+---------------------------------------------------------------+
|                   硬件 (CPU, 内存, I/O)                      |
|  CPU: Intel VT-x / AMD-V                                     |
+---------------------------------------------------------------+
```

**一个绝佳的类比：**

你可以把 **KVM 看作一个“超级进程调度器”**。
*   **普通的 Linux 内核**：调度和管理的是 **进程**（如 Firefox, Apache）。每个进程有自己的虚拟地址空间。
*   **开启了 KVM 的 Linux 内核**：调度和管理的是 **虚拟机**。每个虚拟机被当做一个或多个进程（vCPU 线程），而这些“超级进程”内部运行着完整的、拥有自己内核的操作系统。

### 总结

KVM 的运行原理精髓在于：

1.  **内核集成**：作为内核模块，直接利用内核的调度器、内存管理等核心功能，无需重复造轮子。
2.  **硬件加速**：依赖 CPU 的 VT-x/AMD-V 技术，让虚拟机指令直接运行在物理 CPU 上，性能极高。
3.  **进程抽象**：将虚拟机的 vCPU 映射为宿主机的线程，内存映射到进程地址空间，使得虚拟机的管理变得和进程管理一样简单、高效、自然。
4.  **职责分离**：KVM 只负责最核心的 CPU 虚拟化和内存虚拟化，而将复杂的 I/O 设备模拟交给成熟且功能丰富的用户空间程序（如 QEMU）处理。

这种架构使得 KVM 既高效又灵活，成为现代云计算基础设施的基石。



## KVM和QEMU的关系

KVM 和 QEMU 的关系经常被混淆，但它们组合起来构成了一个强大且高效的虚拟化解决方案。

我们可以用一个简单的比喻来开始：

**把虚拟化看作运行一台游戏机（比如 PlayStation）：**
*   **QEMU** 就像是那个**功能齐全的游戏机模拟器软件**。它能模拟整个游戏机的硬件环境（CPU、内存、手柄、显卡等），让你能在电脑上玩主机游戏。但纯粹的软件模拟速度很慢，因为每条指令都需要被翻译和模拟。
*   **KVM** 就像是给你的电脑加装了一个**专用的游戏机协处理器**。这个协处理器能直接理解并执行游戏机的原生指令，让游戏能以接近原生的速度运行。
*   **QEMU-KVM** 就是让这个“模拟器软件”（QEMU）去调用“协处理器”（KVM）来运行游戏。模拟器负责处理图像、声音和手柄输入，而最核心的游戏运算则交给硬件直接执行。

---

### 它们各自的核心职责

#### QEMU：硬件模拟器

*   **是什么？** 一个通用的、开源的机器模拟器和虚拟化器。
*   **主要工作**：
    1.  **设备模拟**：模拟一整套完整的虚拟硬件，包括网卡（e1000、virtio-net）、硬盘控制器（IDE、SATA、virtio-blk）、显卡（VGA、QXL）、USB控制器、BIOS等。虚拟机看到的所有硬件都是 QEMU 模拟出来的。
    2.  **生命周期管理**：负责虚拟机的创建、配置、暂停、继续、关闭等整个生命周期的管理。
    3.  **最初的模式（无KVM）**：在没有 KVM 的情况下，QEMU 使用一种叫做“二进制翻译”的技术来模拟 CPU。它会把客户机操作系统的代码（如 x86 指令）动态地翻译成本地代码执行。这种方式功能完整，但**速度非常慢**，因为每条指令都要经过翻译。

#### KVM：Linux 内核的虚拟化基础设施

*   **是什么？** 一个开源的 **Linux 内核模块**。
*   **主要工作**：
    1.  **CPU 虚拟化**：利用 Intel VT-x 或 AMD-V 等 CPU 硬件虚拟化扩展，让虚拟机的代码能**直接运行在物理 CPU 上**。这解决了 CPU 指令模拟的性能瓶颈，使虚拟机性能达到近乎原生速度。
    2.  **内存虚拟化**：使用影子页表或更先进的扩展页表（EPT）/快速虚拟化索引（RVI）技术，高效地管理虚拟机的内存访问。
    3.  **不模拟硬件**：KVM **本身不模拟任何 I/O 硬件**（如网卡、硬盘）。它只负责最核心的 CPU 和内存虚拟化。

---

### 它们如何协同工作？（QEMU-KVM）

这才是关键。QEMU 和 KVM 结合后，各自发挥长处，形成了“强强联合”的架构。

1.  **分工合作**：
    *   **KVM 负责“快”的部分**：处理虚拟机的核心指令（CPU 运算和内存访问）。因为它直接使用硬件，所以极快。
    *   **QEMU 负责“全”的部分**：模拟各种 I/O 设备（硬盘、网络、显卡等）。因为它用软件模拟，所以较慢，但功能完整。

2.  **工作流程**：
    *   用户使用 `libvirt`（管理工具）或命令行启动 QEMU，并指定 `-enable-kvm` 参数。
    *   QEMU 调用 KVM 提供的 `/dev/kvm` 接口，将虚拟机的 vCPU 交给 KVM 模块。
    *   KVM 在硬件辅助下，让 vCPU 的代码直接在全速运行。
    *   当虚拟机需要进行 I/O 操作时（例如，向虚拟硬盘写入数据），会发生一次 **VM Exit**。CPU 会从非根模式切换到根模式，将控制权交还给 KVM，KVM 再通知 QEMU。
    *   QEMU 模拟这个写硬盘的操作，将数据写入到主机上的一个镜像文件（如 `vm_disk.qcow2`）中。
    *   操作完成后，QEMU 通知 KVM，KVM 再通过 **VM Entry** 让虚拟机继续运行。

### 关系总结表

| 特性         | QEMU                            | KVM                                 | 组合（QEMU-KVM）         |
| :----------- | :------------------------------ | :---------------------------------- | :----------------------- |
| **核心功能** | 机器**模拟器**，设备模拟        | 内核**虚拟化**模块，CPU/内存加速    | 完整的**虚拟化**解决方案 |
| **性能**     | 纯软件模拟，**慢**              | 硬件加速，**极快**                  | **接近原生性能**         |
| **职责**     | 模拟I/O设备，管理虚拟机生命周期 | 加速CPU和内存指令                   | QEMU处理I/O，KVM处理运算 |
| **依赖关系** | 可独立运行，无需KVM             | **必须**与QEMU等修改后的VMM协同工作 | QEMU调用KVM接口          |
| **类比**     | 游戏模拟器软件                  | 硬件协处理器                        | “带了硬件加速的模拟器”   |

### 结论

**KVM 不是独立的 Hypervisor，而是一个让 QEMU 变成高效 Hypervisor 的“性能加速器”。**

简单来说：
*   **QEMU 自己**：是一个完整的、但速度很慢的模拟器。
*   **QEMU + KVM**：是一个性能极高、功能完整的虚拟化平台。我们现在提到在 Linux 上使用 KVM，本质上指的就是使用 **QEMU-KVM** 这个组合。常见的虚拟化管理工具（如 `virt-manager`）和云平台（如 OpenStack）底层使用的都是这个黄金组合。



## libvirt概念

### 一句话概括

**Libvirt 是一个为了更方便、更统一地管理各种虚拟化技术（如 KVM、Xen、VMware 等）而设计的开源 API、守护进程和管理工具集。它本身不是一个虚拟化技术，而是一个“虚拟化管理层”或“抽象层”。**

---

### 核心概念：解决什么问题？

想象一下，如果你直接使用 QEMU-KVM 命令行来创建和管理虚拟机，命令可能会非常复杂，例如：

```bash
qemu-system-x86_64 -enable-kvm -name guest=vm1 -m 2048 -cpu host ...
```

这种方式存在几个问题：
1.  **命令复杂**：参数又多又长，难以记忆和书写。
2.  **难以持久化**：命令行创建的虚拟机，退出后管理不便。
3.  **缺乏高级功能**：难以轻松实现复杂的网络配置、存储池、快照、迁移等功能。
4.  **异构环境管理困难**：如果你同时有 KVM 和 Xen 的虚拟机，你需要学习两套完全不同的管理工具。

**Libvirt 就是为了解决这些问题而生的。** 它的目标是提供一个**稳定、通用、高级的 API**，让用户和程序可以通过同一种方式来管理不同的虚拟化方案。

---

### Libvirt 的组成部分

Libvirt 不是一个单一的软件，而是一个完整的生态系统，主要包括：

#### 1. **Libvirt API 库**
*   这是最核心的部分。它是一套用 C 语言编写的、功能丰富的**编程接口**。
*   这些 API 抽象了底层不同 Hypervisor（KVM, Xen, VMware ESX, Microsoft Hyper-V, VirtualBox 等）的差异。开发者只需要调用统一的 libvirt API，libvirt 就会将其翻译成底层具体 Hypervisor 能理解的指令。
*   支持多种语言绑定（如 Python, Java, Go, Ruby 等），使得用这些语言开发管理工具变得非常容易。

#### 2. **Libvirt Daemon（守护进程）：`libvirtd`**
*   这是一个运行在主机上的后台服务进程。
*   它是管理的核心，负责接收 API 调用请求（可以是本地的，也可以是远程的），然后与实际的 Hypervisor 进行交互来执行操作（如创建、启动、停止虚拟机）。
*   它维护着虚拟机配置和状态的“真相源”。

#### 3. **管理工具（命令行与图形界面）**
这是用户最常接触的部分，它们都是通过调用 libvirt API 来实现功能的。

*   **`virsh`**：**最强大、最常用的命令行管理工具**。它功能极其丰富，可以完成几乎所有虚拟化管理任务，非常适合自动化和服务器环境。
    *   示例命令：`virsh list --all`（列出所有虚拟机），`virsh start my_vm`（启动虚拟机），`virsh edit my_vm`（编辑虚拟机配置）。

*   **`virt-manager`（Virtual Machine Manager）**：**一个直观的图形界面管理工具**。非常适合桌面用户或初学者，可以像使用 VMware Workstation 一样通过点击来管理虚拟机。

*   **`virt-viewer`**： 一个轻量级的图形控制台，用于连接到虚拟机的桌面。

#### 4. **虚拟机配置文件（XML）**
Libvirt 使用 **XML 文件**来定义虚拟机的所有配置。这是一种非常清晰和强大的方式。

*   **位置**：通常位于 `/etc/libvirt/qemu/` 目录下，每个虚拟机一个 `.xml` 文件（如 `my_vm.xml`）。
*   **内容**：XML 文件描述了虚拟机的方方面面：CPU数量、内存大小、磁盘镜像路径、网络配置、显卡设置等。
*   **好处**：配置是声明式的，易于版本控制（如用 Git 管理）、备份和复制。你可以通过修改一个 XML 模板，快速克隆出多台相似的虚拟机。

---

### Libvirt 的架构与工作流程

下图清晰地展示了 Libvirt 在整个虚拟化栈中的位置和作用：

```
+-------------------------------------------------------+
|                管理工具层                              |
|  +-----------+    +-------------+    +-------------+  |
|  | virt-     |    |  OpenStack  |    |  oVirt/     |  |
|  | manager   |    |  (Nova)     |    |  CloudStack |  |  --> 调用 Libvirt API
|  | (GUI)     |    |             |    |             |  |
|  +-----------+    +-------------+    +-------------+  |
+-------------------------------------------------------+
                            |
+-------------------------------------------------------+
|                 Libvirt 抽象层                         |
|  +--------------------------------------------------+ |
|  |               libvirtd 守护进程                   | |  --> 统一的管理接口
|  |    (将API请求转换为特定Hypervisor的指令)           | |
|  +--------------------------------------------------+ |
+-------------------------------------------------------+
                            |
+-------------------------------------------------------+
|                虚拟化驱动层                            |
|  +-----------+  +--------+  +----------+  +--------+  |
|  |   QEMU/   |  |  Xen   |  | VMware   |  |  LXC   |  |  --> 连接不同的虚拟化技术
|  |   KVM     |  | Driver |  | ESX      |  |Driver  |  |
|  |  Driver   |  |        |  | Driver   |  |        |  |
|  +-----------+  +--------+  +----------+  +--------+  |
+-------------------------------------------------------+
                            |
+-------------------------------------------------------+
|                底层虚拟化平台                          |
|  +-----------+  +--------+  +----------+  +--------+  |
|  |   KVM     |  |  Xen   |  | VMware   |  |  LXC   |  |
|  | Hypervisor|  |Hyper-  |  | ESXi     |  |Contain.|  |
|  |           |  | visor  |  |          |  |        |  |
|  +-----------+  +--------+  +----------+  +--------+  |
+-------------------------------------------------------+
```

**工作流程举例（通过 `virt-manager` 启动一个虚拟机）：**
1.  你在 `virt-manager` 界面上点击“启动虚拟机”。
2.  `virt-manager` 通过 libvirt 的 API（如 Python 绑定）发送“启动”请求。
3.  请求被本地的 `libvirtd` 守护进程接收。
4.  `libvirtd` 根据虚拟机配置（XML），判断底层驱动是 KVM。
5.  `libvirtd` 调用 `qemu-kvm` 命令行工具，并传递所有必要的参数。
6.  QEMU-KVM 进程启动，虚拟机开始运行。
7.  `libvirtd` 记录虚拟机的状态为“运行中”。

---

### 总结：Libvirt 的角色与价值

| 特性           | 解释                                         | 价值                                                         |
| :------------- | :------------------------------------------- | :----------------------------------------------------------- |
| **抽象层**     | 统一了不同 Hypervisor 的管理接口。           | 管理员只需学习一套工具（如 `virsh`）即可管理 KVM、Xen 等多种虚拟化平台。 |
| **管理框架**   | 提供了守护进程、API、CLI、GUI 等一整套工具。 | 极大地简化了虚拟机的生命周期管理、网络配置、存储管理、迁移、快照等高级操作。 |
| **自动化友好** | 稳定的 API 和基于文本的 XML 配置。           | 非常适合与 Ansible、Puppet 等自动化工具集成，也是 OpenStack、oVirt 等云平台的基础。 |
| **生态系统**   | 是 Linux 上事实标准的虚拟化管理工具集。      | 拥有广泛的社区支持和兼容性。                                 |

**简单来说，如果你把 KVM/QEMU 看作是汽车的引擎和底盘（提供核心动力），那么 Libvirt 就是汽车的仪表盘、方向盘和油门踏板（提供人性化的控制和交互界面）。** 普通用户通过 Libvirt 来方便地“驾驶”KVM 这辆高性能跑车。



## virsh概念

### 一句话概括

**`virsh` 是一个功能强大、基于命令行的 Linux 虚拟化管理工具，它是 libvirt 项目的一部分，用于管理使用 libvirt API 的虚拟机（如 KVM、Xen 等）。你可以把它看作是对虚拟化环境的“命令行控制中心”。**

---

### 核心概念：它扮演的角色

为了更好地理解，我们可以做一个类比：

*   **虚拟机（VM）** 就像是一台**独立的物理服务器**。
*   **`virsh`** 就像是机房里的**智能远程管理卡（iDRAC/iLO）** 或 **KVM over IP 切换器**。
    *   你不需要显示器和键盘直接接在服务器上。
    *   通过一个统一的命令行界面，你就可以远程**启动**、**关闭**、**重启**服务器，**查看**其状态，甚至**配置**其硬件（如虚拟的CPU、内存、磁盘）。

简单来说，`virsh` 让你能够通过命令行完成所有在图形化工具（如 `virt-manager`）中能做的操作，甚至更多，尤其适合在无图形界面的服务器上或进行自动化脚本编写。

---

### `virsh` 的主要特点和能力

1.  **命令行驱动**：专为服务器环境和系统管理员设计，无需图形界面即可通过 SSH 进行操作。
2.  **功能全面**：涵盖了虚拟机生命周期的所有方面：
    *   **生命周期管理**：创建、启动、关闭、重启、暂停、恢复、保存状态、恢复状态、销毁虚拟机。
    *   **信息查询**：列出所有虚拟机、查看虚拟机详细信息、监控虚拟机的 CPU 和内存使用情况。
    *   **配置管理**：编辑虚拟机配置、动态附加/卸载虚拟设备（如磁盘、网卡）。
    *   **高级操作**：创建快照、克隆虚拟机、迁移虚拟机（从一台物理主机迁移到另一台）。
    *   **管理虚拟网络和存储**：不仅管理虚拟机，还能管理其依赖的网络和存储池。
3.  **自动化友好**：可以轻松嵌入到 Shell 脚本中，实现虚拟化环境的自动化运维。
4.  **两种工作模式**：
    *   **交互模式**：在终端输入 `virsh` 回车，会进入一个 `virsh>` 提示符的交互式环境，可以连续输入命令。
    *   **非交互模式**：直接在 Shell 提示符下将命令作为 `virsh` 的参数执行，例如 `virsh list --all`。

---

### 常用 `virsh` 命令示例

以下是一些最常用、最基础的 `virsh` 命令，它们构成了日常管理的基础。

#### 1. 查看虚拟机列表和状态
这是最常用的命令，用于查看虚拟机的当前状态。

```bash
# 列出所有正在运行的虚拟机
virsh list

# 列出所有虚拟机（包括已关闭的）
virsh list --all
```
**输出示例：**
```
 Id   Name       State
-------------------------------
 1    web-server running
 2    db-server  running
 -    test-vm    shut off
```

#### 2. 虚拟机的生命周期管理
```bash
# 启动一个已定义但已关闭的虚拟机
virsh start vm_name

# 优雅地关闭虚拟机（需要虚拟机内安装并运行了 ACPI 服务，如 VMware Tools）
virsh shutdown vm_name

# 强制关闭虚拟机（相当于直接拔电源，不安全，仅在必要时使用）
virsh destroy vm_name

# 重启虚拟机
virsh reboot vm_name

# 暂停虚拟机（将其置于暂停状态，内存保存在 RAM 中）
virsh suspend vm_name

# 恢复被暂停的虚拟机
virsh resume vm_name
```

#### 3. 虚拟机信息查询
```bash
# 显示虚拟机的详细信息（CPU、内存、磁盘、网络等配置）
virsh dominfo vm_name

# 以 XML 格式显示虚拟机的完整配置（这是最详细的视图）
virsh dumpxml vm_name

# 查看虚拟机的控制台日志
virsh console vm_name
```

#### 4. 编辑虚拟机配置
这是一个非常重要的功能。它不会直接修改运行中的虚拟机，而是先关机，然后修改其持久化配置。
```bash
# 编辑虚拟机的 XML 配置文件（例如，增加内存或CPU）
virsh edit vm_name
```
执行此命令后，会使用 `$EDITOR` 环境变量指定的编辑器（默认为 `vi`）打开 XML 文件，修改保存后，libvirt 会验证配置的合法性。

#### 5. 快照管理
快照可以保存虚拟机在某个时间点的完整状态，用于备份或测试。
```bash
# 为虚拟机创建一个快照
virsh snapshot-create-as --domain vm_name --name snapshot1

# 列出虚拟机的所有快照
virsh snapshot-list vm_name

# 将虚拟机恢复到某个快照
virsh snapshot-revert --domain vm_name --snapshotname snapshot1

# 删除一个快照
virsh snapshot-delete --domain vm_name --snapshotname snapshot1
```

---

### `virsh` 在 libvirt 架构中的位置

回顾一下 libvirt 的架构，`virsh` 的位置非常清晰：

```
+-----------------------------------+
|           管理工具层               |
|  +------------------------------+ |
|  |        virt-manager (GUI)     | |
|  +------------------------------+ |
|  +------------------------------+ |
|  |         virsh (CLI)           | |  <-- virsh 在这里
|  +------------------------------+ |
|  +------------------------------+ |
|  |       其他程序/自动化脚本       | |
|  +------------------------------+ |
+-------------------|----------------+
                    | (调用 libvirt API)
+-----------------------------------+
|           libvirtd 守护进程        |
+-----------------------------------+
                    |
+-----------------------------------+
|        底层虚拟化驱动 (KVM)        |
+-----------------------------------+
```

**总结一下**：

`virsh` 是 **libvirt 项目提供的命令行管理工具**，是 Linux 系统上管理和操控 KVM 等虚拟机的**标准且强大的命令行接口**。对于服务器管理员和追求自动化效率的用户来说，掌握 `virsh` 是进行高效虚拟化运维的必备技能。



## virt-manager概念

### 一句话概括

**`virt-manager` 是一个基于图形界面的、用于管理 Linux 虚拟机的桌面应用程序。它是 libvirt 项目的官方前端工具，让你能够像使用 VMware Workstation 或 VirtualBox 一样，通过点击鼠标来轻松创建、配置和管理 KVM 等虚拟机。**

简单来说，**它是 KVM 虚拟化的“图形化控制面板”**。

---

### 核心定位：为谁设计？

*   **目标用户**：桌面用户、初学者、以及任何喜欢图形化操作而非命令行管理的系统管理员。
*   **解决的问题**：虽然 `virsh` 命令行功能强大，但对于日常使用（如快速创建一个测试虚拟机）或初学者来说，记忆复杂的命令和参数门槛较高。`virt-manager` 提供了直观的点击操作界面，极大地降低了使用难度。

---

### virt-manager 的主要功能和特点

#### 1. **直观的虚拟机生命周期管理**
你可以通过清晰的按钮完成虚拟机的整个生命周期操作：
*   **创建**：通过向导一步步创建新虚拟机。
*   **启动**：点击“播放”按钮。
*   **关闭**：点击“关机”按钮（优雅关闭）或“强制关机”按钮（相当于断电）。
*   **暂停/恢复**：暂停虚拟机运行或恢复运行。
*   **重启**：重启虚拟机。



#### 2. **内置的图形化控制台（核心优势）**
这是 `virt-manager` 的一个杀手级功能。它内置了一个 VNC/SPICE 客户端，可以直接在管理窗口中显示虚拟机的桌面。你不需要额外安装 VNC 客户端（如 RealVNC、TigerVNC）来连接虚拟机，管理体验非常一体化。



#### 3. **实时的性能监控**
主窗口会以曲线图的形式实时显示每个虚拟机的 **CPU 使用率**、**内存使用量**和**磁盘/网络 I/O**，让你对虚拟机的运行状态一目了然。



#### 4. **硬件配置的图形化编辑**
你可以通过点击“虚拟硬件详情”来轻松修改虚拟机的配置，而无需手动编辑复杂的 XML 文件：
*   **CPU 和内存**：动态调整虚拟 CPU 数量和内存大小（对于支持热插拔的客操作系统）。
*   **磁盘**：添加或移除虚拟磁盘，调整磁盘总线类型（如使用性能更好的 `virtio`）。
*   **网络**：添加网卡，并连接到不同的虚拟网络（如 NAT 网络或桥接网络）。
*   **其他设备**：添加 CD-ROM 镜像、USB 设备、显卡等。



#### 5. **快照管理**
可以方便地为虚拟机创建快照（保存某一时间点的完整状态），并可以在需要时快速恢复到某个快照。这对于软件测试和系统恢复非常有用。

#### 6. **支持本地和远程管理**
`virt-manager` 不仅可以管理本机的虚拟机，还可以通过 SSH 或 TLS 等协议连接到远程的 libvirt 守护进程，从而管理其他物理服务器上的虚拟机。

---

### virt-manager 在 libvirt 架构中的位置

理解它在整个技术栈中的位置，能让你更清楚它的角色：

```
+-----------------------------------------+
|             用户交互层                   |
|  +------------------------------------+ |
|  |        virt-manager (GUI)          | |  <-- 用户通过它进行点击操作
|  +------------------------------------+ |
|  +------------------------------------+ |
|  |           virsh (CLI)              | |
|  +------------------------------------+ |
+-------------------|----------------------+
                    | (调用 libvirt API)
+-----------------------------------------+
|             libvirt 抽象层              |
|  +------------------------------------+ |
|  |           libvirtd 守护进程         | |  <-- 接收指令，与底层交互
|  +------------------------------------+ |
+-------------------|----------------------+
                    |
+-----------------------------------------+
|            虚拟化驱动层                 |
|  +------------------------------------+ |
|  |          QEMU/KVM 驱动             | |  <-- 实际启动和管理 QEMU-KVM 进程
|  +------------------------------------+ |
+-------------------|----------------------+
                    |
+-----------------------------------------+
|               底层硬件                  |
|  +------------------------------------+ |
|  |         KVM (CPU/Memory)          | |
|  +------------------------------------+ |
+-----------------------------------------+
```

**工作流程举例（启动虚拟机）：**
1.  你在 `virt-manager` 界面上双击一个虚拟机的图标。
2.  `virt-manager` 通过 libvirt 的 API 向本地的 `libvirtd` 守护进程发送“启动”请求。
3.  `libvirtd` 调用 QEMU-KVM 驱动。
4.  QEMU-KVM 进程被启动，虚拟机开始运行。
5.  `libvirtd` 启动一个内置的 VNC 服务器来显示虚拟机的桌面。
6.  `virt-manager` 连接到这个 VNC 服务器，并将虚拟机的桌面显示在它的内置窗口中。

---

### 与 `virsh` 的对比

| 特性         | virt-manager (GUI)               | virsh (CLI)                              |
| :----------- | :------------------------------- | :--------------------------------------- |
| **界面**     | 图形化界面，点击操作             | 命令行，文本输入                         |
| **易用性**   | **非常高**，适合初学者和桌面用户 | **有学习曲线**，需要记忆命令             |
| **功能**     | 覆盖大部分日常管理功能           | **功能最全**，包括所有高级功能           |
| **自动化**   | 难以自动化                       | **非常适合自动化**，可编写脚本           |
| **适用场景** | 桌面环境、快速创建和测试         | 无图形界面的服务器、自动化运维、批量管理 |

### 总结

**`virt-manager` 是 KVM/libvirt 虚拟化栈的“面子”，而 `virsh` 和 libvirt 是“里子”。**

*   对于想要在 Linux 桌面上轻松使用虚拟机，进行开发、测试或学习的用户来说，**`virt-manager` 是官方推荐且最佳的选择**。它提供了开箱即用的流畅体验。
*   对于专业的系统管理员，他们可能会在桌面上用 `virt-manager` 进行快速检查和管理，而在自动化脚本和服务器维护中大量使用 `virsh`。

两者并非替代关系，而是相辅相成，共同构成了完整的 Linux 虚拟化管理解决方案。



## virt-viewer概念

### 一句话概括

**`virt-viewer` 是一个轻量级、功能专一的开源工具，它的唯一用途就是提供一个高质量、高性能的图形化界面来连接并显示虚拟机的桌面。它本身不管理虚拟机，只负责“查看”。**

你可以把它看作是一个**专门为 KVM/QEMU 虚拟机优化的“远程桌面客户端”**，类似于 VNC Viewer 或 Microsoft Remote Desktop，但它与 libvirt 和 QEMU 原生协议集成得更好。

---

### 核心概念：解决什么问题？

虽然 `virt-manager` 也内置了一个查看器，但 `virt-viewer` 的存在解决了更特定的需求：

1.  **专注性与轻量级**：`virt-manager` 是一个功能全面的管理控制台，而 `virt-viewer` 只做一件事——显示桌面。因此它更小巧、启动更快、资源占用更少。
2.  **更好的协议支持与性能**：它针对 QEMU 的本地和远程连接协议（如 SPICE 和 VNC）进行了深度优化，通常能提供比通用 VNC 客户端更好的体验，尤其是在图形渲染、音频传输和 USB 重定向方面。
3.  **独立使用**：你可以在一个简单的终端里，只通过一条命令就连接到虚拟机的桌面，而不需要启动整个庞大的 `virt-manager` 界面。
4.  **自动化集成**：在脚本或自动化流程中，你可以直接调用 `virt-viewer` 来打开某个虚拟机的控制台。

---

### `virt-viewer` 的主要特点和优势

| 特性                 | 说明                                                         |
| :------------------- | :----------------------------------------------------------- |
| **专一性**           | 只负责显示虚拟机桌面，不提供创建、开关机等管理功能。         |
| **高性能**           | 对 SPICE 协议有极佳的支持，提供流畅的图形体验、动态分辨率调整、音频和 USB 透传。 |
| **轻量级**           | 应用程序本身非常小巧，启动迅速。                             |
| **简单易用**         | 通常只需一条命令即可连接。                                   |
| **支持多种连接方式** | 支持直接通过 libvirt 连接，也支持传统的 URI 连接（如 `spice://...`, `vnc://...`）。 |

---

### 如何使用 `virt-viewer`？

#### 方法一：通过虚拟机名称连接（最常用、最简单）

这是最直接的方式，前提是你的会话有权限访问 libvirt。

```bash
# 连接到名为 "ubuntu-desktop-vm" 的虚拟机的控制台
virt-viewer ubuntu-desktop-vm

# 连接时自动全屏显示
virt-viewer --full-screen ubuntu-desktop-vm

# 以只读模式连接（无法通过鼠标键盘与虚拟机交互）
virt-viewer --connect qemu:///system --read-only ubuntu-desktop-vm
```

#### 方法二：通过传统 URI 连接

如果你知道虚拟机的具体图形显示地址和端口，也可以直接连接。

```bash
# 连接到本机 5900 端口的 VNC 服务（通常是第一个虚拟机的默认端口）
virt-viewer vnc://localhost:5900

# 连接到远程服务器（192.168.1.100）上使用 SPICE 协议的虚拟机（端口通常为 5900）
virt-viewer spice://192.168.1.100:5900
```

---

### `virt-viewer` 与相关工具的关系

为了更好地理解它的定位，我们将其与 `virt-manager` 和 `virsh` 进行对比。

#### 1. `virt-viewer` vs `virt-manager` 的内置查看器

*   `virt-manager` 的内置查看器是其整体功能的一部分，方便在管理虚拟机时直接查看桌面。
*   `virt-viewer` 是一个独立的、更专业的工具。它的优势在于：
    *   **功能更丰富**：通常提供更多连接选项和显示设置。
    *   **更新更及时**：对 SPICE 等新特性的支持可能更快。
    *   **独立进程**：如果 `virt-manager` 主程序卡死或崩溃，查看器会话可能不会受影响。

**关系**：你可以把 `virt-viewer` 看作是 `virt-manager` 内置查看器的一个“专业独立版”。

#### 2. `virt-viewer` vs `virsh console`

这是一个非常重要的区别！

| 工具                | 连接的界面                                                   | 用途                                                         |
| :------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`virt-viewer`**   | 虚拟机的**图形化桌面**（Windows 的 GUI，Linux 的 GNOME/KDE 等） | 运行图形化应用程序，需要完整的桌面体验。                     |
| **`virsh console`** | 虚拟机的**文本控制台**（类似于物理服务器的串口）             | 进行系统命令行管理、修复无法启动的系统、在无图形界面（如服务器版）的系统中工作。 |

*   `virsh console` 需要先在虚拟机内部配置好串行控制台才能正常工作。
*   对于服务器版 Linux 或无图形界面的虚拟机，`virsh console` 是主要的管理方式。

---

### 总结：`virt-viewer` 的角色

我们可以将整个 libvirt 管理工具栈类比为一个现代化的数据中心：

| 工具               | 类比                                  | 职责                                                         |
| :----------------- | :------------------------------------ | :----------------------------------------------------------- |
| **`virt-manager`** | **数据中心的中央控制室**              | 拥有大屏幕总览所有服务器，并能进行所有操作（开机、关机、配置）。 |
| **`virsh`**        | **控制室的命令行终端和自动化脚本**    | 功能最强大，适合批量、自动化、精确的控制。                   |
| **`virt-viewer`**  | **接在每台服务器上的专属 KVM 显示器** | 功能单一：就是让你清晰地看到某台特定服务器的屏幕内容。       |

**因此，当你的需求很简单——“我想看看我那台 Windows 虚拟机或者带桌面的 Linux 虚拟机里面是什么样子”时，`virt-viewer` 通常是最直接、最快速、体验最好的选择。**



## 查看CPU是否支持硬件虚拟化

 检查当前服务器的 CPU 是否支持硬件虚拟化功能，以及是否在 BIOS 中启用了该功能。这是使用 KVM 虚拟化的前提条件。

```sh
# 有输出表示支持，没有输出表示不支持
cat /proc/cpuinfo | grep -E "vmx|svm"
```

命令解释：

- cat /proc/cpuinfo： 显示 Linux 系统中关于 CPU 的详细信息，包括型号、主频、缓存以及支持的特性（flags）。
- grep -E "vmx|svm"： 使用 grep工具在 cpuinfo的输出中进行正则表达式搜索，查找包含 vmx或svm的行。-E选项表示启用扩展的正则表达式。
- vmx： 代表 Intel VT-x技术。如果你的 CPU 是 Intel 的，并且支持并开启了硬件虚拟化，你就能看到这个标志。
- 代表 AMD-V技术。如果你的 CPU 是 AMD 的，并且支持并开启了硬件虚拟化，你就能看到这个标志。



## 安装

### Ubuntu

步骤如下：

1. 启用CPU硬件虚拟化。

2. 安装KVM软件包

   ```sh
   sudo apt install -y qemu-kvm virt-manager virt-viewer libvirt-daemon-system libvirt-clients bridge-utils
   ```

   软件包说明：

   - qemu-kvm: QEMU 模拟器与 KVM 加速后端。
   - virt-manager: 用于管理虚拟机的图形化界面（GUI）。
   - virt-viewer: 用于连接虚拟机桌面的轻量级查看器。
   - libvirt-daemon-system: 提供 libvirtd守护进程，用于管理虚拟化平台。
   - libvirt-clients: 提供 virsh等命令行客户端工具。
   - bridge-utils: 用于配置网络桥接的工具（可选，但推荐安装以便使用桥接网络）。

3. 启动并设置 Libvirt 守护进程开机自启

   启动服务

   ```sh
   sudo systemctl start libvirtd
   ```

   设置开机自启

   ```sh
   sudo systemctl enable libvirtd
   ```

   检查服务状态

   ```sh
   sudo systemctl status libvirtd
   ```

4. 安装swtpm

   >说明：在安装Windows11时需要安全固件TPM2.0支持，否则会报告“Error starting domain: Unable to find 'swtpm' binary in $PATH: No such file or directory”错误。

   ```sh
   sudo add-apt-repository ppa:stefanberger/swtpm-focal
   sudo apt update
   sudo apt install swtpm swtpm-tools
   ```

5. 将用户添加到 libvirt 组

   >说明：默认情况下，只有 root 用户和 libvirt组内的用户有权管理虚拟机。为了避免每次使用 virt-manager或 virsh时都要加 sudo，请将你的当前用户添加到 libvirt组。

   ```sh
   sudo usermod -aG libvirt $USER
   ```

   重新启动系统，才能使组权限生效。

6. 验证 KVM 是否已正确安装并可用

   检查 KVM 模块是否加载

   ```sh
   # 如果输出包含 kvm_intel或 kvm_amd以及 kvm，则表示模块已成功加载。
   lsmod | grep kvm
   ```

   检查 libvirt 连接状态

   ```sh
   # 如果一切正常，这个命令会列出所有虚拟机（目前是空的），而不会报错。
   virsh list --all
   ```



## 安装客户机系统

### Ubuntu20.04.3

>注意：不能使用XRDP登录系统使用virt-manager创建虚拟机，否则会报告错误导致无法创建虚拟机。

上传ubuntu iso镜像到宿主机中，启动virt-manager图形化界面创建虚拟机。客户端机操作系统安装根据提示安装即可。



### Windows11

上传Win11_23H2_Chinese_Simplified_x64v2.iso镜像到宿主机中，启动virt-manager图形化界面准备创建Windows11。

在virt-manager中点击创建虚拟机，选择本地iso镜像，勾选`Automatically detect from the installation media/source`，点击`Forward`按钮。

内存8192MB，CPU 4核心，点击`Forward`按钮。

存储硬盘根据需要填写大小，点击`Forward`按钮。

虚拟机名称填写windows11，勾选`Customize configuration before install`，网络选择Virtual network 'default': NAT，点击`Finish`按钮。

在弹出配置对话框中导航到Overview，Chipset选择Q35，Firmware选择UEFI x86_64: /usr/share/OVMF/OVMF_CODE_4M.secboot.fd。

点击`Add Hardware`按钮添加安全固件TPM2.0，Model选择CRB，Backend选择Emulated device，Version选择2.0，点击`Finish`按钮。

点击`Apply`按钮应用修改，再点击`Begin Installation`按钮开始安装Windows11。

在安装完Windows11后初始系统配置前，关闭客户机系统并删除网卡以断网

>参考链接：https://www.cnblogs.com/dream-myself/articles/18932554

在网络连接设置向导界面中`下一步`按钮是禁用状态导致无法进行下一步，此时使用Shfit+F10按键调出命令行并输入下面命令

```
OOBE\BypassNRO.cmd
```

等待客户机系统重启后再重新初始配置即可完成客户机系统配置。