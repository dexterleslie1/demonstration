## `CircuitBreaker`

SpringCloud CircuitBreaker是Spring Cloud提供的一个用于处理分布式系统中服务调用的容错机制。以下是对SpringCloud CircuitBreaker的详细介绍：

**一、概述**

SpringCloud CircuitBreaker提供了一个跨越不同断路器实现的抽象，允许开发者选择最适合自己应用程序需求的断路器实现。它支持多种断路器实现，如Resilience4j、Hystrix等。其中，Resilience4j是Spring Cloud官方推荐的断路器实现，它是一个轻量级的容错库，专为Java 8及更高版本设计。

**二、主要功能**

1. **熔断**：当某个服务的错误率达到一定的阈值时，断路器会迅速切换到打开状态，阻止新的请求继续访问该服务，从而防止系统资源的过度消耗和级联失败的发生。
2. **自动恢复**：经过一段时间后，断路器会自动从打开状态切换到半开状态，允许部分请求通过以测试服务是否恢复正常。如果测试请求成功，断路器会关闭；否则，会重新打开。
3. **监控和报警**：SpringCloud CircuitBreaker提供了实时监控和报警功能，可以实时监控断路器的状态、请求成功率、失败率等指标，并在异常情况下发送报警信息。

**三、核心组件**

1. **断路器实例**：每个断路器实例都对应一个具体的服务调用。开发者可以通过配置断路器实例的属性来控制熔断器的行为，如失败率阈值、打开状态下的等待时间等。
2. **熔断器状态**：断路器具有三种普通状态（关闭、打开、半开）和两个特殊状态（禁用和强制打开）。这些状态之间的转换取决于服务的调用情况和配置的策略。

**四、配置与使用**

1. **引入依赖**：在项目的pom.xml文件中引入SpringCloud CircuitBreaker的依赖，如Resilience4j的依赖。
2. **配置属性**：在应用程序的配置文件中配置断路器的属性，如失败率阈值、打开状态下的等待时间、半开状态下允许的最大请求数等。这些配置可以根据实际需求进行调整。
3. **使用注解**：在需要熔断的服务调用方法上使用`@CircuitBreaker`注解，并指定备用方法（fallback）或回退逻辑。当断路器打开时，会调用备用方法或执行回退逻辑。

**五、与其他组件的集成**

SpringCloud CircuitBreaker可以与Spring Cloud的其他组件进行集成，如Spring Cloud Gateway、Spring Cloud OpenFeign等。通过集成这些组件，可以实现更强大的服务治理和容错能力。

**六、注意事项**

1. **合理设置阈值**：在设置失败率阈值时，需要根据服务的实际情况进行合理设置。如果设置得过高，可能会导致服务在正常情况下也被熔断；如果设置得过低，则可能无法有效防止级联失败的发生。
2. **监控和报警**：建议开启实时监控和报警功能，以便在断路器状态发生变化时及时获取通知并进行处理。
3. **定期评估和调整**：随着系统的运行和服务的变化，需要定期评估和调整断路器的配置和策略，以确保其始终能够有效地保护系统。

综上所述，SpringCloud CircuitBreaker是一个强大的容错机制，可以帮助开发者在分布式系统中实现服务调用的容错和降级。通过合理配置和使用断路器，可以提高系统的可用性和稳定性，为用户提供更好的服务体验。



## `Hystrix`

>注意：`feign`客户端调用服务时达到`ribbon.ReadTimeout`超时，即使`execution.isolation.thread.timeoutInMilliseconds`未达到超时时间也会 `fallback`。
>
>配置方式分为 2 种：服务提供者配置服务降级、服务调用者`feign`配置服务降级。

注意：进入维护模式，使用`Resilience4J`替代。

未整理

```
turbine hystrix集群监控
https://www.jianshu.com/p/590bad4c8947
使用 turbine hystrix集群监控
访问 trubine 服务http://localhost:8083/hystrix后，填入http://localhost:8083/turbine.stream，点击monitor按钮

springcloud feign fallback，通过feign、HystrixCommand、FallbackProvider
https://www.cnblogs.com/cearnach/p/9341593.html

springcloud zuul FallbackProvider基本使用，能够根据serviceId调用不同的fallback，不能实现针对route调用不同的fallback
fallback的FallbackProvider使用方法只作用于springcloud zuull，不能作用于fallback的feign、HystrixCommand使用方法
https://juejin.cn/post/6844903862470443015
https://thepracticaldeveloper.com/hystrix-fallback-with-zuul-and-spring-boot/

springcloud hystrix配置
https://blog.csdn.net/hry2015/article/details/78554846

HystrixCommand配置
https://github.com/Netflix/Hystrix/wiki/Configuration#intro

springcloud zuul hystrix超时使用FallbackProvider统一处理
feign hystrix超时使用@ControllerAdvice、@ExceptionHandler统一处理

hystrix资源隔离原理图
https://www.cnblogs.com/-beyond/p/12856421.html

RestTemplate hystrix整合
https://blog.51cto.com/13538361/2426289

feignclient FallbackFactory使用
https://blog.csdn.net/qq_24504315/article/details/79120904

设置 feignclient 各个方法hystrix超时
http://www.saily.top/2020/04/19/springcloud/hystrix05/

The Hystrix timeout of ***ms for the command *** is set lower than the combination of the Ribbon
https://blog.csdn.net/it_beecoder/article/details/106028256

TODO: 写demo演示关闭ribbon、feign、resttemplate retry机制
```



### `Ribbon`超时配置

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

使用浏览器访问 http://localhost:8080/api/v1/user/timeout?milliseconds=30000，在`10`秒时报错表示`Ribbon`配置生效。

`Zuul`网关中配置`Ribbon`超时：

```properties
# ribbon超时
# 连接超时10秒
ribbon.ConnectTimeout=10000
# 读取超时10秒
ribbon.ReadTimeout=10000
ribbon.MaxAutoRetries=0
ribbon.MaxAutoRetriesNextServer=0
# 针对特定服务配置Ribbon超时
#ribbon.spring-cloud-user.ReadTimeout=15000
#ribbon.spring-cloud-user.ConnectTimeout=5000
#ribbon.spring-cloud-user.MaxAutoRetries=0
#ribbon.spring-cloud-user.MaxAutoRetriesNextServer=0
```



### 开启`Feign`客户端的`Hystrix`功能

>说明：开启`Feign`客户端的`Hystrix`功能，如果不开启`Feign`没有熔断保护并且不会触发`Feign`客户端中的`Fallback`回调

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

在`Zuul`中添加如下配置：

```properties
# 开启 Feign 客户端的 Hystrix 功能，如果不开启 Feign 没有熔断保护并且不会出发 Feign 客户端中的 Fallback 回调
feign.hystrix.enabled=true
```

使用下面命令测试此配置

```sh
curl http://localhost:8080/api/v1/user/timeoutWithFeignFallback?milliseconds=30000
```



### 隔离策略

Hystrix 的**隔离策略**是其最核心的设计之一，目的是实现**故障隔离**，防止单个依赖服务的故障耗尽整个系统的资源（如线程），导致雪崩效应。

Hystrix 提供了两种隔离策略：**线程池隔离** 和 **信号量隔离**。

---

#### 两种隔离策略对比总览

| 特性               | THREAD（线程池隔离）         | SEMAPHORE（信号量隔离）      |
| :----------------- | :--------------------------- | :--------------------------- |
| **隔离级别**       | **线程级别**，完全物理隔离   | **信号量级别**，共享调用线程 |
| **超时控制**       | **支持**，可中断任务         | **不支持**，依赖底层调用超时 |
| **异步支持**       | **天然支持**                 | 不支持                       |
| **资源开销**       | 较大（线程创建、上下文切换） | 极小（仅计数器）             |
| **网络请求**       | **推荐**，绝大多数场景适用   | 不适用                       |
| **高性能内部调用** | 不适用，开销过大             | **推荐**                     |

---

##### 1. THREAD（线程池隔离） - **默认且推荐用于外部调用**

**工作原理**

Hystrix 不会在调用线程（如 Tomcat 的工作线程）中直接执行命令，而是将其派发到一个独立的、预先定义好的线程池中执行。这样，即使下游服务响应缓慢或阻塞，也只会占满 Hystrix 的线程池，而不会影响调用线程池（从而不会影响其他服务的调用）。

**配置**

```yaml
hystrix:
  command:
    default:
      execution:
        isolation:
          strategy: THREAD  # 默认就是THREAD，通常不用显式配置
          thread:
            timeoutInMilliseconds: 1000  # 超时时间，可中断
    myServiceCommand: # 针对特定命令的配置
      execution:
        isolation:
          strategy: THREAD
```

```java
@HystrixCommand(
    commandKey = "myServiceCommand",
    groupKey = "MyServiceGroup",
    // 指定使用THREAD隔离
    commandProperties = {
        @HystrixProperty(name = "execution.isolation.strategy", value = "THREAD"),
        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1000")
    },
    // 配置专属线程池
    threadPoolProperties = {
        @HystrixProperty(name = "coreSize", value = "10"),
        @HystrixProperty(name = "maxQueueSize", value = "5")
    }
)
public String callExternalService() {
    // 这个调用会在 "MyServiceGroup" 线程池中的某个线程执行
    return restTemplate.getForObject("http://remote-service/api", String.class);
}
```

**优点**

- **完全隔离**：一个依赖的延迟或故障只会耗尽自己的线程池，不会影响其他依赖。
- **超时控制**：由于是独立线程，Hystrix 可以监控执行时间并主动中断超时的请求。
- **异步支持**：天然支持异步编程模型。

**缺点**

- **性能开销**：线程的创建、调度、上下文切换有一定开销。这是为稳定性付出的必要代价。

**适用场景**

- **所有外部服务调用**：如 HTTP API、RPC 调用、数据库查询等。这是**最常用**的策略。

---

##### 2. SEMAPHORE（信号量隔离）

**工作原理**

Hystrix 在**调用线程**中直接执行命令，不使用线程池。它通过一个计数器（信号量）来限制**并发执行**的命令数量。当信号量用完时，后续请求会被立即拒绝，执行降级逻辑，而不会排队等待。

**配置**

```yaml
hystrix:
  command:
    fastLocalCommand:
      execution:
        isolation:
          strategy: SEMAPHORE  # 指定信号量隔离
        timeout:
          enabled: false  # 信号量隔离下通常禁用超时控制
      circuitBreaker:
        enabled: true  # 熔断器依然可以工作
    fallback:
      isolation:
        semaphore:
          maxConcurrentRequests: 100  # 降级方法的信号量限制
```

```java
@HystrixCommand(
    commandKey = "fastLocalCommand",
    commandProperties = {
        // 指定信号量隔离
        @HystrixProperty(name = "execution.isolation.strategy", value = "SEMAPHORE"),
        // 设置最大并发请求数
        @HystrixProperty(name = "execution.isolation.semaphore.maxConcurrentRequests", value = "20"),
        // 通常禁用超时，因为无法中断调用线程
        @HystrixProperty(name = "execution.timeout.enabled", value = "false")
    }
)
public String veryFastLocalOperation() {
    // 这个调用会在调用线程（如Tomcat线程）中直接执行
    // 信号量只控制能同时进入这个方法的并发数
    return someInMemoryCache.get(data);
}
```

**优点**

- **性能极高**：无线程切换开销，适用于高频、快速的内部调用。
- **简单高效**：对于纯内存操作，信号量控制并发就足够了。

**缺点**

- **无法超时中断**：如果命令在执行线程中阻塞，Hystrix 无法中断它，只能等待其自然返回或容器超时。
- **隔离性较弱**：某个慢请求会一直占用一个调用线程（如 Tomcat 线程），如果大量依赖都使用信号量且同时阻塞，仍可能耗尽容器线程。

**适用场景**

- **超高并发**的**纯内存计算**、**快速本地缓存**查询。
- **非网络调用**的、信任度高的内部方法。

---

#### 总结与实践建议

1.  **默认选择 THREAD 隔离**：对于微服务架构中绝大部分场景（如 Feign 调用、RestTemplate 调用），都应使用 `THREAD` 隔离。这是保证系统稳定性的基石。
2.  **谨慎使用 SEMAPHORE 隔离**：仅在对性能有极致要求，且被调用的方法是快速、可靠的本地操作时使用。通常用于 Hystrix 命令内部的某个关键算法或缓存查询。
3.  **降级方法默认使用 SEMAPHORE**：Hystrix 对降级方法的调用默认使用信号量隔离（通过 `fallback.isolation.semaphore.maxConcurrentRequests` 配置），这是为了防止降级逻辑本身消耗过多资源，导致雪崩。你需要确保降级逻辑是快速且轻量的。

简单来说：**对外部的不信任调用用 THREAD，对内部的信任调用用 SEMAPHORE**。



### 隔离策略 - 信号量

>详细用法请参考本站示例：https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix

```properties
#################################### 信号量模式配置 ####################################
hystrix.command.default.execution.isolation.strategy=SEMAPHORE
# 信号量隔离下不支持超时控制，所以禁用
hystrix.command.default.execution.timeout.enabled=false
hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests=256
hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests=256
# 指定特定微服务信号量配置，微服务不会使用default配置
# 并发请求数限制为256
hystrix.command.spring-cloud-user.execution.isolation.semaphore.maxConcurrentRequests=256
hystrix.command.spring-cloud-user.fallback.isolation.semaphore.maxConcurrentRequests=256
```

### 隔离策略 - 线程 - hystrix.threadpool.default.coreSize配置

**一句话概括：**

`hystrix.threadpool.default.coreSize` 的作用是**设置Hystrix默认线程池中核心线程的数量**。这个参数是Hystrix实现资源隔离（舱壁模式）的关键。

---

#### 详细解释

为了理解这个参数，我们需要从Hystrix的设计理念说起。

##### 1. 背景：资源隔离与舱壁模式

在微服务架构中，服务A调用服务B。如果没有保护措施，当服务B响应缓慢或不可用时，所有调用服务B的请求都会长时间占用服务A的服务器资源（如Tomcat工作线程）。这会导致服务A的资源被耗尽，进而引发服务A本身也瘫痪，也就是所谓的“雪崩效应”。

Hystrix的解决方案是**舱壁模式**。就像轮船的舱壁将船体分隔成多个独立的隔间，一个隔间进水不会导致整艘船沉没一样，Hystrix将不同的远程调用隔离到各自的线程池中。

##### 2. `coreSize` 的角色

`hystrix.threadpool.default.coreSize` 就是这个“舱壁”的厚度。它定义了用于处理某个命令（默认是所有使用`@HystrixCommand`注解的方法）的**独立线程池的最大并发执行线程数**。

*   **“default”**： 表示这是默认的线程池配置。你可以为不同的Hystrix命令指定不同的线程池，例如 `@HystrixCommand(threadPoolKey = "userServicePool")`，然后为 `userServicePool` 配置单独的 `coreSize`。
*   **“coreSize”**： 这里的“核心”指的是线程池中始终保持活跃的线程数（即使空闲），同时也是允许同时执行的最大线程数。当所有核心线程都繁忙时，新的请求会进入队列等待，而不是创建新线程。

##### 3. 工作流程

假设你设置了 `hystrix.threadpool.default.coreSize = 10`。

1.  一个请求进入服务A，需要调用服务B。
2.  Hystrix不会直接用Tomcat的工作线程去调用服务B，而是将这个调用任务提交给其独立的、大小为10的线程池。
3.  如果当前有空闲的线程，该任务会立即被执行。
4.  如果10个线程都在忙（即已经有10个并发请求正在调用服务B），那么新的请求将会被放入队列（队列长度由 `maxQueueSize` 控制）。
5.  如果队列也满了，Hystrix会**立即拒绝执行命令**，并执行降级逻辑（fallback方法）。

##### 4. 核心作用与好处

1.  **控制并发量**： 这是最直接的作用。无论下游服务B有多慢，服务A对服务B的并发请求数最多不会超过 `coreSize`（这里是10个）。这防止了一个慢依赖拖垮整个调用方。
2.  **避免资源耗尽**： 由于Hystrix命令在自己的线程池中运行，它不会占用光所有的Tomcat工作线程。即使调用服务B的10个线程全部被阻塞，服务A仍然有剩余的Tomcat线程来处理其他不依赖服务B的请求（比如健康检查、调用服务C等）。
3.  **快速失败**： 当线程池和队列饱和时，Hystrix会快速失败并触发降级，而不是让请求无休止地等待，这为系统提供了弹性。

##### 5. 如何配置与注意事项

**配置方式（在application.yml中）：**

```yaml
hystrix:
  threadpool:
    default:
      coreSize: 20       # 默认线程池的核心线程数
      maxQueueSize: 1000 # 等待队列的大小，-1表示使用SynchronousQueue，0或正数使用LinkedBlockingQueue
      queueSizeRejectionThreshold: 20 # 即使maxQueueSize没有满，达到此值也会触发拒绝。用于动态修改队列大小时使用。
```

**注意事项：**

*   **设置多大合适？**： 没有一个固定值。你需要根据服务的性能、能承受的负载以及超时时间进行压测和调整。设置太小，无法充分利用资源；设置太大，就失去了隔离的意义。一般原则是：`核心线程数 = 每秒请求数 × 99%平均响应时间(秒) + 一些冗余`。
*   **与信号量隔离的区别**： Hystrix还支持信号量隔离，它更轻量级，但不涉及线程池，适用于内部内存调用（如访问本地缓存）或可靠性极高的依赖。线程池隔离开销更大，但提供了超时和控制异步执行的能力，适用于网络请求。
*   **Hystrix现状**： 请注意，Hystrix目前已处于维护模式，Netflix官方推荐使用更现代的容错库，如 **Resilience4j** 或 **Spring Cloud Circuit Breaker**。这些新库也采用了类似的隔离思想，但API和配置方式有所不同。不过，理解Hystrix的这些核心概念对于理解微服务容错仍然非常有价值。

#### 总结

`hystrix.threadpool.default.coreSize` 是Hystrix实现线程池隔离的核心参数，它通过限制单个依赖的最大并发请求数，将故障隔离在单个依赖内部，从而防止整个系统因某个依赖的故障而发生雪崩效应。

### 隔离策略 - 线程 - hystrix.threadpool.default.maximumSize和hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize配置

**一句话概括：**

`hystrix.threadpool.default.maximumSize` 的作用是**设置Hystrix线程池允许扩展到的最大线程数**。这个参数需要和 `allowMaximumSizeToDivergeFromCoreSize` 配合使用才生效。

---

#### 详细解释

要理解 `maximumSize`，我们需要先回顾一下 `coreSize` 的行为。

##### 1. 回顾：`coreSize` 的固定大小模式

默认情况下，当你只设置了 `hystrix.threadpool.default.coreSize = 10`，Hystrix会创建一个**固定大小的线程池**。这意味着：
*   线程池中始终只有10个线程。
*   当所有10个线程都繁忙时，新来的任务会进入队列等待。
*   **即使系统负载再高，线程池也绝不会创建超过10个线程。**

这种固定模式在大多数情况下能很好地工作，但缺乏弹性。如果在某个高峰时段，10个核心线程被长时间阻塞的任务占满，而队列中也积压了很多任务，此时系统虽然不会崩溃，但响应会变得非常慢，因为所有请求都在排队等待。

##### 2. `maximumSize` 的作用：引入弹性伸缩

`maximumSize` 参数就是为了解决固定模式的僵化问题而引入的。它允许线程池在负载激增时**临时扩展**，创建超过 `coreSize` 的线程来处理队列中的任务，从而提供更好的响应性。

**工作流程（当启用弹性伸缩时）：**

假设配置如下：
```yaml
hystrix:
  threadpool:
    default:
      coreSize: 10
      maximumSize: 20
      allowMaximumSizeToDivergeFromCoreSize: true # 关键：必须设置为true才能启用弹性伸缩
```

1.  **正常情况**：线程池保持 `coreSize=10` 个核心线程运行。
2.  **负载升高**：10个核心线程已满，新任务进入队列。
3.  **弹性扩展**：**当队列中的任务堆积到一定程度时**，线程池不会坐视不管，而是会开始创建新的线程，直到线程总数达到 `maximumSize=20`。
4.  **处理积压**：这些新创建的线程会从队列中获取任务并执行，从而加快消耗队列中的积压请求。
5.  **回收线程**：当负载下降，这些超出 `coreSize` 的“临时”线程在空闲一段时间后（由 `keepAliveTimeMinutes` 控制）会被回收，线程池大小最终会收缩回 `coreSize`。

##### 3. 关键依赖：`allowMaximumSizeToDivergeFromCoreSize`

这是最重要的一个点：**仅仅设置 `maximumSize` 是无效的！**

Hystrix为了保持向后兼容，默认行为是固定大小线程池。你必须显式地将 `allowMaximumSizeToDivergeFromCoreSize` 设置为 `true`，才能将线程池从固定模式切换到可伸缩模式。

##### 4. 相关参数：`keepAliveTimeMinutes`

当线程池扩展后，需要一种机制来回收多余的线程以节省资源。`keepAliveTimeMinutes` 就定义了这些超出核心线程数的临时线程，在空闲多久之后会被终止回收。

示例配置：
```yaml
hystrix:
  threadpool:
    default:
      coreSize: 10
      maximumSize: 20
      allowMaximumSizeToDivergeFromCoreSize: true
      keepAliveTimeMinutes: 1 # 临时线程空闲1分钟后被回收
```

##### 5. 与队列的配合

弹性伸缩机制通常与队列大小（`maxQueueSize`）配合工作。当队列中的任务开始增长，就触发了线程池扩展的条件。这避免了因为队列设置过大，导致请求在队列中等待时间过长的问题。

#### 总结

| 参数                                    | 作用                                                         | 默认值/关系                               |
| :-------------------------------------- | :----------------------------------------------------------- | :---------------------------------------- |
| `coreSize`                              | **核心线程数**。线程池长期保持的基本大小，也是默认的最大并发限制。 | 默认值为 10。                             |
| `maximumSize`                           | **最大线程数**。线程池允许扩展到的绝对上限。                 | 默认等于 `coreSize`，即固定大小。         |
| `allowMaximumSizeToDivergeFromCoreSize` | **启用弹性伸缩的开关**。                                     | 必须设为 `true`，`maximumSize` 才会生效。 |
| `keepAliveTimeMinutes`                  | **临时线程存活时间**。控制超出核心数的线程空闲多久后被回收。 | 默认1分钟。                               |

**核心思想：**
`hystrix.threadpool.default.maximumSize` 提供了比固定大小线程池更灵活的弹性能力。它允许你在流量突发时，通过临时增加线程来快速“泄洪”，降低请求的排队延迟，提高系统的响应速度。这是一种在资源隔离基础上，对系统弹性的进一步优化。

### 隔离策略 - 线程 - hystrix.threadpool.default.maxQueueSize和hystrix.threadpool.default.queueSizeRejectionThreshold配置

#### 总体概念

当所有核心线程都在忙碌时，新的任务不会立即被拒绝，而是先进入一个**等待队列**。`maxQueueSize` 和 `queueSizeRejectionThreshold` 就是用来管理这个队列的。

---

#### 1. hystrix.threadpool.default.maxQueueSize

**作用：** 设置线程池等待队列的**最大容量**。

**详细解释：**

*   **队列类型**：`maxQueueSize` 的值决定了Hystrix使用哪种阻塞队列：
    *   **如果 `maxQueueSize == -1`（默认值）**：Hystrix会使用 `SynchronousQueue`。这是一个非常特殊的队列，它**不保存任何任务**。每个插入操作（提交任务）必须等待一个对应的移除操作（线程来取任务），可以理解为“手递手”模式。**这意味着如果没有立即可用的线程，任务会直接尝试交给新创建的线程（如果允许扩展）或触发拒绝策略。** 实际上，这相当于队列大小为0。
    *   **如果 `maxQueueSize > 0`**：Hystrix会使用 `LinkedBlockingQueue`。这是一个有容量的队列，可以暂时存放等待执行的任务。

*   **行为**：
    *   当运行的线程数达到 `coreSize` 时，新任务不会立即创建新线程（在固定大小模式下），而是会被放入这个队列中等待。
    *   队列起到一个**缓冲作用**，应对短暂的流量高峰。

**示例：**
`maxQueueSize: 10` 表示队列最多可以容纳10个等待任务。

---

#### 2. hystrix.threadpool.default.queueSizeRejectionThreshold

**作用：** 设置触发拒绝的**队列大小阈值**。这个参数是动态控制拒绝时机的关键。

**详细解释：**

这是Hystrix一个非常巧妙的设计。你可能会认为，当队列中的任务数达到 `maxQueueSize` 时，才会触发拒绝。但实际上，Hystrix允许你设置一个**更早、更灵活的拒绝点**。

*   **为什么需要这个参数？**
    *   因为 `maxQueueSize` 可以在应用运行时**动态调整**（通过Archaius配置管理器），但 `LinkedBlockingQueue` 的容量在创建后就无法更改。
    *   为了解决这个矛盾，Hystrix引入了 `queueSizeRejectionThreshold` 作为动态的“水位线”。即使队列的实际容量 (`maxQueueSize`) 很大，但只要队列中的任务数达到了这个阈值，Hystrix就会开始拒绝新任务。

*   **行为规则**：
    *   当队列中的任务数 **>= `queueSizeRejectionThreshold`** 时，新提交的任务会被立即拒绝，并执行降级逻辑，而不会进入队列等待。
    *   `queueSizeRejectionThreshold` 的值必须 **<= `maxQueueSize`**，否则它将不生效。

---

#### 工作流程与配合示例

让我们通过一个具体的配置例子，把这两个参数串联起来看它们是如何工作的。

**配置：**
```yaml
hystrix:
  threadpool:
    default:
      coreSize: 10
      maxQueueSize: 20
      queueSizeRejectionThreshold: 15
      # 假设是固定大小模式，maximumSize不生效
```

**一个请求的处理流程：**

1.  **请求到达**：一个需要Hystrix保护的调用请求到来。
2.  **检查线程**：
    *   如果有空闲的**核心线程**，立即使用该线程执行任务。✅
    *   如果**10个核心线程已全部占用**，则请求不立即执行，而是进入下一步。➡️
3.  **检查队列**：
    *   当前队列中有 **14个** 任务在等待。`14 < queueSizeRejectionThreshold(15)`，所以新任务可以进入队列排队。✅
    *   当前队列中有 **15个** 任务在等待。`15 >= queueSizeRejectionThreshold(15)`，**触发拒绝策略**！新任务被立即拒绝，执行fallback方法。❌
4.  **队列的物理限制**：
    *   即使你将 `queueSizeRejectionThreshold` 设得很高，队列中的任务数也**永远不会超过 `maxQueueSize(20)`**。这是队列本身的硬限制。

#### 总结与类比

你可以把整个系统想象成一个**银行办事大厅**：

| Hystrix 参数                      | 银行大厅类比                                                 |
| :-------------------------------- | :----------------------------------------------------------- |
| `coreSize: 10`                    | 有 **10个服务窗口**。                                        |
| `maxQueueSize: 20`                | 大厅里设置的**排队等候区最多只能放20把椅子**。这是物理限制。 |
| `queueSizeRejectionThreshold: 15` | 大厅经理看到已经有**15个人在排队**时，就会在门口立个“暂停取号”的牌子，新来的客户会被劝离（拒绝），建议他们去其他银行（降级）。 |

**这样设计的好处：**

*   **快速失败**：不会等到队列完全塞满（20人）才拒绝，而是在排队长度达到一个“合理”的阈值（15人）时就提前拒绝，避免客户等待时间过长。这符合微服务快速失败的设计原则。
*   **动态控制**：在不重启应用的情况下，你可以通过配置中心动态地将 `queueSizeRejectionThreshold` 从15降低到5，从而让系统在排队很长之前就变得“不那么友好”，以保护自身。

**默认值提醒：**
*   `maxQueueSize` 默认是 **-1**（使用`SynchronousQueue`，无队列）。
*   `queueSizeRejectionThreshold` 默认是 **5**。
*   因为默认 `maxQueueSize = -1`，所以默认情况下 `queueSizeRejectionThreshold` 是**不生效**的。只有当你将 `maxQueueSize` 设置为一个正数时，这个阈值参数才有意义。

### 隔离策略 - 线程

>详细用法请参考本站示例：https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix

```properties
#################################### 线程隔离模式配置 ####################################
hystrix.command.default.execution.isolation.strategy=THREAD
# 启用 Hystrix 命令执行的超时控制功能
# 决定 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000 配置是否生效
hystrix.command.default.execution.timeout.enabled=true
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=30000
hystrix.command.default.circuitBreaker.enabled=false
hystrix.command.default.circuitBreaker.errorThresholdPercentage=50
hystrix.command.default.circuitBreaker.requestVolumeThreshold=20
#核心线程数。线程池长期保持的基本大小，也是默认的最大并发限制。
hystrix.threadpool.default.coreSize=256
# 线程池从固定模式切换到可伸缩模式
hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize=true
# 最大线程数。线程池允许扩展到的绝对上限。
hystrix.threadpool.default.maximumSize=256
hystrix.threadpool.default.maxQueueSize=10240
hystrix.threadpool.default.queueSizeRejectionThreshold=10240
hystrix.command.ApiUser#timeout(Integer).execution.isolation.thread.timeoutInMilliseconds=6000
# zuul route hystrix隔离ThreadPool默认THREAD
zuul.ribbonIsolationStrategy=THREAD
# zuul route hystrix隔离ThreadPool各个微服务独立
# http://www.itmuch.com/spring-cloud/edgware-new-zuul-hystrix-thread-pool/
zuul.threadPool.useSeparateThreadPools=true
```



### 服务提供者服务降级

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

正常访问

```sh
curl http://localhost:8081/api/v1/user/test1
```

服务降级访问

>说明：因为`sleep`时间持续`3000`毫秒大于`execution.isolation.thread.timeoutInMilliseconds`配置的`2000`毫秒导致触发服务降级。虽然因为超时服务降级，但是陆续进来的请求依旧被服务器处理，并且将会导致更多的服务调用失败。

```sh
$ curl http://localhost:8081/api/v1/user/test1\?milliseconds\=3000
{"errorCode":5000,"errorMessage":null,"data":"调用ProviderSideFallbackController1#test接口失败"}
```



### 服务提供者服务降级 - 统一`Fallback`

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

正常访问

```sh
curl http://localhost:8081/api/v1/user/test2
```

服务降级访问

```sh
$ curl http://localhost:8081/api/v1/user/test2?milliseconds=3000
{"errorCode":5000,"errorMessage":null,"data":"调用ProviderSideFallbackController2#test接口失败"}
```



### 服务调用者`Feign`服务降级

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

正常访问

```sh
curl http://localhost:8080/api/v1/user/timeoutWithFeignFallback
```

触发`Feign Fallback`访问

>说明：在`application.properties`里面配置`Feign ApiUser.timeout`超时时间为`10000`，所以会触发`Feign Fallback`。

```sh
curl http://localhost:8080/api/v1/user/timeoutWithFeignFallback?milliseconds=10100
{"errorCode":600,"errorMessage":"User服务不可用，稍候...（来自ApiUser）","data":null}
```



### 服务熔断

借助本站[示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix)协助测试

使用命令刷新`5`次后触发熔断

```sh
curl http://localhost:8081/api/v1/user/testCircuitBreaker1
```

马上使用命令访问接口错误返回说明熔断已经被打开，大概经过`30`秒后服务恢复正常

```sh
curl http://localhost:8081/api/v1/user/testCircuitBreaker1?id=22
```

### 性能调优

>说明：注释其他调优参数，只切换信号量和线程两种策略对比性能差异。
>
>使用本站示例 https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-hystrix 协助测试。

编译并推送镜像

```sh
./build.sh && ./push.sh
```

复制部署配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

启动服务

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试服务是否正常

```sh
curl http://192.168.1.185/api/v1/user/test1
```

信号量测试结果：

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/user/test1
Running 30s test @ http://192.168.1.185/api/v1/user/test1
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   169.06ms  213.94ms   3.79s    97.37%
    Req/Sec     1.71k   265.38     2.15k    89.70%
  Latency Distribution
     50%  133.30ms
     75%  144.64ms
     90%  190.60ms
     99%  958.37ms
  409215 requests in 30.07s, 113.18MB read
Requests/sec:  13610.39
Transfer/sec:      3.76MB
```

线程测试结果：

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/user/test1
Running 30s test @ http://192.168.1.185/api/v1/user/test1
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   167.42ms   50.02ms   1.23s    89.98%
    Req/Sec     1.54k   216.30     3.16k    81.12%
  Latency Distribution
     50%  153.84ms
     75%  180.54ms
     90%  214.18ms
     99%  296.64ms
  366721 requests in 30.10s, 101.42MB read
Requests/sec:  12185.11
Transfer/sec:      3.37MB
```

结论：信号量性能高于线程。

销毁服务

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

## `Resilience4J`

详细用法请参考示例`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/demo-spring-cloud-resilience4j`



### 介绍

Resilience4j是一个专为Java应用设计的轻量级容错库，以下是对Resilience4j的详细介绍：

**一、简介**

Resilience4j受Netflix Hystrix的启发，但专为Java 8和函数式编程而设计。与Hystrix相比，Resilience4j更加轻量级，因为它只使用Vavr库，没有任何其他外部库依赖项。Resilience4j提供了高阶函数（装饰器），以通过断路器、速率限制器、重试或隔板（Bulkhead）增强任何功能接口、lambda表达式或方法引用。此外，Resilience4j可以在任何功能接口、lambda表达式或方法引用上堆叠多个装饰器，且允许开发者选择所需的装饰器。

**二、核心组件**

Resilience4j提供了丰富的模块化且灵活的容错选项，这些核心组件各自承担不同的职责，能够单独使用或组合使用，以应对不同类型的故障场景。具体组件包括：

1. **断路器（Circuit Breaker）**：当下游服务出现问题时，Resilience4j的断路器可以阻止应用程序持续向故障的服务发送请求，从而提高应用程序的整体可用性。
2. **限流器（Rate Limiter）**：Resilience4j可以防止应用程序向下游服务发送过多的请求，从而防止下游服务过载。限流器通过限制单位时间内允许的请求数量，确保系统在高负载下仍能稳定运行。
3. **重试（Retry）**：在网络不稳定或服务暂时不可用的情况下，Resilience4j可以自动重试失败的操作。
4. **隔板（Bulkhead）**：类似于船舶的舱壁设计，用于将系统划分为多个独立的部分，以防止某个部分的故障影响整个系统。Resilience4j的隔板通过限制并发调用的数量，确保关键资源的可用性。
5. **缓存（Cache）**：用于存储请求的响应结果，减少对后端服务的频繁调用，提高系统的响应速度和可用性。Resilience4j的缓存模块可以与断路器和重试机制结合使用，优化容错策略。
6. **时间器（Time Limiter）**：用于限制调用的最大执行时间，防止长时间阻塞导致系统资源被占用。Resilience4j的时间器通过设置超时时间，当调用超过指定时间后自动中断。

**三、特点与优势**

1. **轻量级且模块化**：Resilience4j采用模块化设计，开发者可以根据实际需求选择所需的功能模块，避免引入不必要的依赖，保持项目的轻量性。
2. **函数式编程支持**：Resilience4j完全基于Java 8的函数式编程理念，能够与现代Java应用无缝集成，提升代码的可读性和可维护性。
3. **易于配置和扩展**：通过简单的配置文件或代码方式，开发者可以轻松定制各个模块的行为。此外，Resilience4j提供丰富的扩展点，允许用户根据具体需求进行自定义。
4. **良好的集成能力**：Resilience4j能够与Spring Boot等主流框架良好集成，简化了在现有项目中引入容错机制的过程。同时，它也兼容多种监控工具，方便进行性能监控和故障诊断。
5. **活跃的社区和文档支持**：Resilience4j拥有活跃的开源社区，提供详尽的文档和丰富的示例，帮助开发者快速上手并解决实际问题。

**四、使用场景**

Resilience4j主要应用于微服务架构中，提供服务间调用的稳定性和弹性。例如，在一个微服务应用中，可能需要调用一个可能会失败的远程服务。此时，可以使用Resilience4j的熔断器和重试功能来增强服务调用。如果服务调用失败的次数超过了设定的阈值，熔断器就会打开，阻止进一步的服务调用。然后，可以使用重试对象来自动重试失败的服务调用。

**五、总结**

Resilience4j以其简单易用、灵活配置和良好的性能表现，成为许多Java开发者在构建高可用系统时的首选工具。通过使用Resilience4j，开发者可以更好地应对故障和异常，提高系统的可靠性和可用性。



### 基本配置

>OpenFeign + Resilience4J 组合，OpenFeign 提供远程调用能力，Resilience4J 提供服务熔断和降级能力。SpringBoot 版本 3.3.7 + SpringCloud 版本 2023.0.4 + JDK 版本 17。

pom 添加如下配置：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<!-- Resilience4J circuitbreaker 依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<!-- Resilience4J 需要 AOP 支持才能够正常运作 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

application.yaml 配置 circuitbreaker Resilience4J

```yaml
spring:
  cloud:
    openfeign:
      circuitbreaker:
        # 启用 OpenFeign 的断路器功能
        enabled: true
        # 支持 default 默认配置和指定 feign 的配置
        group:
          enabled: true
resilience4j:
  timelimiter:
    configs:
      default:
        # 设置了超时持续时间为10秒。这意味着，如果一个远程调用的响应时间超过了10秒，它将触发一个超时异常
        timeout-duration: 10s
  circuitbreaker:
    configs:
      default:
        # 设置了失败率阈值为50%。这意味着，如果在一个滑动窗口时间段内，远程调用的失败率达到了或超过了50%，断路器将会打开，阻止进一步的调用，以保护系统免受进一步的失败影响。
        failure-rate-threshold: 50
        # 设置了慢调用的持续时间阈值为5秒。这意味着，如果一个远程调用的响应时间超过了5秒，它将被视为一个慢调用。
        slow-call-duration-threshold: 1s
        # 设置了慢调用率阈值为30%。这意味着，在一个滑动窗口时间段内，如果远程调用的慢调用比率达到了或超过了30%，断路器将会打开。这
        slow-call-rate-threshold: 30
        # 设置了滑动窗口的类型为基于计数的类型，大小为6。这意味着断路器将使用一个大小为6的计数器来跟踪最近的调用结果。
        sliding-window-type: COUNT_BASED
        # 设置了滑动窗口的大小为6。这意味着断路器将使用一个大小为6的计数器来跟踪最近的调用结果，以便进行失败率计算和慢调用的统计。
        sliding-window-size: 6
        # 设置了在断路器打开之前，至少需要6次调用才能触发断路器的状态转换。这意味着，在断路器完全打开之前，必须收集足够的数据来评估系统的健康状况。
        minimum-number-of-calls: 6
        # 设置了在断路器打开后，自动从开放状态转换到半开状态的标志为true。这意味着，一旦断路器打开，它将尝试在一段时间后重新允许少量的调用通过
        automatic-transition-from-open-to-half-open-enabled: true
        # 设置了在断路器打开状态下，等待5秒后自动转换到半开状态。这意味着，一旦断路器打开，它将等待5秒钟后再尝试允许少量的调用通过
        wait-duration-in-open-state: 5s
        # 设置了在断路器半开状态下，允许2次调用通过。这意味着，当断路器从打开状态转换到半开状态时，它将只允许少量的调用尝试执行远程服务的方法
        permitted-number-of-calls-in-half-open-state: 2
        record-exceptions:
          # 指定了在断路器统计失败率时，哪些异常类型应该被记录为失败的调用。这里包括了所有继承自java.lang.Exception的异常类
          - java.lang.Exception

#      default:
#        # 设置了失败率阈值为50%。这意味着，如果在一个滑动窗口时间段内，远程调用的失败率达到了或超过了50%，断路器将会打开，阻止进一步的调用，以保护系统免受进一步的失败影响。
#        failure-rate-threshold: 50
#        # 设置了慢调用的持续时间阈值为5秒。这意味着，如果一个远程调用的响应时间超过了5秒，它将被视为一个慢调用。
#        slow-call-duration-threshold: 1s
#        # 设置了慢调用率阈值为30%。这意味着，在一个滑动窗口时间段内，如果远程调用的慢调用比率达到了或超过了30%，断路器将会打开。这
#        slow-call-rate-threshold: 30
#        # 设置了滑动窗口的类型为基于时间的类型
#        sliding-window-type: TIME_BASED
#        # 设置了滑动窗口的大小为5。这意味着断路器将使用一个大小为5的时间窗口来跟踪最近的调用结果，以便进行失败率计算和慢调用的统计。
#        sliding-window-size: 5
#        # 设置了在断路器打开之前，至少需要5次调用才能触发断路器的状态转换。这意味着，在断路器完全打开之前，必须收集足够的数据来评估系统的健康状况。
#        minimum-number-of-calls: 5
#        # 设置了在断路器打开后，自动从开放状态转换到半开状态的标志为true。这意味着，一旦断路器打开，它将尝试在一段时间后重新允许少量的调用通过
#        automatic-transition-from-open-to-half-open-enabled: true
#        # 设置了在断路器打开状态下，等待5秒后自动转换到半开状态。这意味着，一旦断路器打开，它将等待5秒钟后再尝试允许少量的调用通过
#        wait-duration-in-open-state: 5s
#        # 设置了在断路器半开状态下，允许2次调用通过。这意味着，当断路器从打开状态转换到半开状态时，它将只允许少量的调用尝试执行远程服务的方法
#        permitted-number-of-calls-in-half-open-state: 2
#        record-exceptions:
#          # 指定了在断路器统计失败率时，哪些异常类型应该被记录为失败的调用。这里包括了所有继承自java.lang.Exception的异常类
#          - java.lang.Exception
    instances:
      # 指定了名为demo-service-provider的远程服务实例，并使用默认配置（default）来配置断路器参数
      demo-service-provider:
        base-config: default
```

Feign 客户端 FeignClientProvider

```java
@FeignClient(value = "demo-service-provider", path = "/api/v1")
public interface FeignClientProvider {
    @GetMapping("test1")
    // 配置 Feign 客户端 circuitbreaker resilience4j 服务熔断和降级
    @CircuitBreaker(name = "demo-service-provider", fallbackMethod = "test1Fallback")
    public ObjectResponse<String> test1(@RequestParam(value = "flag", defaultValue = "") String flag) throws Throwable;

    // 服务降级 fallback 方法
    default public ObjectResponse<String> test1Fallback(Throwable throwable) {
        ObjectResponse<String> response = new ObjectResponse<>();
        response.setErrorMessage(throwable.getMessage());
        return response;
    }
}

```

调用 Feign 客户端

```java
@RestController
@RequestMapping("/api/v1")
public class DemoController {
    @Resource
    FeignClientProvider feignClientProvider;

    @GetMapping("test1")
    public ObjectResponse<String> test1(@RequestParam(value = "flag", defaultValue = "") String flag) throws Throwable {
        return this.feignClientProvider.test1(flag);
    }
}
```

启用 Feign 客户端

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(clients = {FeignClientProvider.class})
public class ApplicationConsumer {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationConsumer.class, args);
    }
}
```

运行 ApplicationTests#testForCountBased 测试用例



### 运行示例

注意：运行 ApplicationTests 中不同的测试用例时，在每个测试用例之间需要重启 ApplicationConsumer，否则上次的测试会影响此次的测试。

启动 Consul

```bash
docker compose up -d
```

启动 ApplicationProvider、ApplicationConsumer 应用

运行 ApplicationTests#testForCountBased 测试用例



### 基于计数窗口（CircuitBreaker）

application.yaml 配置如下：

```yaml
spring:
  cloud:
    openfeign:
      circuitbreaker:
        # 启用 OpenFeign 的断路器功能
        enabled: true
        # 支持 default 默认配置和指定 feign 的配置
        group:
          enabled: true
resilience4j:
  timelimiter:
    configs:
      default:
        # 设置了超时持续时间为10秒。这意味着，如果一个远程调用的响应时间超过了10秒，它将触发一个超时异常
        timeout-duration: 10s
  circuitbreaker:
    configs:
      default:
        # 设置了失败率阈值为50%。这意味着，如果在一个滑动窗口时间段内，远程调用的失败率达到了或超过了50%，断路器将会打开，阻止进一步的调用，以保护系统免受进一步的失败影响。
        failure-rate-threshold: 50
        # 设置了慢调用的持续时间阈值为5秒。这意味着，如果一个远程调用的响应时间超过了5秒，它将被视为一个慢调用。
        slow-call-duration-threshold: 1s
        # 设置了慢调用率阈值为30%。这意味着，在一个滑动窗口时间段内，如果远程调用的慢调用比率达到了或超过了30%，断路器将会打开。这
        slow-call-rate-threshold: 30
        # 设置了滑动窗口的类型为基于计数的类型，大小为6。这意味着断路器将使用一个大小为6的计数器来跟踪最近的调用结果。
        sliding-window-type: COUNT_BASED
        # 设置了滑动窗口的大小为6。这意味着断路器将使用一个大小为6的计数器来跟踪最近的调用结果，以便进行失败率计算和慢调用的统计。
        sliding-window-size: 6
        # 设置了在断路器打开之前，至少需要6次调用才能触发断路器的状态转换。这意味着，在断路器完全打开之前，必须收集足够的数据来评估系统的健康状况。
        minimum-number-of-calls: 6
        # 设置了在断路器打开后，自动从开放状态转换到半开状态的标志为true。这意味着，一旦断路器打开，它将尝试在一段时间后重新允许少量的调用通过
        automatic-transition-from-open-to-half-open-enabled: true
        # 设置了在断路器打开状态下，等待5秒后自动转换到半开状态。这意味着，一旦断路器打开，它将等待5秒钟后再尝试允许少量的调用通过
        wait-duration-in-open-state: 5s
        # 设置了在断路器半开状态下，允许2次调用通过。这意味着，当断路器从打开状态转换到半开状态时，它将只允许少量的调用尝试执行远程服务的方法
        permitted-number-of-calls-in-half-open-state: 2
        record-exceptions:
          # 指定了在断路器统计失败率时，哪些异常类型应该被记录为失败的调用。这里包括了所有继承自java.lang.Exception的异常类
          - java.lang.Exception
    instances:
      # 指定了名为demo-service-provider的远程服务实例，并使用默认配置（default）来配置断路器参数
      demo-service-provider:
        base-config: default
```

Feign 客户端注解 @CircuitBreaker

```java
@FeignClient(value = "demo-service-provider", path = "/api/v1")
public interface FeignClientProvider {
    @GetMapping("test1")
    // 配置 Feign 客户端 circuitbreaker resilience4j 服务熔断和降级
    @CircuitBreaker(name = "demo-service-provider", fallbackMethod = "test1Fallback")
    public ObjectResponse<String> test1(@RequestParam(value = "flag", defaultValue = "") String flag) throws Throwable;

    // 服务降级 fallback 方法
    default public ObjectResponse<String> test1Fallback(Throwable throwable) {
        ObjectResponse<String> response = new ObjectResponse<>();
        response.setErrorMessage(throwable.getMessage());
        return response;
    }
}
```

重启 ApplicationConsumer 应用，运行 ApplicationTests#testForCoutBased 测试用例



### 基于慢调用（CircuitBreaker）

application.yaml 配置如下：

```yaml
spring:
  cloud:
    openfeign:
      circuitbreaker:
        # 启用 OpenFeign 的断路器功能
        enabled: true
        # 支持 default 默认配置和指定 feign 的配置
        group:
          enabled: true
resilience4j:
  timelimiter:
    configs:
      default:
        # 设置了超时持续时间为10秒。这意味着，如果一个远程调用的响应时间超过了10秒，它将触发一个超时异常
        timeout-duration: 10s
  circuitbreaker:
    configs:
      default:
        # 设置了慢调用的持续时间阈值为5秒。这意味着，如果一个远程调用的响应时间超过了5秒，它将被视为一个慢调用。
        slow-call-duration-threshold: 1s
        # 设置了慢调用率阈值为30%。这意味着，在一个滑动窗口时间段内，如果远程调用的慢调用比率达到了或超过了30%，断路器将会打开。这
        slow-call-rate-threshold: 30
    instances:
      # 指定了名为demo-service-provider的远程服务实例，并使用默认配置（default）来配置断路器参数
      demo-service-provider:
        base-config: default
```

Feign 客户端注解 @CircuitBreaker

```java
@FeignClient(value = "demo-service-provider", path = "/api/v1")
public interface FeignClientProvider {
    @GetMapping("test1")
    // 配置 Feign 客户端 circuitbreaker resilience4j 服务熔断和降级
    @CircuitBreaker(name = "demo-service-provider", fallbackMethod = "test1Fallback")
    public ObjectResponse<String> test1(@RequestParam(value = "flag", defaultValue = "") String flag) throws Throwable;

    // 服务降级 fallback 方法
    default public ObjectResponse<String> test1Fallback(Throwable throwable) {
        ObjectResponse<String> response = new ObjectResponse<>();
        response.setErrorMessage(throwable.getMessage());
        return response;
    }
}
```

重启 ApplicationConsumer 应用，运行 ApplicationTests#testForSlowCall 测试用例



### 基于时间窗口（CircuitBreaker）

application.yaml 配置如下：

```yaml
spring:
  cloud:
    openfeign:
      circuitbreaker:
        # 启用 OpenFeign 的断路器功能
        enabled: true
        # 支持 default 默认配置和指定 feign 的配置
        group:
          enabled: true
resilience4j:
  timelimiter:
    configs:
      default:
        # 设置了超时持续时间为10秒。这意味着，如果一个远程调用的响应时间超过了10秒，它将触发一个超时异常
        timeout-duration: 10s
  circuitbreaker:
    configs:
      default:
        # 设置了失败率阈值为50%。这意味着，如果在一个滑动窗口时间段内，远程调用的失败率达到了或超过了50%，断路器将会打开，阻止进一步的调用，以保护系统免受进一步的失败影响。
        failure-rate-threshold: 50
        # 设置了慢调用的持续时间阈值为5秒。这意味着，如果一个远程调用的响应时间超过了5秒，它将被视为一个慢调用。
        slow-call-duration-threshold: 1s
        # 设置了慢调用率阈值为30%。这意味着，在一个滑动窗口时间段内，如果远程调用的慢调用比率达到了或超过了30%，断路器将会打开。这
        slow-call-rate-threshold: 30
        # 设置了滑动窗口的类型为基于时间的类型
        sliding-window-type: TIME_BASED
        # 设置了滑动窗口的大小为5。这意味着断路器将使用一个大小为5的时间窗口来跟踪最近的调用结果，以便进行失败率计算和慢调用的统计。
        sliding-window-size: 5
        # 设置了在断路器打开之前，至少需要5次调用才能触发断路器的状态转换。这意味着，在断路器完全打开之前，必须收集足够的数据来评估系统的健康状况。
        minimum-number-of-calls: 5
        # 设置了在断路器打开后，自动从开放状态转换到半开状态的标志为true。这意味着，一旦断路器打开，它将尝试在一段时间后重新允许少量的调用通过
        automatic-transition-from-open-to-half-open-enabled: true
        # 设置了在断路器打开状态下，等待5秒后自动转换到半开状态。这意味着，一旦断路器打开，它将等待5秒钟后再尝试允许少量的调用通过
        wait-duration-in-open-state: 5s
        # 设置了在断路器半开状态下，允许2次调用通过。这意味着，当断路器从打开状态转换到半开状态时，它将只允许少量的调用尝试执行远程服务的方法
        permitted-number-of-calls-in-half-open-state: 2
        record-exceptions:
          # 指定了在断路器统计失败率时，哪些异常类型应该被记录为失败的调用。这里包括了所有继承自java.lang.Exception的异常类
          - java.lang.Exception
    instances:
      # 指定了名为demo-service-provider的远程服务实例，并使用默认配置（default）来配置断路器参数
      demo-service-provider:
        base-config: default
```

Feign 客户端注解 @CircuitBreaker

```java
@FeignClient(value = "demo-service-provider", path = "/api/v1")
public interface FeignClientProvider {
    @GetMapping("test1")
    // 配置 Feign 客户端 circuitbreaker resilience4j 服务熔断和降级
    @CircuitBreaker(name = "demo-service-provider", fallbackMethod = "test1Fallback")
    public ObjectResponse<String> test1(@RequestParam(value = "flag", defaultValue = "") String flag) throws Throwable;

    // 服务降级 fallback 方法
    default public ObjectResponse<String> test1Fallback(Throwable throwable) {
        ObjectResponse<String> response = new ObjectResponse<>();
        response.setErrorMessage(throwable.getMessage());
        return response;
    }
}
```

重启 ApplicationConsumer 应用，运行 ApplicationTests#testForTimeBased 测试用例



### 舱壁隔离（Bulkhead）

>todo 实验未成功

pom 引入舱壁隔离依赖

```xml
<!-- 舱壁隔离（Bulkhead）依赖 -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-bulkhead</artifactId>
</dependency>
```



### 限流（RateLimiter）

>todo 未做实验



## `Sentinel`

详细用法请参考文档 <a href="/spring-cloud/#sentinel-2" target="_blank">链接</a>