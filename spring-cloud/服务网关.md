## 网关概念

---

### 一、核心概念：什么是微服务网关？

想象一下一个大型购物中心（你的微服务系统）：
*   里面有成千上万个独立的专卖店（每个专卖店就是一个**微服务**），比如服装店、餐厅、电影院、书店等。
*   如果顾客（**客户端**，比如手机APP或网页）想逛遍所有店，就需要知道每个店的具体位置（**IP地址和端口**），并且要分别进入每个店，这非常麻烦。

那么，购物中心会怎么做呢？它会建立一个**统一的入口大厅**（这就是**API网关**）！
*   所有顾客都从这个大厅进入。
*   大厅里有清晰的指示牌，告诉顾客想去服装店该怎么走，想去餐厅该怎么走。
*   大厅还可能提供一些通用服务，比如问询处、安全检查、会员卡积分、存包处等。

**Spring Cloud Gateway 就是这个“统一的入口大厅”。** 它是微服务架构中的一个组件，为所有微服务提供了一个统一的入口点。客户端不再需要直接调用各个微服务，而是只与网关交互，由网关将请求路由到相应的后端服务。

---

### 二、为什么需要网关？它的主要作用（优点）

网关的核心价值在于**解耦**和**赋能**。它具体负责以下关键任务：

1.  **路由转发**
    *   **这是最核心的功能。** 网关根据请求的路径、参数、Header等信息，将请求智能地分发到对应的微服务实例。
    *   **举例：** 当收到 `/user/**` 的请求，网关会将其转发到“用户服务”；收到 `/order/**` 的请求，则转发到“订单服务”。客户端完全不需要知道后端有成百上千个服务。

2.  **身份认证和授权**
    *   **问题：** 如果每个微服务都自己处理登录验证、权限检查，会非常冗余且难以维护。
    *   **解决方案：** 网关作为统一入口，可以集中处理所有请求的认证和授权（比如校验 JWT 令牌）。只有合法的请求才会被转发到后端服务，这样业务微服务就可以更专注于业务逻辑。

3.  **流量控制与熔断降级**
    *   **问题：** 某个服务突然遇到大量请求，可能会被压垮（雪崩效应）。
    *   **解决方案：** 网关可以集成如 Sentinel 或 Hystrix 等组件，对特定服务进行限流（比如每秒只允许100个请求），防止服务崩溃。当某个服务不可用时，网关可以直接熔断，返回一个预设的友好提示（降级），而不是让请求一直等待导致超时。

4.  **日志记录与监控**
    *   所有请求都经过网关，这使得它成为一个收集全局日志和监控指标的绝佳位置。你可以轻松地统计访问量、延迟、成功率等，便于分析系统性能。

5.  **请求优化**
    *   **负载均衡：** 网关可以集成负载均衡器（如Ribbon），如果一个服务有多个实例，网关可以将请求均匀地分发到各个实例上，提高系统可用性。
    *   **请求/响应修改：** 网关可以在转发前给请求头添加一些信息（如用户ID），或者对响应结果进行简单的修改和过滤。

---

### 三、Spring Cloud Gateway 的技术特点

Spring Cloud 官方提供了两种网关组件，**Spring Cloud Gateway** 是新一代的产品，也是目前的主流选择。

*   **Spring Cloud Gateway（推荐）**
    *   **基于异步非阻塞模型：** 使用 Project Reactor 和 Netty 作为底层服务器，性能非常高，特别适合高并发场景。
    *   **功能强大：** 提供了路由、断言、过滤器等非常灵活和强大的功能。
    *   **易于扩展：** 可以方便地编写自定义的过滤器和断言逻辑。

*   **Zuul（旧版本，已逐步淘汰）**
    *   **基于同步阻塞模型：** 性能上不如 Gateway。
    *   Zuul 2.x 也开始支持异步非阻塞，但 Spring Cloud 官方已明确推荐使用 Gateway 作为未来技术方向。

---

### 四、一个简单的工作流程示例

假设你的系统有：
*   用户服务：运行在 `localhost:8001`
*   订单服务：运行在 `localhost:8002`

**没有网关时：**
*   客户端调用用户服务：`http://localhost:8001/user/1`
*   客户端调用订单服务：`http://localhost:8002/order/101`
*   客户端需要维护两个地址。

**有网关时（网关运行在 `localhost:8080`）：**
你在网关中配置两条路由规则：
1.  所有以 `/api/user/**` 开头的请求，都转发到 `用户服务（:8001）`。
2.  所有以 `/api/order/**` 开头的请求，都转发到 `订单服务（:8002）`。

**现在，客户端调用方式变为：**
*   调用用户服务：`http://localhost:8080/api/user/1`
*   调用订单服务：`http://localhost:8080/api/order/101`

对于客户端来说，它只需要和网关（`8080`端口）打交道，完全不知道用户服务和订单服务的存在。网关接收到请求后，会根据路径中的 `/api/user` 或 `/api/order` 正确地路由到对应的后端服务。

---

### 总结

| 角色                     | 类比                       | 作用                                                 |
| :----------------------- | :------------------------- | :--------------------------------------------------- |
| **微服务**               | 购物中心里的**专卖店**     | 提供具体的业务功能（用户管理、订单处理等）           |
| **客户端（APP/网页）**   | **购物顾客**               | 使用系统功能的用户                                   |
| **Spring Cloud Gateway** | 购物中心的**统一入口大厅** | **统一入口、路由转发、安全认证、流量控制、日志监控** |

简单来说，**Spring Cloud Gateway 是微服务架构的“门面”和“交警”，它让系统更安全、更健壮、更易于管理。** 对于任何具有一定复杂度的微服务系统，引入网关都是一个非常重要的架构决策。

## 开源网关的状态

`netflix zuul`（进入维护状态，被`springcloud`抛弃）、`netflix zuul2`（推迟上线计划，被`springcloud`抛弃）、`gateway`（`springcloud`自研新一代网关）

## Zuul网络通信原理

理解这个原理，关键在于区分两个角色：**Zuul 网关本身**和**其内部封装的网络通信组件**。

简单来说，Zuul 的核心是一个**请求路由和过滤器框架**，它本身并不直接处理底层的 HTTP 网络通信（如建立 TCP 连接、读写 Socket 等）。这些繁重的网络 I/O 工作，它委托给了内置的、成熟的 HTTP 客户端库来完成。

在 Zuul 1.x 和 Zuul 2.x 中，这个底层通信机制有根本性的不同，这也是理解其原理的重点。

---

### 核心通信模型：Zuul 1.x vs Zuul 2.x

#### 1. Zuul 1.x：阻塞 I/O 模型

Zuul 1.x 采用的是经典的、同步阻塞的 Request/Response 模型。

**通信原理流程：**

1.  **接收请求**：外部请求（例如来自浏览器或移动应用）到达 Zuul 网关。Zuul 运行在一个 Servlet 容器（如 Tomcat）中，容器的工作线程（如 Tomcat 的 HTTP 线程）被占用来处理这个请求。
2.  **预处理（过滤器）**：请求经过 Zuul 中定义的 `pre` 路由过滤器链，进行身份验证、日志记录、路由判断等操作。
3.  **转发请求**：Zuul 根据路由规则确定目标服务地址后，它会使用一个**阻塞式的 HTTP 客户端**（最常用的是 Apache HttpClient）来转发请求。
    *   主线程（Tomcat 线程）会**阻塞**地等待 HttpClient 去建立与下游服务的 TCP 连接。
    *   连接建立后，主线程继续**阻塞**地等待 HttpClient 将请求发送到下游服务。
4.  **等待响应**：请求发送完毕后，主线程**一直阻塞**，等待下游服务处理并返回响应。
5.  **接收响应**：下游服务的响应数据通过 HttpClient 接收后，主线程被唤醒。
6.  **后处理（过滤器）**：响应数据经过 Zuul 的 `post` 路由过滤器链，可能进行响应体修改、添加标准头信息等操作。
7.  **返回响应**：最终，Zuul 将处理后的响应返回给初始的客户端，此时 Tomcat 的工作线程才被释放，可以处理下一个请求。

**核心特点与优缺点：**

*   **模型简单**：编程模型直观，易于理解和调试。
*   **资源消耗大**：每个外部请求都会占用一个宝贵的容器工作线程，而该线程大部分时间都在“空闲”等待（等待下游服务响应）。在高并发场景下，线程数量会迅速增长，导致巨大的内存开销和频繁的线程上下文切换，成为性能瓶颈。
*   **通信组件**：通常使用 **Apache HttpClient** 或 **Ribbon**（其底层也常用 HttpClient）作为阻塞式 HTTP 客户端。



---

#### 2. Zuul 2.x：非阻塞 I/O 模型

为了克服 Zuul 1.x 的性能瓶颈，Netflix 重写了 Zuul，推出了基于 Netty 的异步非阻塞版本 Zuul 2.x。

**通信原理流程：**

1.  **接收请求**：Zuul 2.x 自身就是一个 Netty 服务器，它使用**少量的、可复用的 I/O 工作线程（EventLoop Group）** 来接收所有传入的客户端请求。这些线程只负责高效的网络 I/O 读写，不处理业务逻辑。
2.  **预处理（过滤器）**：请求被接收后，会提交给一个**异步的过滤器链**进行处理。Netty 的 I/O 线程会立即被释放去处理其他网络连接，不会被阻塞。
3.  **转发请求**：Zuul 2.x 使用一个**非阻塞的 HTTP 客户端**（同样是基于 Netty 构建的）来向下游服务转发请求。这个转发操作是异步的：发出请求后，立即返回一个 `Future` 或类似的异步对象，而不会阻塞任何线程。
4.  **等待响应**：下游服务处理请求时，Zuul 网关的线程（无论是 I/O 线程还是业务线程）**不会被阻塞**。它们可以自由地去处理其他任务。
5.  **接收响应**：当下游服务的响应数据包通过网络返回时，Netty 客户端会接收到它们，并触发一个**回调函数**。
6.  **后处理（过滤器）**：在回调函数中，响应被提交给 `post` 过滤器链进行异步处理。
7.  **返回响应**：最终，处理完成的响应通过 Netty 服务器写回给初始的客户端。

**核心特点与优缺点：**

*   **高并发、高性能**：使用少量线程即可处理大量并发连接。线程不再因等待 I/O 而被阻塞，资源利用率极高，非常适合高延迟、高并发的微服务网关场景。
*   **编程复杂**：异步回调（或响应式编程）模型比同步阻塞模型更复杂，调试难度也更高。
*   **通信组件**：前后端都使用 **Netty** 作为网络通信框架，实现了全链路的非阻塞。



---

### 总结对比

| 特性            | Zuul 1.x（阻塞式）                         | Zuul 2.x（非阻塞式）                       |
| :-------------- | :----------------------------------------- | :----------------------------------------- |
| **网络模型**    | 同步阻塞 I/O                               | 异步非阻塞 I/O                             |
| **线程模型**    | 每个请求占用一个线程（Thread-per-request） | 少量 I/O 线程处理所有连接（EventLoop）     |
| **核心通信库**  | Apache HttpClient, Ribbon（阻塞模式）      | Netty（服务器和客户端）                    |
| **吞吐量/资源** | 线程数是瓶颈，资源消耗大，吞吐量有限       | 资源利用率高，支持极高吞吐量               |
| **编程复杂度**  | 简单直观                                   | 相对复杂，基于回调/Future                  |
| **适用场景**    | 并发量不高，逻辑简单的场景                 | 高并发、低延迟要求严苛的云原生和微服务场景 |

### 补充说明：Spring Cloud Gateway

值得注意的是，由于 Zuul 2.x 的开发和开源进度问题，Spring 官方并没有在 Spring Cloud 中集成 Zuul 2，而是自己开发了一个更高性能的网关：**Spring Cloud Gateway**。

**Spring Cloud Gateway 的通信原理与 Zuul 2.x 类似：**
*   它也是基于 **Spring WebFlux**（一个响应式编程框架）构建的。
*   底层网络通信同样使用 **Netty**，实现了全异步非阻塞的处理模型。
*   因此，在技术选型上，Spring Cloud Gateway 通常被视为 Zuul 1.x 的现代化替代品，其性能远超 Zuul 1.x，与 Zuul 2.x 属于同一梯队。

### 结论

Zuul 网关的网络通信原理核心在于其 **I/O 模型**：
*   **Zuul 1.x** 采用**同步阻塞**模型，依赖容器线程和阻塞式 HTTP 客户端，简单但性能有瓶颈。
*   **Zuul 2.x** 采用**异步非阻塞**模型，基于 Netty 框架，用少量线程处理海量请求，实现了高性能和高吞吐量。

在实际应用中，对于新项目，通常更推荐使用基于同样非阻塞模型的 **Spring Cloud Gateway**。

## Zuul使用

### 代理请求到外部服务

详细用法请参考`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul`



运行示例步骤如下：

1. 先运行`demo-assistant-external-service`服务，此服务模拟提供上传和下载的外部服务。
2. 再运行`demo-zuul-service`服务后，执行其中`Tests.java`测试。

示例核心配置如下：

- `zuul`网关配置代理外部服务的上传和下载接口，`application.yaml`配置如下：

  ```yaml
  zuul:
    routes:
      # 代理上传和下载接口到外部服务
      demo-external-service-api-upload:
        path: /api/v1/upload
        url: http://localhost:18090
        strip-prefix: false
      demo-external-service-api-download:
        path: /api/v1/download/**
        url: http://localhost:18090
        strip-prefix: false
  ```

- `zuul`网关自定义`filter`在请求中注入外部服务的开发者`token`，代码如下：

  ```java
  package com.future.demo.spring.cloud.zuul;
  
  import com.netflix.zuul.ZuulFilter;
  import com.netflix.zuul.context.RequestContext;
  
  import javax.servlet.http.HttpServletRequest;
  import java.util.UUID;
  
  public class UploadAndDownloadFilter extends ZuulFilter {
  
      @Override
      public String filterType() {
          return "pre"; // 在请求被路由之前执行
      }
  
      @Override
      public int filterOrder() {
          return 1; // Filter的执行顺序
      }
  
      @Override
      public boolean shouldFilter() {
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
          // 基于请求URL或其他信息决定是否应用此Filter
          String requestURI = request.getRequestURI();
          // 仅对上传和下载接口应用此filter
          return requestURI.startsWith("/api/v1/upload") || requestURI.startsWith("/api/v1/download");
      }
  
      @Override
      public Object run() {
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
  
          // 添加一个名为"token"
          ctx.addZuulRequestHeader("token", UUID.randomUUID().toString());
  
          return null;
      }
  }
  ```

  ```java
  @Bean
  UploadAndDownloadFilter uploadAndDownloadFilter() {
      return new UploadAndDownloadFilter();
  }
  ```



### 路径重写（Path Rewriting）

>[How to change service path in Zuul route](https://github.com/spring-cloud/spring-cloud-netflix/issues/1893)

把 /api/v1/hello 开头的请求路径重写为 /api/v1/a/b/hello 路径

```java
@Component
public class PathRewriteZuulFilter extends ZuulFilter {
    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return PreDecorationFilter.FILTER_ORDER + 1;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        String originalRequestPath = (String) context.get(REQUEST_URI_KEY);
        // 只过滤 /api/v1/hello 开始的请求
        return originalRequestPath.startsWith("/api/v1/hello");
    }

    @Override
    public Object run() {
        RequestContext context = RequestContext.getCurrentContext();
        String originalRequestPath = (String) context.get(REQUEST_URI_KEY);
        String modifiedRequestPath = "/api/v1/a/b" + originalRequestPath.replace("/api/v1/hello", StringUtils.EMPTY);
        context.put(REQUEST_URI_KEY, modifiedRequestPath);
        return null;
    }
}
```

application.yaml 配置如下：

```yaml
zuul:
  routes:
    helloworld:
      path: /api/v1/hello/**
      service-id: helloworld
      strip-prefix: false
```

详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul/demo-zuul-service)

### strip-prefix

`strip-prefix` 的作用是**在处理路由转发时，决定是否（以及多少）从请求路径中剥离（去除）掉在网关上配置的前缀**。

---

#### 核心作用：路径重写

简单来说，`strip-prefix` 就像一个“路径剪刀”，它的存在是为了解决一个常见问题：**网关路径与微服务路径不匹配**。

*   **网关路径**：暴露给外部客户端的、相对较长的路径。
*   **微服务路径**：微服务内部实际的、相对较短的路径。

`strip-prefix` 的功能就是在将请求转发给下游微服务之前，剪掉网关路径中多余的部分，使得微服务能接收到它期望的正确路径。

---

#### 场景示例：一看就懂

假设我们有一个用户服务，它提供了一个获取用户信息的接口，真实端点如下：
`http://user-service/user/info/1`

但我们不希望外部直接访问这个地址，而是希望通过网关来访问。

##### 场景一：不使用 `strip-prefix`（或设置为 `false`）

**网关路由配置**：
```yaml
zuul:
  routes:
    user-service:
      path: /api/user/**   # 网关暴露的长路径
      url: http://localhost:8081 # 用户服务地址
      strip-prefix: false  # 明确指定不剥离前缀
```

**访问网关的请求**：
`GET http://gateway:port/api/user/user/info/1`

**转发到用户服务的实际请求**：
`http://localhost:8081/api/user/user/info/1`

**结果分析**：
由于没有剥离前缀 `/api/user`，这个部分被原封不动地带到了用户服务。用户服务收到的路径是 `/api/user/user/info/1`，但它并不认识 `/api/user` 这个路径，很可能返回 **404 Not Found**。

##### 场景二：使用 `strip-prefix: true`（Zuul 1.x 常见配置）

**网关路由配置**：
```yaml
zuul:
  routes:
    user-service:
      path: /api/user/**   # 网关暴露的长路径
      url: http://localhost:8081 # 用户服务地址
      strip-prefix: true   # 【关键】启用剥离前缀
```

**访问网关的请求**：
`GET http://gateway:port/api/user/user/info/1`

**转发到用户服务的实际请求**：
`http://localhost:8081/user/info/1`

**结果分析**：
当 `strip-prefix` 设置为 `true` 时，Zuul 会自动**剥离掉路由配置中 `path` 定义的那部分路径（即 `/api/user`）**。剩下的部分 `/user/info/1` 被拼接到目标服务地址上。这样，用户服务就能正确识别路径并返回结果了。

**剥离过程图解**：
`/api/user/user/info/1`  --(剥离 `/api/user`)--> `/user/info/1`

---

#### 总结

| 配置                            | 作用                                                     | 适用场景                                                |
| :------------------------------ | :------------------------------------------------------- | :------------------------------------------------------ |
| `strip-prefix: false`           | **保留完整路径**。将客户端请求的路径原样转发给下游服务。 | 下游服务能识别网关的完整路径，通常不常用。              |
| `strip-prefix: true` (Zuul 1.x) | **剥离路由前缀**。自动去掉路由 `path` 中定义的整个前缀。 | 最常见的场景，用于将网关的“API上下文路径”对微服务隐藏。 |

**核心价值**：`strip-prefix` 实现了**路径解耦**。客户端通过网关访问的路径可以与微服务内部的路径完全不同，网关负责这中间的转换工作，使得微服务无需关心自己在网关上是如何被暴露的，提升了系统的灵活性和可维护性。

#### 示例

>详细用法请参考本站示例：https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-zuul/demo-zuul-service

zuul的application.yaml配置如下：

```yaml
zuul:
  routes:
    helloworld-without-filter:
      path: /api/v1/helloWithoutFilter/**
      service-id: helloworld
      # 自动截断请求路径前缀/api/v1/helloWithoutFilter
      strip-prefix: true
```

helloworld微服务ApiController

```java
@RestController
public class ApiController {
    /**
     * 测试不带过滤器的接口
     *
     * @return
     */
    @GetMapping(value = "/sayHello", produces = MediaType.TEXT_PLAIN_VALUE)
    public String sayHelloWithoutFilter() {
        return "Hello Zuul without filter!";
    }

}
```

测试

```sh
curl http://localhost:8080/api/v1/helloWithoutFilter/sayHello
```

## Zuul性能测试


## Gateway

### 介绍

SpringCloud Gateway是Spring官方基于Spring 5.0、Spring Boot 2.0和Project Reactor等技术开发的网关，旨在为微服务架构提供简单、有效和统一的API路由管理方式。以下是关于SpringCloud Gateway的详细介绍：

一、主要特性

1. **非阻塞式API**：
   - Spring Cloud Gateway基于WebFlux框架实现，而WebFlux框架底层使用了高性能的Reactor模式通信框架Netty。这种非阻塞式通信方式使得Gateway在高并发场景下具有更好的性能表现。
2. **函数式编程端点**：
   - 通过使用Spring WebFlux的函数式编程模式定义路由端点，处理请求。
3. **集成Spring Cloud组件**：
   - Gateway可以与Eureka、Ribbon、Hystrix等Spring Cloud组件配合使用，实现服务发现、负载均衡、熔断等功能。
4. **动态路由**：
   - 支持根据请求属性匹配对应的路由，并可以基于注册中心的服务发现动态更新路由配置。
5. **丰富的过滤器**：
   - 提供了易于编写的Predicates（断言）和Filters（过滤器），可以作用于特定路由。过滤器可以在请求被路由前或之后对请求进行修改，实现如安全、访问超时设置、限流等横切与应用无关的功能。

二、核心组件

1. **Route（路由）**：
   - 网关配置的基本组成模块。一个Route模块由一个ID、一个目标URI、一组断言和一组过滤器组成。如果断言为真，则路由匹配，目标URI会被访问。
2. **Predicate（断言）**：
   - Predicate来自Java 8的接口，可以用来匹配来自HTTP请求的任何内容，例如headers或参数。接口包含多种默认方法，并将Predicate组合成复杂的逻辑（与、或、非），可以用于接口参数校验、路由转发判断等。
3. **Filter（过滤器）**：
   - 网关过滤器链中的过滤器有两种：GatewayFilter（路由过滤器）和GlobalFilter（全局过滤器）。GatewayFilter作用范围比较灵活，可以是任意指定的路由；而GlobalFilter作用范围是所有路由，不可配置。

三、工作原理

1. **请求处理流程**：
   - 客户端向Spring Cloud Gateway发出HTTP请求。
   - Gateway Handler Mapping判断请求与哪个路由匹配。
   - 将请求发送到对应的Gateway Web Handler。
   - Web Handler加载当前路由下需要执行的过滤器链，并按照顺序逐一执行过滤器。
   - 所有过滤器的pre逻辑都依次顺序执行通过后，请求被路由到微服务。
   - 微服务返回结果后，再倒序执行过滤器的post逻辑。
   - 最终将响应结果返回给客户端。
2. **过滤器执行逻辑**：
   - 在“pre”类型的过滤器中，可以实现参数校验、权限校验、流量监控、日志输出、协议转换等功能。
   - 在“post”类型的过滤器中，可以实现响应内容、响应头的修改，日志的输出、流量监控等功能。

四、应用场景

1. **API路由管理**：
   - 作为微服务架构的系统统一入口，提供内部服务的路由中转。
2. **安全控制**：
   - 在网关层实现身份验证和授权，确保只有合法的请求才能访问微服务。
3. **监控和日志**：
   - 收集和分析请求数据，为系统的运维和监控提供有力支持。
4. **流量控制**：
   - 限制请求的速率以保护后端服务，防止因过载而导致的服务不可用。
5. **熔断和降级**：
   - 在后端服务不可用时提供默认响应，确保系统的稳定性和可用性。

综上所述，SpringCloud Gateway作为Spring Cloud生态系统中的网关组件，具有高性能、易于集成和丰富的功能特性。它能够为微服务架构提供简单、有效和统一的API路由管理方式，并帮助开发者实现安全控制、监控日志、流量控制等关键功能。



### 基本配置和示例运行

>注意：项目引用 spring-cloud-starter-gateway 依赖后不能同时引用 spring-boot-starter-web 依赖。

详细用法请参考示例`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-gateway`

父 pom 依赖配置如下：

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.4.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2020.0.2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

SpringCloud Gateway 项目 pom 依赖配置如下：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

SpringCloud Gateway 项目启动类如下：

```java
@SpringBootApplication
public class ApplicationGateway {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationGateway.class, args);
    }
}
```

启动 ApplicationEureka、ApplicationGateway、ApplicationHelloworld 应用

访问`http://localhost:8080/`提示资源不存在表示 SpringCloud Gateway 配置并启动成功。



### 路由规则配置

application.properties 配置如下：

```properties
# 基本路由规则
spring.cloud.gateway.routes[0].id=test1
# 使用负载均衡算法发送请求到微服务service-helloworld
spring.cloud.gateway.routes[0].uri=lb://service-helloworld
# 使用Path route predicate匹配uri转发路由
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/test1

# 演示同时使用多个predicate
spring.cloud.gateway.routes[1].id=test2
spring.cloud.gateway.routes[1].uri=lb://service-helloworld
# 需要提供param1参数才路由
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/test2
spring.cloud.gateway.routes[1].predicates[1]=Query=param1

# 演示参数等于指定值才路由
spring.cloud.gateway.routes[2].id=test3
spring.cloud.gateway.routes[2].uri=lb://service-helloworld
# 指定param1=h1才路由
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/test3
spring.cloud.gateway.routes[2].predicates[1]=Query=param1,h1

# 演示header等于指定值才路由
spring.cloud.gateway.routes[3].id=test5
spring.cloud.gateway.routes[3].uri=lb://service-helloworld
# 指定header1=h2和header2=h3才路由
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/v1/test5
spring.cloud.gateway.routes[3].predicates[1]=Header=header1,h2
spring.cloud.gateway.routes[3].predicates[2]=Header=header2,h3

# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2

spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



### 谓词（Predicate）

#### Path

```properties
# 基本路由规则
spring.cloud.gateway.routes[0].id=test1
# 使用负载均衡算法发送请求到微服务service-helloworld
spring.cloud.gateway.routes[0].uri=lb://service-helloworld
# 使用Path route predicate匹配uri转发路由
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/test1
```

```properties
spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



#### Query

```properties
# 演示同时使用多个predicate
spring.cloud.gateway.routes[1].id=test2
spring.cloud.gateway.routes[1].uri=lb://service-helloworld
# 需要提供param1参数才路由
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/test2
spring.cloud.gateway.routes[1].predicates[1]=Query=param1
```

```properties
# 演示参数等于指定值才路由
spring.cloud.gateway.routes[2].id=test3
spring.cloud.gateway.routes[2].uri=lb://service-helloworld
# 指定param1=h1才路由
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/test3
spring.cloud.gateway.routes[2].predicates[1]=Query=param1,h1
```



#### Header

```properties
# 演示header等于指定值才路由
spring.cloud.gateway.routes[3].id=test5
spring.cloud.gateway.routes[3].uri=lb://service-helloworld
# 指定header1=h2和header2=h3才路由
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/v1/test5
spring.cloud.gateway.routes[3].predicates[1]=Header=header1,h2
spring.cloud.gateway.routes[3].predicates[2]=Header=header2,h3
```



### 过滤器（Filter）

>注意：predicate 不通过是不会调用 filter（包括全局、局部 filter）的

#### 内置 Filter - AddRequestHeader

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 内置 Filter - AddRequestParameter

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 内置 Filter - RemoveRequestParameter

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 全局 Filter

>使用 GlobalFilter 定义全局 filter
>
>每种全局 `Filter` 在 gateway 中只会有一个实例，会对所有的 `Route` 都生效。
>
>自定义GlobalFilter作为权限验证`https://www.pianshen.com/article/4176276100/`、`https://www.cnblogs.com/h--d/p/12741935.html`

MyGlobalFilter

```java
@Slf4j
@Component
public class MyGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String uri = exchange.getRequest().getURI().getPath();
        log.debug("请求前uri={},params={}", uri, exchange.getRequest().getQueryParams());
        Mono<Void> mono = chain.filter(exchange);
        log.debug("请求后response={}", exchange.getResponse());
        return mono;
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

使用全局 Filter 之需要注解其为 @Component 即可



#### 局部 Filter

>使用 AbstractGatewayFilterFactory 定义局部 filter
>
>路由 `Filter` 是针对 `Route` 进行配置的，不同的 `Route` 可以使用不同的参数，因此会创建不同的实例。
>
>注意:自定义局部 filter 命名规则为 XxxGatewayFilterFactory

MyGatewayFilterFactory

```java
@Slf4j
@Component
public class MyGatewayFilterFactory extends AbstractGatewayFilterFactory<Object> {

    final static ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    @Override
    public GatewayFilter apply(Object config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            String originalUri = request.getURI().getPath();
            String uri = originalUri.substring(1);
            String[] uriParts = uri.split("/", 2);
            if(uriParts.length<2) {
                ServerHttpResponse response = exchange.getResponse();
                response.setStatusCode(HttpStatus.BAD_REQUEST);
                response.getHeaders().setContentType(MediaType.APPLICATION_JSON);

                final String errMsg = "请求路径 " + originalUri + " 错误，例如: http://localhost:8080/obs-default-epu-555-33/2021-08-20/uuu-01.jpg" ;
                return response.writeWith(Mono.create(monoSink -> {
                    try {
                        Map<String, Object> errorResponseMap = new HashMap<>();
                        errorResponseMap.put("errorCode", 600);
                        errorResponseMap.put("errorMessage", errMsg);
                        String responseJSON = OBJECT_MAPPER.writeValueAsString(errorResponseMap);
                        DataBuffer dataBuffer = response.bufferFactory().wrap(responseJSON.getBytes(StandardCharsets.UTF_8));
                        monoSink.success(dataBuffer);
                    }
                    catch (Exception ex) {
                        log.error("对象输出异常", ex);
                        monoSink.error(ex);
                    }
                }));
            }

            String bucketName = uriParts[0];
            String objectName = uriParts[1];
            String obsPrefix = "obs-";
            bucketName = bucketName.substring(obsPrefix.length());
            try {
                objectName = URLEncoder.encode(objectName, StandardCharsets.UTF_8.name());
            } catch (UnsupportedEncodingException e) {
                log.error(e.getMessage(), e);
            }
            log.debug("bucketName=" + bucketName + ",objectName=" + objectName);

            request = request.mutate()
                    .uri(URI.create("/api/v1/oss/getObject"))
                    .header("bucketName", bucketName)
                    .header("objectName", objectName)
                    .build();
            return chain.filter(exchange.mutate().request(request).build());
        };
    }
}
```

使用 Filter

```properties
spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



### 和 Spring Security 集成

>todo 未做实验
