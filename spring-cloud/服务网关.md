## 网关概念

---

### 一、核心概念：什么是微服务网关？

想象一下一个大型购物中心（你的微服务系统）：
*   里面有成千上万个独立的专卖店（每个专卖店就是一个**微服务**），比如服装店、餐厅、电影院、书店等。
*   如果顾客（**客户端**，比如手机APP或网页）想逛遍所有店，就需要知道每个店的具体位置（**IP地址和端口**），并且要分别进入每个店，这非常麻烦。

那么，购物中心会怎么做呢？它会建立一个**统一的入口大厅**（这就是**API网关**）！
*   所有顾客都从这个大厅进入。
*   大厅里有清晰的指示牌，告诉顾客想去服装店该怎么走，想去餐厅该怎么走。
*   大厅还可能提供一些通用服务，比如问询处、安全检查、会员卡积分、存包处等。

**Spring Cloud Gateway 就是这个“统一的入口大厅”。** 它是微服务架构中的一个组件，为所有微服务提供了一个统一的入口点。客户端不再需要直接调用各个微服务，而是只与网关交互，由网关将请求路由到相应的后端服务。

---

### 二、为什么需要网关？它的主要作用（优点）

网关的核心价值在于**解耦**和**赋能**。它具体负责以下关键任务：

1.  **路由转发**
    *   **这是最核心的功能。** 网关根据请求的路径、参数、Header等信息，将请求智能地分发到对应的微服务实例。
    *   **举例：** 当收到 `/user/**` 的请求，网关会将其转发到“用户服务”；收到 `/order/**` 的请求，则转发到“订单服务”。客户端完全不需要知道后端有成百上千个服务。

2.  **身份认证和授权**
    *   **问题：** 如果每个微服务都自己处理登录验证、权限检查，会非常冗余且难以维护。
    *   **解决方案：** 网关作为统一入口，可以集中处理所有请求的认证和授权（比如校验 JWT 令牌）。只有合法的请求才会被转发到后端服务，这样业务微服务就可以更专注于业务逻辑。

3.  **流量控制与熔断降级**
    *   **问题：** 某个服务突然遇到大量请求，可能会被压垮（雪崩效应）。
    *   **解决方案：** 网关可以集成如 Sentinel 或 Hystrix 等组件，对特定服务进行限流（比如每秒只允许100个请求），防止服务崩溃。当某个服务不可用时，网关可以直接熔断，返回一个预设的友好提示（降级），而不是让请求一直等待导致超时。

4.  **日志记录与监控**
    *   所有请求都经过网关，这使得它成为一个收集全局日志和监控指标的绝佳位置。你可以轻松地统计访问量、延迟、成功率等，便于分析系统性能。

5.  **请求优化**
    *   **负载均衡：** 网关可以集成负载均衡器（如Ribbon），如果一个服务有多个实例，网关可以将请求均匀地分发到各个实例上，提高系统可用性。
    *   **请求/响应修改：** 网关可以在转发前给请求头添加一些信息（如用户ID），或者对响应结果进行简单的修改和过滤。

---

### 三、Spring Cloud Gateway 的技术特点

Spring Cloud 官方提供了两种网关组件，**Spring Cloud Gateway** 是新一代的产品，也是目前的主流选择。

*   **Spring Cloud Gateway（推荐）**
    *   **基于异步非阻塞模型：** 使用 Project Reactor 和 Netty 作为底层服务器，性能非常高，特别适合高并发场景。
    *   **功能强大：** 提供了路由、断言、过滤器等非常灵活和强大的功能。
    *   **易于扩展：** 可以方便地编写自定义的过滤器和断言逻辑。

*   **Zuul（旧版本，已逐步淘汰）**
    *   **基于同步阻塞模型：** 性能上不如 Gateway。
    *   Zuul 2.x 也开始支持异步非阻塞，但 Spring Cloud 官方已明确推荐使用 Gateway 作为未来技术方向。

---

### 四、一个简单的工作流程示例

假设你的系统有：
*   用户服务：运行在 `localhost:8001`
*   订单服务：运行在 `localhost:8002`

**没有网关时：**
*   客户端调用用户服务：`http://localhost:8001/user/1`
*   客户端调用订单服务：`http://localhost:8002/order/101`
*   客户端需要维护两个地址。

**有网关时（网关运行在 `localhost:8080`）：**
你在网关中配置两条路由规则：
1.  所有以 `/api/user/**` 开头的请求，都转发到 `用户服务（:8001）`。
2.  所有以 `/api/order/**` 开头的请求，都转发到 `订单服务（:8002）`。

**现在，客户端调用方式变为：**
*   调用用户服务：`http://localhost:8080/api/user/1`
*   调用订单服务：`http://localhost:8080/api/order/101`

对于客户端来说，它只需要和网关（`8080`端口）打交道，完全不知道用户服务和订单服务的存在。网关接收到请求后，会根据路径中的 `/api/user` 或 `/api/order` 正确地路由到对应的后端服务。

---

### 总结

| 角色                     | 类比                       | 作用                                                 |
| :----------------------- | :------------------------- | :--------------------------------------------------- |
| **微服务**               | 购物中心里的**专卖店**     | 提供具体的业务功能（用户管理、订单处理等）           |
| **客户端（APP/网页）**   | **购物顾客**               | 使用系统功能的用户                                   |
| **Spring Cloud Gateway** | 购物中心的**统一入口大厅** | **统一入口、路由转发、安全认证、流量控制、日志监控** |

简单来说，**Spring Cloud Gateway 是微服务架构的“门面”和“交警”，它让系统更安全、更健壮、更易于管理。** 对于任何具有一定复杂度的微服务系统，引入网关都是一个非常重要的架构决策。

## 开源网关的状态

`netflix zuul`（进入维护状态，被`springcloud`抛弃）、`netflix zuul2`（推迟上线计划，被`springcloud`抛弃）、`gateway`（`springcloud`自研新一代网关）

## Zuul网络通信原理

理解这个原理，关键在于区分两个角色：**Zuul 网关本身**和**其内部封装的网络通信组件**。

简单来说，Zuul 的核心是一个**请求路由和过滤器框架**，它本身并不直接处理底层的 HTTP 网络通信（如建立 TCP 连接、读写 Socket 等）。这些繁重的网络 I/O 工作，它委托给了内置的、成熟的 HTTP 客户端库来完成。

在 Zuul 1.x 和 Zuul 2.x 中，这个底层通信机制有根本性的不同，这也是理解其原理的重点。

---

### 核心通信模型：Zuul 1.x vs Zuul 2.x

#### 1. Zuul 1.x：阻塞 I/O 模型

Zuul 1.x 采用的是经典的、同步阻塞的 Request/Response 模型。

**通信原理流程：**

1.  **接收请求**：外部请求（例如来自浏览器或移动应用）到达 Zuul 网关。Zuul 运行在一个 Servlet 容器（如 Tomcat）中，容器的工作线程（如 Tomcat 的 HTTP 线程）被占用来处理这个请求。
2.  **预处理（过滤器）**：请求经过 Zuul 中定义的 `pre` 路由过滤器链，进行身份验证、日志记录、路由判断等操作。
3.  **转发请求**：Zuul 根据路由规则确定目标服务地址后，它会使用一个**阻塞式的 HTTP 客户端**（最常用的是 Apache HttpClient）来转发请求。
    *   主线程（Tomcat 线程）会**阻塞**地等待 HttpClient 去建立与下游服务的 TCP 连接。
    *   连接建立后，主线程继续**阻塞**地等待 HttpClient 将请求发送到下游服务。
4.  **等待响应**：请求发送完毕后，主线程**一直阻塞**，等待下游服务处理并返回响应。
5.  **接收响应**：下游服务的响应数据通过 HttpClient 接收后，主线程被唤醒。
6.  **后处理（过滤器）**：响应数据经过 Zuul 的 `post` 路由过滤器链，可能进行响应体修改、添加标准头信息等操作。
7.  **返回响应**：最终，Zuul 将处理后的响应返回给初始的客户端，此时 Tomcat 的工作线程才被释放，可以处理下一个请求。

**核心特点与优缺点：**

*   **模型简单**：编程模型直观，易于理解和调试。
*   **资源消耗大**：每个外部请求都会占用一个宝贵的容器工作线程，而该线程大部分时间都在“空闲”等待（等待下游服务响应）。在高并发场景下，线程数量会迅速增长，导致巨大的内存开销和频繁的线程上下文切换，成为性能瓶颈。
*   **通信组件**：通常使用 **Apache HttpClient** 或 **Ribbon**（其底层也常用 HttpClient）作为阻塞式 HTTP 客户端。



---

#### 2. Zuul 2.x：非阻塞 I/O 模型

为了克服 Zuul 1.x 的性能瓶颈，Netflix 重写了 Zuul，推出了基于 Netty 的异步非阻塞版本 Zuul 2.x。

**通信原理流程：**

1.  **接收请求**：Zuul 2.x 自身就是一个 Netty 服务器，它使用**少量的、可复用的 I/O 工作线程（EventLoop Group）** 来接收所有传入的客户端请求。这些线程只负责高效的网络 I/O 读写，不处理业务逻辑。
2.  **预处理（过滤器）**：请求被接收后，会提交给一个**异步的过滤器链**进行处理。Netty 的 I/O 线程会立即被释放去处理其他网络连接，不会被阻塞。
3.  **转发请求**：Zuul 2.x 使用一个**非阻塞的 HTTP 客户端**（同样是基于 Netty 构建的）来向下游服务转发请求。这个转发操作是异步的：发出请求后，立即返回一个 `Future` 或类似的异步对象，而不会阻塞任何线程。
4.  **等待响应**：下游服务处理请求时，Zuul 网关的线程（无论是 I/O 线程还是业务线程）**不会被阻塞**。它们可以自由地去处理其他任务。
5.  **接收响应**：当下游服务的响应数据包通过网络返回时，Netty 客户端会接收到它们，并触发一个**回调函数**。
6.  **后处理（过滤器）**：在回调函数中，响应被提交给 `post` 过滤器链进行异步处理。
7.  **返回响应**：最终，处理完成的响应通过 Netty 服务器写回给初始的客户端。

**核心特点与优缺点：**

*   **高并发、高性能**：使用少量线程即可处理大量并发连接。线程不再因等待 I/O 而被阻塞，资源利用率极高，非常适合高延迟、高并发的微服务网关场景。
*   **编程复杂**：异步回调（或响应式编程）模型比同步阻塞模型更复杂，调试难度也更高。
*   **通信组件**：前后端都使用 **Netty** 作为网络通信框架，实现了全链路的非阻塞。



---

### 总结对比

| 特性            | Zuul 1.x（阻塞式）                         | Zuul 2.x（非阻塞式）                       |
| :-------------- | :----------------------------------------- | :----------------------------------------- |
| **网络模型**    | 同步阻塞 I/O                               | 异步非阻塞 I/O                             |
| **线程模型**    | 每个请求占用一个线程（Thread-per-request） | 少量 I/O 线程处理所有连接（EventLoop）     |
| **核心通信库**  | Apache HttpClient, Ribbon（阻塞模式）      | Netty（服务器和客户端）                    |
| **吞吐量/资源** | 线程数是瓶颈，资源消耗大，吞吐量有限       | 资源利用率高，支持极高吞吐量               |
| **编程复杂度**  | 简单直观                                   | 相对复杂，基于回调/Future                  |
| **适用场景**    | 并发量不高，逻辑简单的场景                 | 高并发、低延迟要求严苛的云原生和微服务场景 |

### 补充说明：Spring Cloud Gateway

值得注意的是，由于 Zuul 2.x 的开发和开源进度问题，Spring 官方并没有在 Spring Cloud 中集成 Zuul 2，而是自己开发了一个更高性能的网关：**Spring Cloud Gateway**。

**Spring Cloud Gateway 的通信原理与 Zuul 2.x 类似：**
*   它也是基于 **Spring WebFlux**（一个响应式编程框架）构建的。
*   底层网络通信同样使用 **Netty**，实现了全异步非阻塞的处理模型。
*   因此，在技术选型上，Spring Cloud Gateway 通常被视为 Zuul 1.x 的现代化替代品，其性能远超 Zuul 1.x，与 Zuul 2.x 属于同一梯队。

### 结论

Zuul 网关的网络通信原理核心在于其 **I/O 模型**：
*   **Zuul 1.x** 采用**同步阻塞**模型，依赖容器线程和阻塞式 HTTP 客户端，简单但性能有瓶颈。
*   **Zuul 2.x** 采用**异步非阻塞**模型，基于 Netty 框架，用少量线程处理海量请求，实现了高性能和高吞吐量。

在实际应用中，对于新项目，通常更推荐使用基于同样非阻塞模型的 **Spring Cloud Gateway**。

## Zuul判断使用哪种负载均衡器

使用本站示例 https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul/demo-zuul-service 协助测试。

在项目根目录执行命令

```sh
$ mvn dependency:tree -Dincludes="*:*loadbalancer*"
[INFO] -----------------< com.future.demo:spring-cloud-zuul >------------------
[INFO] Building spring-cloud-zuul 1.0                                     [3/4]
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-dependency-plugin:3.0.2:tree (default-cli) @ spring-cloud-zuul ---
[INFO] com.future.demo:spring-cloud-zuul:jar:1.0
[INFO] \- org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:jar:2.0.0.RELEASE:compile
[INFO]    \- org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.0.0.RELEASE:compile
[INFO]       \- com.netflix.ribbon:ribbon-loadbalancer:jar:2.2.5:compile

```

没有输出spring-cloud-starter-loadbalancer表示没有使用LoadBalancer作为其负载均衡器。

在项目根目录执行命令

```sh
$ mvn dependency:tree -Dincludes="*:*ribbon*"
[INFO] -----------------< com.future.demo:spring-cloud-zuul >------------------
[INFO] Building spring-cloud-zuul 1.0                                     [3/4]
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-dependency-plugin:3.0.2:tree (default-cli) @ spring-cloud-zuul ---
[INFO] com.future.demo:spring-cloud-zuul:jar:1.0
[INFO] \- org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:jar:2.0.0.RELEASE:compile
[INFO]    +- org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.0.0.RELEASE:compile
[INFO]    |  \- org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.0.0.RELEASE:compile
[INFO]    +- org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.0.0.RELEASE:compile
[INFO]    |  +- com.netflix.ribbon:ribbon:jar:2.2.5:compile
[INFO]    |  |  \- com.netflix.ribbon:ribbon-transport:jar:2.2.5:runtime
[INFO]    |  +- com.netflix.ribbon:ribbon-core:jar:2.2.5:compile
[INFO]    |  +- com.netflix.ribbon:ribbon-httpclient:jar:2.2.5:compile
[INFO]    |  \- com.netflix.ribbon:ribbon-loadbalancer:jar:2.2.5:compile
[INFO]    \- com.netflix.ribbon:ribbon-eureka:jar:2.2.5:compile

```

上面输出spring-cloud-starter-netflix-ribbon表示使用Ribbon作为其负载均衡器。

## Zuul网关和Ribbon的关系

简单来说，**Zuul 是网关，负责“大门”的安检和路由；Ribbon 是客户端负载均衡器，负责“院内”的交通疏导。它们经常协同工作，Zuul 在将外部请求路由到内部微服务时，会利用 Ribbon 来实现负载均衡。**

下面我们来详细拆解它们的关系。

### 一、核心角色定位

1.  **Zuul（网关/门面 - API Gateway）**
    *   **角色**：系统的统一入口、流量网关。
    *   **核心功能**：
        *   **动态路由**：将外部请求根据特定规则（如URL路径）转发到内部对应的某个微服务集群。
        *   **身份认证与安全**：在网关层统一进行权限校验、安全控制，防止非法请求进入内部网络。
        *   **压力测试与金丝雀发布**：可以按权重将流量分发到不同版本的服务。
        *   **服务聚合与解耦**：可以聚合多个微服务的调用结果，对客户端透明。
        *   **监控与限流**：统一收集监控数据，并实施限流、熔断等保护措施。

2.  **Ribbon（客户端负载均衡器 - Client Side Load Balancer）**
    *   **角色**：进程内（in-process）的负载均衡器，嵌入在服务消费者内部。
    *   **核心功能**：
        *   **服务发现**：从服务注册中心（如Eureka）获取服务的可用实例列表。
        *   **负载均衡**：根据内置的负载均衡规则（如轮询、随机、根据响应时间加权等），从可用的实例列表中选择一个具体的实例地址。
        *   **它不直接对外提供端口，而是给服务调用者（如RestTemplate、Feign、Zuul）提供选择服务地址的能力。**

### 二、工作协作关系（经典Spring Cloud Netflix架构）

在微服务架构中，一个典型的请求流程如下，这清晰地展示了两者的协作：

**前提**：所有微服务（包括Zuul本身）都注册到服务注册中心（如Eureka）。

1.  **外部请求到达**：用户或客户端发送一个请求，例如 `GET /api/user-service/v1/users/123`。
2.  **Zuul 接收请求**：这个请求首先到达Zuul网关。Zuul根据预设的路由规则，解析出目标微服务名。例如，它配置了所有以 `/api/user-service/` 开头的请求，都应该转发给名为 `user-service` 的微服务集群。
3.  **Zuul 调用 Ribbon**：此时，Zuul需要知道“`user-service`”这个服务具体有哪些可用的实例（IP和端口）。Zuul本身不负责查找，而是**委托给内嵌的Ribbon客户端**。
4.  **Ribbon 执行负载均衡**：
    *   Ribbon联系服务注册中心（Eureka），获取 `user-service` 的所有健康实例列表，例如：`[192.168.1.10:8080, 192.168.1.11:8080, 192.168.1.12:8080]`。
    *   Ribbon根据配置的负载均衡策略（如轮询），从列表中选出一个实例，比如 `192.168.1.11:8080`。
5.  **Zuul 发起代理请求**：Zuul拿到Ribbon选择的具体地址后，将原始请求转发到 `http://192.168.1.11:8080/v1/users/123`。
6.  **响应返回**：`user-service` 处理请求并返回结果，结果经由Zuul再返回给原始客户端。

**可以这样比喻：**

*   **Zuul 就像公司大门的保安和前台**：
    *   他收到一个快递，收件人写的是“技术部-Java组”（这相当于路由规则 `/api/user-service/**`）。
    *   他并不知道Java组具体坐在哪个工位。
*   **Ribbon 就像公司内部的座机表/导航系统**：
    *   保安前台查询内部导航系统（Ribbon），问“Java组有哪些空位？”
    *   导航系统返回所有Java组成员的工位号（服务发现），并建议一个当前最不忙的工位（负载均衡），比如“A区-201工位”。
*   **协作**：保安（Zuul）根据导航系统（Ribbon）的建议，把快递送到了A区-201工位（具体的服务实例）。

### 三、关键总结

| 特性         | Zuul (网关)                                                  | Ribbon (负载均衡器)                                          |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **层级**     | 系统边缘，外部流量入口                                       | 系统内部，服务间调用                                         |
| **关注点**   | 路由、过滤、安全、监控、限流                                 | **服务发现**、**负载均衡算法**                               |
| **协作方式** | Zuul **依赖**并使用Ribbon来实现向**下游微服务**的路由和负载均衡。 | Ribbon为Zuul、Feign、RestTemplate等客户端**提供基础服务选址能力**。 |
| **独立性**   | 可以独立存在，但如果不集成Ribbon或类似组件，只能进行静态路由。 | 不能独立对外提供服务，必须嵌入到其他服务消费者中工作。       |

### 四、技术演进

需要注意的是，Spring Cloud Netflix系列组件（包括Zuul 1.x, Ribbon, Eureka等）已经进入维护模式。在更新的Spring Cloud Gateway中，其默认的负载均衡客户端不再是Ribbon，而是Spring Cloud **LoadBalancer**。

但**核心架构思想是完全一致的**：**API网关 + 客户端负载均衡器** 的协作模式没有改变。Spring Cloud Gateway 在路由到下游服务时，会通过 `ReactiveLoadBalancerClientFilter` 来调用 LoadBalancer 完成服务发现和负载均衡，其角色和当初 Zuul 调用 Ribbon 一模一样。

### 结论

Zuul 和 Ribbon 是微服务架构中不同层面但紧密协作的两个核心组件。**Zuul 负责宏观的流量管控和路由，Ribbon 负责微观的服务实例发现与选择。** 理解这种“网关依赖负载均衡器来完成高效路由”的关系，对于设计和理解微服务架构至关重要。

## Zuul网关和Hystrix的关系

简单来说，Zuul 网关和 Hystrix 在微服务架构中，尤其是在 Spring Cloud Netflix 套件中，是**紧密协作、相辅相成**的关系。它们共同为微服务系统提供了**入口流量管理**和**后端服务容错**的能力。

下面我们来详细分解它们的关系。

### 核心关系概括

1.  **职责不同，但目标一致**：它们的最终目标都是提升整个微服务架构的**可靠性（Reliability）**、**弹性（Resiliency）** 和**容错能力（Fault Tolerance）**。
2.  **Zuul 是流量的入口，Hystrix 是服务的盾牌**：Zuul 作为网关，是所有外部请求的第一个接触点；而 Hystrix 作为容错库，保护的是 Zuul 本身以及 Zuul 所代理的后端微服务，防止单个服务的故障导致整个系统雪崩。
3.  **Zuul 集成 Hystrix**：在 Spring Cloud 的体系中，Zuul 默认就集成了 Hystrix。这意味着，**每一个通过 Zuul 路由到后端服务的请求，默认都会被一个 Hystrix 命令所包裹**。

---

### 各自的核心职责

在深入理解关系前，先明确它们各自的角色：

#### Zuul（网关）的核心职责：
*   **动态路由**：将外部请求智能地路由到相应的后端微服务。
*   **身份认证与安全**：在网关层统一进行权限校验，保护后端服务。
*   **压力测试与金丝雀发布**：可以按权重将流量分发到不同版本的服务。
*   **服务聚合**：将多个后端服务的结果聚合后返回给客户端。
*   **监控**：在网关层面收集监控数据。

#### Hystrix（容错库）的核心职责：
*   **断路器模式**：当对某个服务的调用失败率达到阈值时，断路器会打开，在指定时间内所有调用会立即失败（快速失败），不再请求该服务，从而避免资源耗尽。
*   **服务降级**：当服务调用失败（超时、异常、断路器打开）时，执行一个预设的降级方法，返回一个托底数据（fallback response），保证用户体验。
*   **资源隔离**：通过线程池隔离或信号量隔离，将不同的远程服务调用隔离开来。即使某个服务线程池被耗尽，也不会影响其他服务的调用。
*   **监控与度量**：收集各项指标，并通过 Hystrix Dashboard 进行近乎实时的监控。

---

### 它们如何协同工作？

结合上面的职责，我们可以描绘出一个典型的协作场景：

1.  **请求到达**：一个外部 HTTP 请求到达 Zuul 网关。
2.  **Zuul 路由**：Zuul 根据预设的路由规则，确定这个请求应该被转发到哪个后端微服务（例如 `user-service`）。
3.  **Hystrix 介入**：在 Zuul 准备发起对 `user-service` 的调用时，这个调用**自动被包装在一个 Hystrix Command 中执行**。
4.  **正常流程**：如果 `user-service` 在短时间内（默认1秒）正常响应，Hystrix 会让调用成功通过，Zuul 将结果返回给客户端。
5.  **异常流程 - 这是 Hystrix 发挥价值的地方**：
    *   **场景A：服务响应慢或超时**
        *   `user-service` 因高负载响应极其缓慢。
        *   Hystrix 会监测到调用超时（超过配置的阈值），它会**中断**这次调用，并抛出一个超时异常。
        *   随后，Hystrix 会**触发服务降级**。Zuul 可以配置一个降级逻辑，例如返回一个默认提示：`{"message": "用户服务暂时不可用，请稍后再试"}`。
    *   **场景B：服务持续失败（断路器打开）**
        *   在短时间内，对 `user-service` 的调用失败率（超时、500错误等）超过阈值（默认50%）。
        *   Hystrix 的**断路器会打开**。在接下来的一个时间窗口内（默认5秒），所有对 `user-service` 的请求都会**立即失败**，而根本不会真正发出网络请求。
        *   这些请求会直接执行降级逻辑。这给了故障服务恢复的时间，并防止连锁故障。
6.  **资源隔离**：对 `user-service` 的调用和对 `order-service` 的调用运行在**不同的 Hystrix 线程池**中。即使 `user-service` 不可用，占满了自己的线程池，也不会影响 Zuul 去调用正常的 `order-service`。

### 配置示例

在 Zuul 中，你可以为特定的路由配置 Hystrix 的降级逻辑：

```java
@Component
public class UserServiceFallbackProvider implements FallbackProvider {

    // 指定为哪个路由服务提供降级逻辑，返回 "*" 表示所有路由
    @Override
    public String getRoute() {
        return "user-service"; // 只针对名为 user-service 的路由
    }

    // 降级逻辑
    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {}

            @Override
            public InputStream getBody() throws IOException {
                // 返回降级内容
                return new ByteArrayInputStream("用户服务暂不可用".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}
```

### 总结

| 特性       | Zuul（网关）         | Hystrix（容错库）      | 协作关系                                   |
| :--------- | :------------------- | :--------------------- | :----------------------------------------- |
| **角色**   | 流量门卫、路由器     | 服务盾牌、保险丝       | Zuul 负责转发，Hystrix 保护转发过程        |
| **关注点** | 路由、过滤、安全     | 容错、隔离、降级、熔断 | 共同构建可靠的微服务边界                   |
| **关系**   | Hystrix 的**使用者** | 被 Zuul **集成和依赖** | Zuul 的每一次路由转发都受到 Hystrix 的保护 |

**一句话总结：Zuul 是系统的前沿阵地，负责接待和引导所有外部请求；而 Hystrix 则是阵地上部署的防御工事，确保当某个后方服务（微服务）被“攻破”（故障）时，故障不会蔓延到整个阵地（系统雪崩）。**

> **注意**：随着 Spring Cloud 的发展，Netflix 套件（包括 Zuul 1.x 和 Hystrix）已进入维护模式。官方推荐使用 **Spring Cloud Gateway**（替代 Zuul）和 **Resilience4j** 或 **Spring Cloud Circuit Breaker**（替代 Hystrix）。但 Zuul 与 Hystrix 的设计思想和协作模式在今天依然具有非常重要的学习和参考价值。

## Zuul怎么判断底层是使用httpclient通信

使用本站示例 https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul/demo-zuul-service 协助测试。

找出应用中httpclient的依赖：在应用的根目录执行下面命令

```sh
mvn dependency:tree -Dincludes="*:*httpclient*"
```

排除httpclient依赖：根据上面命令找出httpclient的依赖路径并排除

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

排除httpclient依赖后再启动应用，此时报告下面错误表示应用使用httpclient作为其底层通信

```

java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2]
	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:659) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:556) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:541) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.util.ReflectionUtils.getUniqueDeclaredMethods(ReflectionUtils.java:599) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(AbstractAutowireCapableBeanFactory.java:724) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:665) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:633) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1489) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:420) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:390) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:511) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:503) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1198) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	at org.springframework.boot.SpringApplication.getExitCodeFromMappedException(SpringApplication.java:889) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.getExitCodeFromException(SpringApplication.java:875) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.handleExitCode(SpringApplication.java:861) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:810) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]
	at com.future.demo.ApplicationZuul.main(ApplicationZuul.java:18) [classes/:na]
Caused by: java.lang.NoClassDefFoundError: org/apache/http/impl/client/CloseableHttpClient
	at java.lang.Class.getDeclaredMethods0(Native Method) ~[na:1.8.0_271]
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) ~[na:1.8.0_271]
	at java.lang.Class.getDeclaredMethods(Class.java:1975) ~[na:1.8.0_271]
	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:641) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]
	... 20 common frames omitted
Caused by: java.lang.ClassNotFoundException: org.apache.http.impl.client.CloseableHttpClient
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_271]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_271]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) ~[na:1.8.0_271]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[na:1.8.0_271]
	... 24 common frames omitted
```

## Zuul使用

### 代理请求到外部服务

详细用法请参考`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul`



运行示例步骤如下：

1. 先运行`demo-assistant-external-service`服务，此服务模拟提供上传和下载的外部服务。
2. 再运行`demo-zuul-service`服务后，执行其中`Tests.java`测试。

示例核心配置如下：

- `zuul`网关配置代理外部服务的上传和下载接口，`application.yaml`配置如下：

  ```yaml
  zuul:
    routes:
      # 代理上传和下载接口到外部服务
      demo-external-service-api-upload:
        path: /api/v1/upload
        url: http://localhost:18090
        strip-prefix: false
      demo-external-service-api-download:
        path: /api/v1/download/**
        url: http://localhost:18090
        strip-prefix: false
  ```

- `zuul`网关自定义`filter`在请求中注入外部服务的开发者`token`，代码如下：

  ```java
  package com.future.demo.spring.cloud.zuul;
  
  import com.netflix.zuul.ZuulFilter;
  import com.netflix.zuul.context.RequestContext;
  
  import javax.servlet.http.HttpServletRequest;
  import java.util.UUID;
  
  public class UploadAndDownloadFilter extends ZuulFilter {
  
      @Override
      public String filterType() {
          return "pre"; // 在请求被路由之前执行
      }
  
      @Override
      public int filterOrder() {
          return 1; // Filter的执行顺序
      }
  
      @Override
      public boolean shouldFilter() {
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
          // 基于请求URL或其他信息决定是否应用此Filter
          String requestURI = request.getRequestURI();
          // 仅对上传和下载接口应用此filter
          return requestURI.startsWith("/api/v1/upload") || requestURI.startsWith("/api/v1/download");
      }
  
      @Override
      public Object run() {
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
  
          // 添加一个名为"token"
          ctx.addZuulRequestHeader("token", UUID.randomUUID().toString());
  
          return null;
      }
  }
  ```

  ```java
  @Bean
  UploadAndDownloadFilter uploadAndDownloadFilter() {
      return new UploadAndDownloadFilter();
  }
  ```



### 路径重写（Path Rewriting）

>[How to change service path in Zuul route](https://github.com/spring-cloud/spring-cloud-netflix/issues/1893)

把 /api/v1/hello 开头的请求路径重写为 /api/v1/a/b/hello 路径

```java
@Component
public class PathRewriteZuulFilter extends ZuulFilter {
    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return PreDecorationFilter.FILTER_ORDER + 1;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        String originalRequestPath = (String) context.get(REQUEST_URI_KEY);
        // 只过滤 /api/v1/hello 开始的请求
        return originalRequestPath.startsWith("/api/v1/hello");
    }

    @Override
    public Object run() {
        RequestContext context = RequestContext.getCurrentContext();
        String originalRequestPath = (String) context.get(REQUEST_URI_KEY);
        String modifiedRequestPath = "/api/v1/a/b" + originalRequestPath.replace("/api/v1/hello", StringUtils.EMPTY);
        context.put(REQUEST_URI_KEY, modifiedRequestPath);
        return null;
    }
}
```

application.yaml 配置如下：

```yaml
zuul:
  routes:
    helloworld:
      path: /api/v1/hello/**
      service-id: helloworld
      strip-prefix: false
```

详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-zuul/demo-zuul-service)

### strip-prefix

`strip-prefix` 的作用是**在处理路由转发时，决定是否（以及多少）从请求路径中剥离（去除）掉在网关上配置的前缀**。

---

#### 核心作用：路径重写

简单来说，`strip-prefix` 就像一个“路径剪刀”，它的存在是为了解决一个常见问题：**网关路径与微服务路径不匹配**。

*   **网关路径**：暴露给外部客户端的、相对较长的路径。
*   **微服务路径**：微服务内部实际的、相对较短的路径。

`strip-prefix` 的功能就是在将请求转发给下游微服务之前，剪掉网关路径中多余的部分，使得微服务能接收到它期望的正确路径。

---

#### 场景示例：一看就懂

假设我们有一个用户服务，它提供了一个获取用户信息的接口，真实端点如下：
`http://user-service/user/info/1`

但我们不希望外部直接访问这个地址，而是希望通过网关来访问。

##### 场景一：不使用 `strip-prefix`（或设置为 `false`）

**网关路由配置**：
```yaml
zuul:
  routes:
    user-service:
      path: /api/user/**   # 网关暴露的长路径
      url: http://localhost:8081 # 用户服务地址
      strip-prefix: false  # 明确指定不剥离前缀
```

**访问网关的请求**：
`GET http://gateway:port/api/user/user/info/1`

**转发到用户服务的实际请求**：
`http://localhost:8081/api/user/user/info/1`

**结果分析**：
由于没有剥离前缀 `/api/user`，这个部分被原封不动地带到了用户服务。用户服务收到的路径是 `/api/user/user/info/1`，但它并不认识 `/api/user` 这个路径，很可能返回 **404 Not Found**。

##### 场景二：使用 `strip-prefix: true`（Zuul 1.x 常见配置）

**网关路由配置**：
```yaml
zuul:
  routes:
    user-service:
      path: /api/user/**   # 网关暴露的长路径
      url: http://localhost:8081 # 用户服务地址
      strip-prefix: true   # 【关键】启用剥离前缀
```

**访问网关的请求**：
`GET http://gateway:port/api/user/user/info/1`

**转发到用户服务的实际请求**：
`http://localhost:8081/user/info/1`

**结果分析**：
当 `strip-prefix` 设置为 `true` 时，Zuul 会自动**剥离掉路由配置中 `path` 定义的那部分路径（即 `/api/user`）**。剩下的部分 `/user/info/1` 被拼接到目标服务地址上。这样，用户服务就能正确识别路径并返回结果了。

**剥离过程图解**：
`/api/user/user/info/1`  --(剥离 `/api/user`)--> `/user/info/1`

---

#### 总结

| 配置                            | 作用                                                     | 适用场景                                                |
| :------------------------------ | :------------------------------------------------------- | :------------------------------------------------------ |
| `strip-prefix: false`           | **保留完整路径**。将客户端请求的路径原样转发给下游服务。 | 下游服务能识别网关的完整路径，通常不常用。              |
| `strip-prefix: true` (Zuul 1.x) | **剥离路由前缀**。自动去掉路由 `path` 中定义的整个前缀。 | 最常见的场景，用于将网关的“API上下文路径”对微服务隐藏。 |

**核心价值**：`strip-prefix` 实现了**路径解耦**。客户端通过网关访问的路径可以与微服务内部的路径完全不同，网关负责这中间的转换工作，使得微服务无需关心自己在网关上是如何被暴露的，提升了系统的灵活性和可维护性。

#### 示例

>详细用法请参考本站示例：https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-zuul/demo-zuul-service

zuul的application.yaml配置如下：

```yaml
zuul:
  routes:
    helloworld-without-filter:
      path: /api/v1/helloWithoutFilter/**
      service-id: helloworld
      # 自动截断请求路径前缀/api/v1/helloWithoutFilter
      strip-prefix: true
```

helloworld微服务ApiController

```java
@RestController
public class ApiController {
    /**
     * 测试不带过滤器的接口
     *
     * @return
     */
    @GetMapping(value = "/sayHello", produces = MediaType.TEXT_PLAIN_VALUE)
    public String sayHelloWithoutFilter() {
        return "Hello Zuul without filter!";
    }

}
```

测试

```sh
curl http://localhost:8080/api/v1/helloWithoutFilter/sayHello
```

## Zuul性能横向扩展能力

>使用本站示例 https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-zuul/demo-zuul-service 协助。

### 调试思路

如下：

- 测试微服务zuul和helloworld单实例性能。
- 测试微服务helloworld性能横向扩展能力。
- 测试微服务zuul性能横向扩展能力。
- 测试微服务helloworld和zuul性能同时横向扩展能力。

### 过程

测试硬件配置：

- Hypervisor:    VMware ESXi, 7.0.3, 20328353
- Model:    PowerEdge R740xd
- Processor Type:    Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz

测试虚拟机配置：zuul和helloword微服务使用实例为4C4G。

微服务zuul和helloworld单实例性能

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
Running 30s test @ http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   171.31ms   54.55ms   1.27s    83.09%
    Req/Sec     1.48k   192.40     2.13k    81.86%
  Latency Distribution
     50%  156.11ms
     75%  178.04ms
     90%  242.34ms
     99%  334.56ms
  352504 requests in 30.09s, 75.64MB read
Requests/sec:  11715.45
Transfer/sec:      2.51MB
```

微服务helloworld性能横向扩展能力：一个zuul实例，两个helloworld实例

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
Running 30s test @ http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   192.98ms  209.81ms   3.57s    98.54%
    Req/Sec     1.46k   166.58     2.10k    79.21%
  Latency Distribution
     50%  159.91ms
     75%  177.79ms
     90%  255.14ms
     99%  960.25ms
  349476 requests in 30.08s, 74.99MB read
Requests/sec:  11619.97
Transfer/sec:      2.49MB
```

测试微服务zuul性能横向扩展能力：两个zuul实例，一个helloworld实例

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
Running 30s test @ http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    98.64ms   44.79ms   1.08s    81.95%
    Req/Sec     2.57k   286.33     3.76k    77.79%
  Latency Distribution
     50%   85.63ms
     75%  109.81ms
     90%  156.10ms
     99%  245.01ms
  613050 requests in 30.08s, 131.55MB read
Requests/sec:  20377.94
Transfer/sec:      4.37MB
```

微服务helloworld和zuul性能同时横向扩展能力：两个zuul实例，两个helloworld实例

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
Running 30s test @ http://192.168.1.185/api/v1/helloWithoutFilter/sayHello
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    97.64ms   47.40ms 622.84ms   80.85%
    Req/Sec     2.65k   302.59     4.30k    80.38%
  Latency Distribution
     50%   80.80ms
     75%  106.94ms
     90%  168.32ms
     99%  260.42ms
  633025 requests in 30.07s, 135.83MB read
Requests/sec:  21050.36
Transfer/sec:      4.52MB
```

### 总结

结论：通过扩容zuul和helloworld实例能够实现横向扩展性能。

## Zuul性能调优

>提示：未完成完整的调优过程，只是尝试过Hystrix的信号量和线程调优，可以继续参考下面的思路完成完整的调优过程。
>
>说明：zuul一个实例，helloworld一个实例协助调优，虚拟机配置为4C6G。
>
>使用本站示例 https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-zuul/demo-zuul-service 协助调优。

思路如下：

- 调优方法：针对各类调优参数，例如：Ribbon和Hystrix，分别创建Ribbon和Hystrix示例专门用于各自的参数调优，把调优后的参数应用到zuul中。
- 调优微服务helloworld并测试其并发能力。
- 调优微服务zuul并测试其并发能力。
  - zuul参数调优。
  - tomcat参数调优。
  - hystrix参数调优。
  - 了解Zuul网关和Ribbon的关系。
  - Ribbon负载均衡器配置调优（需要证明配置生效）。


## Gateway

### 介绍

SpringCloud Gateway是Spring官方基于Spring 5.0、Spring Boot 2.0和Project Reactor等技术开发的网关，旨在为微服务架构提供简单、有效和统一的API路由管理方式。以下是关于SpringCloud Gateway的详细介绍：

一、主要特性

1. **非阻塞式API**：
   - Spring Cloud Gateway基于WebFlux框架实现，而WebFlux框架底层使用了高性能的Reactor模式通信框架Netty。这种非阻塞式通信方式使得Gateway在高并发场景下具有更好的性能表现。
2. **函数式编程端点**：
   - 通过使用Spring WebFlux的函数式编程模式定义路由端点，处理请求。
3. **集成Spring Cloud组件**：
   - Gateway可以与Eureka、Ribbon、Hystrix等Spring Cloud组件配合使用，实现服务发现、负载均衡、熔断等功能。
4. **动态路由**：
   - 支持根据请求属性匹配对应的路由，并可以基于注册中心的服务发现动态更新路由配置。
5. **丰富的过滤器**：
   - 提供了易于编写的Predicates（断言）和Filters（过滤器），可以作用于特定路由。过滤器可以在请求被路由前或之后对请求进行修改，实现如安全、访问超时设置、限流等横切与应用无关的功能。

二、核心组件

1. **Route（路由）**：
   - 网关配置的基本组成模块。一个Route模块由一个ID、一个目标URI、一组断言和一组过滤器组成。如果断言为真，则路由匹配，目标URI会被访问。
2. **Predicate（断言）**：
   - Predicate来自Java 8的接口，可以用来匹配来自HTTP请求的任何内容，例如headers或参数。接口包含多种默认方法，并将Predicate组合成复杂的逻辑（与、或、非），可以用于接口参数校验、路由转发判断等。
3. **Filter（过滤器）**：
   - 网关过滤器链中的过滤器有两种：GatewayFilter（路由过滤器）和GlobalFilter（全局过滤器）。GatewayFilter作用范围比较灵活，可以是任意指定的路由；而GlobalFilter作用范围是所有路由，不可配置。

三、工作原理

1. **请求处理流程**：
   - 客户端向Spring Cloud Gateway发出HTTP请求。
   - Gateway Handler Mapping判断请求与哪个路由匹配。
   - 将请求发送到对应的Gateway Web Handler。
   - Web Handler加载当前路由下需要执行的过滤器链，并按照顺序逐一执行过滤器。
   - 所有过滤器的pre逻辑都依次顺序执行通过后，请求被路由到微服务。
   - 微服务返回结果后，再倒序执行过滤器的post逻辑。
   - 最终将响应结果返回给客户端。
2. **过滤器执行逻辑**：
   - 在“pre”类型的过滤器中，可以实现参数校验、权限校验、流量监控、日志输出、协议转换等功能。
   - 在“post”类型的过滤器中，可以实现响应内容、响应头的修改，日志的输出、流量监控等功能。

四、应用场景

1. **API路由管理**：
   - 作为微服务架构的系统统一入口，提供内部服务的路由中转。
2. **安全控制**：
   - 在网关层实现身份验证和授权，确保只有合法的请求才能访问微服务。
3. **监控和日志**：
   - 收集和分析请求数据，为系统的运维和监控提供有力支持。
4. **流量控制**：
   - 限制请求的速率以保护后端服务，防止因过载而导致的服务不可用。
5. **熔断和降级**：
   - 在后端服务不可用时提供默认响应，确保系统的稳定性和可用性。

综上所述，SpringCloud Gateway作为Spring Cloud生态系统中的网关组件，具有高性能、易于集成和丰富的功能特性。它能够为微服务架构提供简单、有效和统一的API路由管理方式，并帮助开发者实现安全控制、监控日志、流量控制等关键功能。



### 基本配置和示例运行

>注意：项目引用 spring-cloud-starter-gateway 依赖后不能同时引用 spring-boot-starter-web 依赖。

详细用法请参考示例`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-gateway`

父 pom 依赖配置如下：

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.4.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2020.0.2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

SpringCloud Gateway 项目 pom 依赖配置如下：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

SpringCloud Gateway 项目启动类如下：

```java
@SpringBootApplication
public class ApplicationGateway {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationGateway.class, args);
    }
}
```

启动 ApplicationEureka、ApplicationGateway、ApplicationHelloworld 应用

访问`http://localhost:8080/`提示资源不存在表示 SpringCloud Gateway 配置并启动成功。



### 路由规则配置

application.properties 配置如下：

```properties
# 基本路由规则
spring.cloud.gateway.routes[0].id=test1
# 使用负载均衡算法发送请求到微服务service-helloworld
spring.cloud.gateway.routes[0].uri=lb://service-helloworld
# 使用Path route predicate匹配uri转发路由
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/test1

# 演示同时使用多个predicate
spring.cloud.gateway.routes[1].id=test2
spring.cloud.gateway.routes[1].uri=lb://service-helloworld
# 需要提供param1参数才路由
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/test2
spring.cloud.gateway.routes[1].predicates[1]=Query=param1

# 演示参数等于指定值才路由
spring.cloud.gateway.routes[2].id=test3
spring.cloud.gateway.routes[2].uri=lb://service-helloworld
# 指定param1=h1才路由
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/test3
spring.cloud.gateway.routes[2].predicates[1]=Query=param1,h1

# 演示header等于指定值才路由
spring.cloud.gateway.routes[3].id=test5
spring.cloud.gateway.routes[3].uri=lb://service-helloworld
# 指定header1=h2和header2=h3才路由
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/v1/test5
spring.cloud.gateway.routes[3].predicates[1]=Header=header1,h2
spring.cloud.gateway.routes[3].predicates[2]=Header=header2,h3

# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2

spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



### 谓词（Predicate）

#### Path

```properties
# 基本路由规则
spring.cloud.gateway.routes[0].id=test1
# 使用负载均衡算法发送请求到微服务service-helloworld
spring.cloud.gateway.routes[0].uri=lb://service-helloworld
# 使用Path route predicate匹配uri转发路由
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/test1
```

```properties
spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



#### Query

```properties
# 演示同时使用多个predicate
spring.cloud.gateway.routes[1].id=test2
spring.cloud.gateway.routes[1].uri=lb://service-helloworld
# 需要提供param1参数才路由
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/test2
spring.cloud.gateway.routes[1].predicates[1]=Query=param1
```

```properties
# 演示参数等于指定值才路由
spring.cloud.gateway.routes[2].id=test3
spring.cloud.gateway.routes[2].uri=lb://service-helloworld
# 指定param1=h1才路由
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/test3
spring.cloud.gateway.routes[2].predicates[1]=Query=param1,h1
```



#### Header

```properties
# 演示header等于指定值才路由
spring.cloud.gateway.routes[3].id=test5
spring.cloud.gateway.routes[3].uri=lb://service-helloworld
# 指定header1=h2和header2=h3才路由
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/v1/test5
spring.cloud.gateway.routes[3].predicates[1]=Header=header1,h2
spring.cloud.gateway.routes[3].predicates[2]=Header=header2,h3
```



### 过滤器（Filter）

>注意：predicate 不通过是不会调用 filter（包括全局、局部 filter）的

#### 内置 Filter - AddRequestHeader

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 内置 Filter - AddRequestParameter

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 内置 Filter - RemoveRequestParameter

```properties
# AddRequestHeader、AddRequestParameter filter
spring.cloud.gateway.routes[4].id=test6
spring.cloud.gateway.routes[4].uri=lb://service-helloworld
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/test6
# 自动添加http头 header1=h1
spring.cloud.gateway.routes[4].filters[0]=AddRequestHeader=header1,h1
## 自动删除客户端传入的userId参数，防止注入userId参数
spring.cloud.gateway.routes[4].filters[1]=RemoveRequestParameter=userId
# 自动添加http参数 userId=2
spring.cloud.gateway.routes[4].filters[2]=AddRequestParameter=userId,2
```



#### 全局 Filter

>使用 GlobalFilter 定义全局 filter
>
>每种全局 `Filter` 在 gateway 中只会有一个实例，会对所有的 `Route` 都生效。
>
>自定义GlobalFilter作为权限验证`https://www.pianshen.com/article/4176276100/`、`https://www.cnblogs.com/h--d/p/12741935.html`

MyGlobalFilter

```java
@Slf4j
@Component
public class MyGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String uri = exchange.getRequest().getURI().getPath();
        log.debug("请求前uri={},params={}", uri, exchange.getRequest().getQueryParams());
        Mono<Void> mono = chain.filter(exchange);
        log.debug("请求后response={}", exchange.getResponse());
        return mono;
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

使用全局 Filter 之需要注解其为 @Component 即可



#### 局部 Filter

>使用 AbstractGatewayFilterFactory 定义局部 filter
>
>路由 `Filter` 是针对 `Route` 进行配置的，不同的 `Route` 可以使用不同的参数，因此会创建不同的实例。
>
>注意:自定义局部 filter 命名规则为 XxxGatewayFilterFactory

MyGatewayFilterFactory

```java
@Slf4j
@Component
public class MyGatewayFilterFactory extends AbstractGatewayFilterFactory<Object> {

    final static ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    @Override
    public GatewayFilter apply(Object config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            String originalUri = request.getURI().getPath();
            String uri = originalUri.substring(1);
            String[] uriParts = uri.split("/", 2);
            if(uriParts.length<2) {
                ServerHttpResponse response = exchange.getResponse();
                response.setStatusCode(HttpStatus.BAD_REQUEST);
                response.getHeaders().setContentType(MediaType.APPLICATION_JSON);

                final String errMsg = "请求路径 " + originalUri + " 错误，例如: http://localhost:8080/obs-default-epu-555-33/2021-08-20/uuu-01.jpg" ;
                return response.writeWith(Mono.create(monoSink -> {
                    try {
                        Map<String, Object> errorResponseMap = new HashMap<>();
                        errorResponseMap.put("errorCode", 600);
                        errorResponseMap.put("errorMessage", errMsg);
                        String responseJSON = OBJECT_MAPPER.writeValueAsString(errorResponseMap);
                        DataBuffer dataBuffer = response.bufferFactory().wrap(responseJSON.getBytes(StandardCharsets.UTF_8));
                        monoSink.success(dataBuffer);
                    }
                    catch (Exception ex) {
                        log.error("对象输出异常", ex);
                        monoSink.error(ex);
                    }
                }));
            }

            String bucketName = uriParts[0];
            String objectName = uriParts[1];
            String obsPrefix = "obs-";
            bucketName = bucketName.substring(obsPrefix.length());
            try {
                objectName = URLEncoder.encode(objectName, StandardCharsets.UTF_8.name());
            } catch (UnsupportedEncodingException e) {
                log.error(e.getMessage(), e);
            }
            log.debug("bucketName=" + bucketName + ",objectName=" + objectName);

            request = request.mutate()
                    .uri(URI.create("/api/v1/oss/getObject"))
                    .header("bucketName", bucketName)
                    .header("objectName", objectName)
                    .build();
            return chain.filter(exchange.mutate().request(request).build());
        };
    }
}
```

使用 Filter

```properties
spring.cloud.gateway.routes[5].id=router-service-helloworld-oss-getObject
spring.cloud.gateway.routes[5].uri=lb://service-helloworld
spring.cloud.gateway.routes[5].predicates[0]=Path=/obs-*/**
# filter My会自动查找 MyGatewayFilterFactory，即自定义局部filter命名规则为XxxGatewayFilterFactory
spring.cloud.gateway.routes[5].filters[0]=My
spring.cloud.gateway.routes[5].filters[1]=AddRequestHeader=header1,hvalue1
spring.cloud.gateway.routes[5].filters[2]=AddRequestParameter=param1,pvalue1
```



### 和 Spring Security 集成

>todo 未做实验
