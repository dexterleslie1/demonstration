## `Ribbon`

> 注意：停止更新，许多遗留项目还在使用，所以需要学习。
>
> `Ribbon`实现客户端的负载均衡：http://www.cnblogs.com/chry/p/7263281.html

进程内负载均衡（负载均衡 + RestTemplate ）。



### 运行示例

详细用法请参考[示例](https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-ribbon-parent)

启动`Consul`

```bash
docker compose up -d
```

启动`ApplicationRibbon`、`ApplicationHelloworld`（修改端口后启动两个`ApplicationHelloworld`应用）

访问 http://localhost:8081/api/v1/external/sayHello?name=Dexter 测试`Ribbon+RestTemplate`负载均衡。



### 基本配置

`POM`引入`Ribbon`依赖

```xml
<!-- SpringCloud Ribbon 客户端依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

`RestTemplate`使用`@LoadBalanced`注解

```java
/**
 * 无论是否何种Ribbon负载均衡算法都需要配置下面的RestTemplate
 * @return
 */
@Bean
@LoadBalanced
RestTemplate restTemplate() {
    return new RestTemplate();
}
```



#### 使用`IRule`替换负载均衡算法

> 默认负载均衡算法是`RoundRobinRule`

```java
// 注意：自动IRule一定需要放置到与Application启动类所在的包和子包外，例如：com.future.demo.myrule
// 否则@RibbonClient注解不生效
@Configuration
public class MyRuleRandom {
    @Bean
    public IRule rule() {
        // 随机选择服务负载均衡算法
        return new RandomRule();
    }
}

@SpringBootApplication
@RibbonClient(name = "spring-cloud-helloworld", configuration = MyRuleRandom.class)
@EnableDiscoveryClient
public class ApplicationRibbon {
    /**
     *
     * @param args
     */
    public static void main(String[] args) {
        SpringApplication.run(ApplicationRibbon.class, args);
    }

    /**
     * 无论是否何种Ribbon负载均衡算法都需要配置下面的RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```



#### 切换底层`HTTP`通讯为`Apache HttpClient`

`POM`配置

```xml
<!-- SpringCloud Ribbon 客户端依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
<!-- RestTemplate 默认使用 Java 标准库的 HttpURLConnection 作为底层 HTTP 通信实现 -->
<!-- 把底层 HTTP 通讯实现切换为 Apache HttpClient 需要先引入 org.apache.httpcomponents:httpclient -->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
</dependency>
```

`RestTemplate`创建方式修改如下：

```java
/**
 * 无论是否何种Ribbon负载均衡算法都需要配置下面的RestTemplate
 *
 * @return
 */
@Bean
@LoadBalanced
RestTemplate restTemplate() {
    // RestTemplate 默认使用 Java 标准库的 HttpURLConnection 作为底层 HTTP 通信实现
    // 通过下面的配置把 HTTP 通讯实现切换为 Apache HttpClient

    // 创建HttpClient连接池配置
    PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
    // 设置最大连接数
    connectionManager.setMaxTotal(65535);
    // 设置每个路由默认最大连接数
    connectionManager.setDefaultMaxPerRoute(65535);
    // 创建HttpClient
    CloseableHttpClient httpClient = HttpClientBuilder.create()
            .setConnectionManager(connectionManager)
            .build();
    // 使用HttpClient创建请求工厂
    HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();
    factory.setHttpClient(httpClient);
    // 连接超时5秒
    factory.setConnectTimeout(5000);
    // 读取超时10秒
    factory.setReadTimeout(10000);
    // 从连接池获取连接的超时时间
    factory.setConnectionRequestTimeout(10000);

    return new RestTemplate(factory);

    // 下面创建 RestTemplate 方式默认使用 Java 标准库的 HttpURLConnection 作为底层 HTTP 通信实现
    // 超时默认配置为无限制
    // return new RestTemplate();
}
```



#### 超时设置

```java
/**
 * 无论是否何种Ribbon负载均衡算法都需要配置下面的RestTemplate
 *
 * @return
 */
@Bean
@LoadBalanced
RestTemplate restTemplate() {
    // RestTemplate 默认使用 Java 标准库的 HttpURLConnection 作为底层 HTTP 通信实现
    // 通过下面的配置把 HTTP 通讯实现切换为 Apache HttpClient

    // 创建HttpClient连接池配置
    PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
    // 设置最大连接数
    connectionManager.setMaxTotal(65535);
    // 设置每个路由默认最大连接数
    connectionManager.setDefaultMaxPerRoute(65535);
    // 创建HttpClient
    CloseableHttpClient httpClient = HttpClientBuilder.create()
            .setConnectionManager(connectionManager)
            .build();
    // 使用HttpClient创建请求工厂
    HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();
    factory.setHttpClient(httpClient);
    // 连接超时5秒
    factory.setConnectTimeout(5000);
    // 读取超时10秒
    factory.setReadTimeout(10000);
    // 从连接池获取连接的超时时间
    factory.setConnectionRequestTimeout(10000);

    return new RestTemplate(factory);

    // 下面创建 RestTemplate 方式默认使用 Java 标准库的 HttpURLConnection 作为底层 HTTP 通信实现
    // 超时默认配置为无限制
    // return new RestTemplate();
}
```

请求接口会报告超时错误

```sh
curl http://localhost:8081/api/v1/external/sayHello\?name\=Dexter\&timeoutInMillis\=60000
```



## `LoadBalancer`



### 介绍

SpringCloud LoadBalancer是Spring Cloud提供的一个客户端负载均衡器，它取代了传统的Ribbon组件，为微服务架构提供了更加灵活和强大的负载均衡功能。以下是对SpringCloud LoadBalancer的详细解析：

**一、定义与职责**

负载均衡器（LoadBalancer）是一种网络设备或软件机制，用于分发传入的网络流量负载请求到多个后端目标服务器上，从而实现系统资源的均衡利用和提高系统的可用性和性能。SpringCloud LoadBalancer作为客户端负载均衡器，它的主要职责是根据配置的负载均衡策略，从服务注册中心获取的服务实例列表中选择一个实例来处理请求。

**二、工作原理**

客户端负载均衡是一种将请求分发到多个服务实例的机制。每个发起服务调用的客户端都存有完整的目标服务地址列表，根据配置的负载均衡策略，由客户端自己决定向哪台服务器发起调用。这种方式相较于传统的网关层负载均衡，具有网络开销小、配置灵活等优点。

在Spring Cloud中，当客户端发起服务调用请求时，请求首先到达带有`@LoadBalanced`注解的`RestTemplate`或`LBRestTemplate`。`RestTemplate`或`LBRestTemplate`接收到请求后，会先经过一系列的拦截器（Interceptor）处理，这些拦截器可以用于实现认证、限流等功能。拦截器处理完成后，请求会被传送到LoadBalancer组件。LoadBalancer会根据配置的负载均衡策略和后端服务实例列表，选择一个合适的目标服务器。选定的目标服务器地址将被封装在一个新的HTTP请求中，然后由LoadBalancer将这个新的HTTP请求返回给`RestTemplate`或`LBRestTemplate`。最后，`RestTemplate`或`LBRestTemplate`将根据LoadBalancer返回的地址信息，直接与服务网关交互并完成服务调用。

**三、负载均衡策略**

SpringCloud LoadBalancer支持多种负载均衡策略，以满足不同场景的需求。常见的负载均衡策略包括：

1. **轮询（Round Robin）**：按顺序将每个新请求分配给下一个服务器。当到达列表末尾时，它会重新开始。这是最简单的负载均衡策略，适用于服务器性能相似且负载相对均衡的情况。
2. **随机（Random）**：随机选择一个服务器来处理新的请求。适用于服务器数量较多且请求分布均匀的场景。
3. **最少连接（Least Connections）**：选择当前连接数最少的服务器来处理新的请求。这种方法考虑了服务器的当前负载，适用于请求处理时间波动较大的场景。
4. **加权轮询（Weighted Round Robin）**：给每个服务器分配一个权重，服务器的权重越高，分配给该服务器的请求就越多。适用于服务器性能不均或希望给特定服务器更多流量的情况。
5. **加权随机（Weighted Random）**：与加权轮询类似，但是按照权重值来随机选择后端服务器。也可以用来处理后端服务器性能不均衡的情况，但是分发更随机。
6. **最短响应时间（Shortest Response Time）**：测量每个后端服务器的响应时间，并将请求发送到响应时间最短的服务器。这可以确保客户端获得最快的响应，适用于要求低延迟的应用。
7. **IP哈希（IP Hash）**：使用客户端的IP地址来计算哈希值，然后将请求发送到与哈希值对应的后端服务器。这种策略可用于确保来自同一客户端的请求都被发送到同一台后端服务器，适用于需要会话保持的情况。

SpringCloud LoadBalancer默认的负载均衡策略是轮询。如果需要自定义负载均衡策略，可以实现`ReactorServiceInstanceLoadBalancer`接口，并在配置类中注册自定义的负载均衡器。

**四、配置与使用**

要配置和使用SpringCloud LoadBalancer，需要按照以下步骤进行：

1. **添加依赖**：确保项目包含SpringCloud LoadBalancer的依赖。如果使用Maven，可以在`pom.xml`文件中添加相应的依赖项。
2. **创建RestTemplate Bean**：在配置类中，创建一个带有`@LoadBalanced`注解的`RestTemplate` Bean。这个注解会告诉Spring Cloud使用LoadBalancer来处理该`RestTemplate`的请求。
3. **使用服务名称**：在请求URL中使用服务名称而不是具体的IP地址或主机名。例如，如果服务注册在Eureka上，并且服务名称为`my-service`，则请求URL应该是`http://my-service/some-endpoint`。

**五、优势与意义**

SpringCloud LoadBalancer通过客户端负载均衡的方式，实现了更加高效和灵活的服务调用方式。它具有以下优势：

1. **动态配置**：支持动态更新配置，当后端服务实例发生变化时，可以快速响应并调整负载均衡策略。
2. **健康检查**：通过内置的健康检查机制，自动识别并排除故障实例，保证服务的可用性。
3. **集成RestTemplate**：通过给`RestTemplate`打标签的方式，将其转化为经过负载均衡器处理的`LBRestTemplate`，实现了对现有代码的无侵入式改造。
4. **多种负载均衡策略**：支持多种负载均衡算法，以满足不同场景的需求。

总之，SpringCloud LoadBalancer是微服务架构中不可或缺的重要组件之一，对于提升系统的性能和稳定性具有重要意义。



### 运行示例

详细用法请参考示例`https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-loadbalancer-parent`

启动 Consul

```bash
docker compose up -d
```

启动 ApplicationLoadBalancer、ApplicationHelloworld（修改端口后启动两个 ApplicationHelloworld 应用）

访问`http://localhost:8081/api/v1/external/sayHello?name=Dexter`测试 LoadBalancer + RestTemplate 负载均衡。



### 基本配置

pom 引入 LoadBalancer 依赖

```xml
<!-- SpringCloud LoadBalancer 依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

RestTemplate 使用 @LoadBalanced 注解

```java
// 创建RestTemplate并开启负载均衡
@Bean
@LoadBalanced
RestTemplate restTemplate() {
    return new RestTemplate();
}
```



### 负载均衡算法切换

```java
@Configuration
@LoadBalancerClients(
        // spring-cloud-helloworld 使用 LoadBalancerConfig 配置的负载均衡算法 RoundRobinLoadBalancer
        @LoadBalancerClient(value = "spring-cloud-helloworld", configuration = LoadBalancerConfig.class))
public class LoadBalancerConfig {
    // 创建RestTemplate并开启负载均衡
    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @Bean
    ReactorLoadBalancer<ServiceInstance> loadBalancer(Environment environment,
                                                      LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        // 随机负载均衡算法
        /*return new RandomLoadBalancer(loadBalancerClientFactory
                .getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);*/
        // 轮询负载均衡算法
        return new RoundRobinLoadBalancer(loadBalancerClientFactory
                .getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);
    }
}
```



## `OpenFeign`

>参考链接：https://www.jianshu.com/p/c0cb63e7640c



### 概念

OpenFeign是一个声明式的Web服务客户端，它使得编写Web服务客户端变得更加容易。以下是对OpenFeign的详细介绍：

**一、简介与背景**

OpenFeign是在Spring Cloud生态系统中的一个组件，它整合了Ribbon（客户端负载均衡器）和Eureka（服务发现组件），从而简化了微服务之间的调用。通过定义一个接口并使用注解的方式，开发者可以轻松地创建一个Web服务客户端，而不需要编写大量的模板代码。OpenFeign会自动生成接口的实现类，并使用Ribbon来调用相应的服务。

**二、核心组件与功能**

OpenFeign的核心组件包括Encoder（编码器）、Decoder（解码器）、Contract（契约）等。这些组件共同协作，实现了对HTTP请求的封装和调用。其中：

- **Encoder**：负责将请求对象编码为HTTP请求体。
- **Decoder**：负责将HTTP响应体解码为响应对象。
- **Contract**：定义了OpenFeign的注解和它们的含义，例如@FeignClient注解用于声明一个Feign客户端。

**三、使用与配置**

1. **添加依赖**：在Spring Cloud项目中，使用OpenFeign首先需要添加相应的依赖。通常，这可以通过在pom.xml文件中添加spring-cloud-starter-openfeign依赖来实现。
2. **开启OpenFeign**：在主应用类上添加@EnableFeignClients注解，以启用OpenFeign的功能。
3. **创建Feign客户端接口**：通过定义一个接口，并使用@FeignClient注解来指定服务提供者的名称和URL，可以创建一个Feign客户端。在接口中，可以使用Spring MVC的注解来定义需要调用的HTTP方法和路径。
4. **配置**：OpenFeign提供了多种配置选项，以满足不同的需求。例如，可以通过配置文件或配置类来设置日志级别、连接超时时间和请求处理超时时间等。

**四、日志配置**

OpenFeign提供了日志打印功能，通过配置调整日志级别，开发者可以了解请求的细节。这有助于在调试和定位问题时获取更多的信息。日志级别包括：

- **NONE**：不记录任何信息（默认）。
- **BASIC**：仅记录请求方法、URL以及响应状态码和执行时间。
- **HEADERS**：除了记录BASIC级别的信息外，还会记录请求和响应的头信息。
- **FULL**：记录所有请求与响应的明细，包括头信息、请求体、元数据等。

**五、超时配置**

为了避免服务调用连接和处理时间超时，可以对Feign的连接超时时间和请求处理超时时间进行配置。这可以通过在配置类中定义Request.Options对象，或者在配置文件中指定相关属性来实现。

**六、优势与适用场景**

OpenFeign的优势在于其易用性、集成性和轻量级特性。它简化了微服务之间的调用，使得开发者可以更加专注于业务逻辑的实现。同时，由于与Spring Cloud的紧密集成，OpenFeign可以方便地利用Spring Cloud提供的各种功能，如熔断、限流等。这使得OpenFeign在构建轻量级的微服务架构时具有显著的优势。

然而，需要注意的是，OpenFeign可能不适合处理大量并发请求或复杂业务场景。在这些情况下，可能需要考虑使用更强大的RPC框架，如Dubbo等。

**七、总结**

OpenFeign是一个功能强大且易于使用的Web服务客户端，它简化了微服务之间的通信和调用。通过合理的配置和使用，OpenFeign可以帮助开发者构建高效、可靠的微服务架构。



### 运行示例

>详细用法请参考本站[示例1](https://gitee.com/dexterleslie/demonstration/tree/main/demo-spring-boot/demo-spring-boot-openfeign-client)
>
>详细用法请参考本站[示例2](https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-feign-demo)

启动`Consul`

```bash
docker compose up -d
```

启动`ApplicationConsumer`、`ApplicationProvider`（修改端口后启动两个应用）

访问 http://localhost:8080/api/v1/external/product/1 测试应用是否正常



### 基本配置

`POM`引用`SpringCloud OpenFeign`依赖

```xml
<!-- SpringCloud OpenFeign 依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <exclusions>
        <!-- 排除 Ribbon 以证明 OpenFeign + Consul 是依赖 SpringCloud LoadBalancer 提供的负载均衡算法支持 -->
        <exclusion>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-netflix-ribbon</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

创建`OpenFeign`客户端

```java
@FeignClient(
        contextId = "productFeign1",
        value = "spring-cloud-feign-demo-provider",
        path = "/api/v1/product")
public interface ProductFeign {
    @GetMapping("{productId}")
    ObjectResponse<Product> info(@PathVariable("productId") Integer productId) throws BusinessException;

    @GetMapping("get")
    Product get(@RequestParam(value = "productId", required = false) Integer productId);

    @PostMapping("add")
    String add(@RequestHeader(value = "customHeader") String customHeader,
               @RequestBody(required = false) Product product);

    @GetMapping("timeout")
    String timeout();
}
```

`Application`中启用`OpenFeign`客户端的支持

```java
@SpringBootApplication
// 应用程序中启用Feign客户端的支持
@EnableFeignClients(
        clients = {
                ProductFeign.class
        }
)
@EnableFutureExceptionHandler
public class ApplicationConsumer {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationConsumer.class, args);
    }
}
```

注入并调用`OpenFeign`客户端

```java
@Resource
ProductFeign productFeign;

@GetMapping("{productId}")
public ObjectResponse<Product> info(@PathVariable("productId") Integer productId) throws BusinessException {
    ObjectResponse<Product> response = this.productFeign.info(productId);
    return response;
}
```



### 负载均衡

org.springframework.boot:spring-boot-starter-parent:2.2.7.RELEASE + org.springframework.cloud:spring-cloud-dependencies:Hoxton.SR10 + OpenFeign + Eureka 默认使用 OpenFeign + Ribbon（为 OpenFeign 提供负载均衡算法支持），注意：使用 JMeter 压力测试才能够触发 Ribbon 负载均衡起作用。

org.springframework.boot:spring-boot-starter-parent:2.2.7.RELEASE + org.springframework.cloud:spring-cloud-dependencies:Hoxton.SR10 + OpenFeign + Consul 默认使用 OpenFeign + LoadBalancer（为 OpenFeign 提供负载均衡算法支持）。

访问`http://localhost:8080/api/v1/external/product/1`测试

### 怎么判断是使用Ribbon还是LoadBalancer负载均衡

在本站示例 https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-feign-demo 中Consumer微服务中修改POM如下：

```xml
<!-- SpringCloud Consul 客户端依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
    <exclusions>
        <!-- 排除 Ribbon 以证明 OpenFeign + Consul 是依赖 SpringCloud LoadBalancer 提供的负载均衡算法支持 -->
        <exclusion>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

启动应用后报告下面错误：

```
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2025-11-24 09:58:24.246 ERROR 1214568 --- [           main] o.s.boot.SpringApplication               : Application run failed

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'apiController': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.future.demo.spring.cloud.feign.common.feign.ProductFeign': Unexpected exception during bean creation; nested exception is java.lang.IllegalStateException: No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessProperties(CommonAnnotationBeanPostProcessor.java:321) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:895) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) [spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) [spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at com.future.demo.spring.cloud.feign.consumer.ApplicationConsumer.main(ApplicationConsumer.java:26) [classes/:na]
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.future.demo.spring.cloud.feign.common.feign.ProductFeign': Unexpected exception during bean creation; nested exception is java.lang.IllegalStateException: No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:530) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1306) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.autowireResource(CommonAnnotationBeanPostProcessor.java:521) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.getResource(CommonAnnotationBeanPostProcessor.java:497) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor$ResourceElement.getResourceToInject(CommonAnnotationBeanPostProcessor.java:650) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.annotation.InjectionMetadata$InjectedElement.inject(InjectionMetadata.java:239) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessProperties(CommonAnnotationBeanPostProcessor.java:318) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	... 17 common frames omitted
Caused by: java.lang.IllegalStateException: No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?
	at org.springframework.cloud.openfeign.FeignClientFactoryBean.loadBalance(FeignClientFactoryBean.java:341) ~[spring-cloud-openfeign-core-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.cloud.openfeign.FeignClientFactoryBean.getTarget(FeignClientFactoryBean.java:369) ~[spring-cloud-openfeign-core-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject(FeignClientFactoryBean.java:347) ~[spring-cloud-openfeign-core-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.cloud.openfeign.FeignClientsRegistrar.lambda$registerFeignClient$0(FeignClientsRegistrar.java:240) ~[spring-cloud-openfeign-core-2.2.7.RELEASE.jar:2.2.7.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1231) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1173) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]
	... 30 common frames omitted
```

因为spring-cloud-starter-netflix-ribbon和spring-cloud-starter-loadbalancer都被排除后没有负载均衡器，所以应用启动失败。

保留任意一种负载均衡器后重启应用不会再报错，说明应用此时使用保留的负载均衡器。

### 超时设置

org.springframework.boot:spring-boot-starter-parent:3.3.7 + org.springframework.cloud:spring-cloud-dependencies:2023.0.4 版本的 OpenFeign 超时设置

```properties
# 注意：org.springframework.boot:spring-boot-starter-parent:3.3.7 + org.springframework.cloud:spring-cloud-dependencies:2023.0.4 版本的 OpenFeign 超时设置
# 该属性控制Feign客户端在尝试连接到目标服务时等待响应的最长时间。如果在这个时间内没有成功建立连接，
# 则会抛出超时异常。这有助于防止客户端在目标服务不可用时长时间挂起，从而提高系统的健壮性和响应性。
# default 表示全局 OpenFeign 设置
spring.cloud.openfeign.client.config.default.connect-timeout=75000
# 该属性用于控制服务间调用的响应时间，防止因某个服务响应过慢而导致整个调用链路的阻塞或失败。
# 它确保了Feign客户端在发起远程HTTP请求时，能够根据预设的超时时间限制，及时终止那些响应过慢的请求，从而保护系统的稳定性和响应性。
# default 表示全局 OpenFeign 设置
spring.cloud.openfeign.client.config.default.read-timeout=75000

# 指定 productFeign1 Feign 的超时设置
spring.cloud.openfeign.client.config.productFeign1.connect-timeout=75000
spring.cloud.openfeign.client.config.productFeign1.read-timeout=75000
```

org.springframework.boot:spring-boot-starter-parent:2.2.7.RELEASE + org.springframework.cloud:spring-cloud-dependencies:Hoxton.SR10 版本的 OpenFeign 超时设置

```properties
# 注意：org.springframework.boot:spring-boot-starter-parent:2.2.7.RELEASE + org.springframework.cloud:spring-cloud-dependencies:Hoxton.SR10 版本的 OpenFeign 超时设置
feign.client.config.default.connect-timeout=75000
feign.client.config.default.read-timeout=75000
```

访问`http://localhost:8080/api/v1/external/product/timeout`测试



### 重试机制 - 固定间隔

配置如下：

```java
// 设置重试机制
@Bean
Retryer retryer() {
    // 不启用重试机制
    // return Retryer.NEVER_RETRY;
    // 每次重试的时间间隔为 1 秒，period 和 maxPeriod 设置为相等，最大重试次数为 3 次
    return new Retryer.Default(1000, 1000, 3);
}
```

访问`http://localhost:8080/api/v1/external/product/timeout`测试



`new Retryer.Default(1000, 1000, 3)` 这三个参数分别代表了重试策略的核心配置。我们来逐一分解：

**参数详解**

```java
new Retryer.Default(period, maxPeriod, maxAttempts)
```

1.  **`period` (第一个 1000)**
    *   **含义**：**初始重试间隔时间**。
    *   **单位**：毫秒（ms）。
    *   **解释**：当第一次调用失败后，进行第一次重试之前，需要等待的时间。这里设置为 1000 毫秒，也就是 **1 秒**。

2.  **`maxPeriod` (第二个 1000)**
    *   **含义**：**最大重试间隔时间**。
    *   **单位**：毫秒（ms）。
    *   **解释**：这是重试间隔时间的上限。如果重试策略是“指数退避”（即每次等待时间指数级增长），当计算出的等待时间超过这个值时，会使用这个最大值作为等待时间。
    *   **特别说明**：在您这个配置中，`period` (1000ms) 和 `maxPeriod` (1000ms) 被设置为**相等**。这意味着它**不是指数退避策略，而是固定间隔策略**。无论重试多少次，每次重试前的等待时间都是固定的 1 秒钟。

3.  **`maxAttempts` (3)**
    *   **含义**：**最大尝试次数（包括第一次调用）**。
    *   **解释**：这是最关键的一个参数。它指的是**总共允许进行多少次请求**。
        *   **第一次**：原始调用。
        *   如果失败，则进行**重试**。
    *   **计算**：最大重试次数 = `maxAttempts - 1`。
    *   **在您的例子中 (3)**：
        *   最多会发出 **3** 次请求。
        *   即：第 1 次调用失败后，最多会**重试 2 次**。

---

**工作流程示例**

假设您调用一个远程接口，但该接口因为网络波动或服务繁忙而失败。根据您的配置 `new Retryer.Default(1000, 1000, 3)`，Feign 的行为如下：

1.  **第一次请求**：发送请求 -> **失败**。
2.  **等待 1000ms (1秒)**。
3.  **第一次重试 (第2次请求)**：发送请求 -> **失败**。
4.  **等待 1000ms (1秒)**。
5.  **第二次重试 (第3次请求)**：发送请求 -> 如果成功，则返回结果；如果**再次失败**，Feign 会抛出异常，**停止重试**（因为总尝试次数已达到 `maxAttempts=3` 的限制）。

**总结**

您的配置 `new Retryer.Default(1000, 1000, 3)` 表示：

*   **重试策略**：固定间隔重试（非指数退避）。
*   **重试间隔**：每次重试前固定等待 **1秒钟**。
*   **重试次数**：最多**重试2次**（加上最初的1次调用，总共最多发起3次请求）。

**重要提示**

*   **幂等性**：重试机制**只适用于幂等操作**（如GET、PUT请求）。对于非幂等操作（如POST），重试可能导致数据重复创建，需要谨慎使用。
*   `Retryer.NEVER_RETRY`：这是一个安全的默认选项，表示任何失败都会立即抛出异常，不进行任何重试。在不确定下游服务是否幂等时，建议使用此选项。

### 重试机制 - 指数退避

要让 Feign 的重试机制实现**指数退避**，就需要让 `period` 和 `maxPeriod` 设置为**不同的值**。

**指数退避配置方法**

指数退避的核心思想是：**每次重试的等待时间随重试次数指数级增加，但不超过一个最大值**。这可以避免在服务短暂不可用时，客户端过多的重试请求对服务端造成“雪崩式”的冲击。

在 `Retryer.Default` 中，只需将 `period` 和 `maxPeriod` 设置为不同的值即可自动启用指数退避算法。

**修改后的配置示例：**

```java
@Bean
Retryer retryer() {
    // 初始间隔100ms，最大间隔3秒，最大尝试4次（即重试3次）
    return new Retryer.Default(100, 3000, 4);
}
```

---

**指数退避工作流程详解**

使用上面的配置 `new Retryer.Default(100, 3000, 4)`，重试过程如下：

1.  **第一次请求**：发送请求 -> **失败**。
2.  **第一次重试等待**：等待 `100ms`（初始间隔 `period`） -> 发起**第2次请求**。
3.  **第二次重试等待**：如果再次失败，等待时间 = `100ms * 1.5 = 150ms`（约为上次的1.5倍）-> 发起**第3次请求**。
4.  **第三次重试等待**：如果还失败，等待时间 = `150ms * 1.5 = 225ms` -> 发起**第4次请求**。
5.  如果第4次请求也失败，则不再重试（因为 `maxAttempts=4` 已用完），直接抛出异常。

**关键点**：每次的等待时间会以上一次的等待时间为基础，乘以一个系数（约为1.5）逐步递增，但**绝不会超过** `maxPeriod`（本例中为 3000ms）设置的最大值。

**更直观的配置对比**

| 配置                     | 重试策略     | 第一次重试等待 | 第二次重试等待 | 第三次重试等待 |
| :----------------------- | :----------- | :------------- | :------------- | :------------- |
| `Default(1000, 1000, 3)` | **固定间隔** | 1000 ms        | 1000 ms        | 1000 ms        |
| `Default(100, 3000, 4)`  | **指数退避** | 100 ms         | ~150 ms        | ~225 ms        |
| `Default(1000, 5000, 4)` | **指数退避** | 1000 ms        | ~1500 ms       | ~2250 ms       |

**总结**

要实现指数退避，关键在于：

1.  **设置 `period` < `maxPeriod`**。
2.  `period` 是**初始等待时间**。
3.  `maxPeriod` 是**等待时间的上限**。
4.  实际等待时间会以 `period` 为起点，每次重试后按一定倍数（~1.5）增长，直到达到 `maxPeriod` 后保持不变。

这种策略能更好地应对服务的短暂不可用，在“快速恢复”和“避免加重服务端压力”之间取得良好平衡。在生产环境中，指数退避通常是比固定间隔更推荐的做法。



### 替换底层使用 HttpClient5 通讯

pom 配置

```xml
<!-- 替换底层使用 HttpClient5 通讯依赖 -->
<dependency>
    <groupId>org.apache.httpcomponents.client5</groupId>
    <artifactId>httpclient5</artifactId>
</dependency>
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
</dependency>
```

修改 application.properties 替换 HttpClient5

```properties
# 替换底层使用 HttpClient5 通讯
spring.cloud.openfeign.httpclient.hc5.enabled=true
```

访问`http://localhost:8080/api/v1/external/product/timeout`测试，查看错误堆栈显示使用 HttpClient5 作为底层通讯组件。



### 日志级别设置

日志级别：

- NONE：不打印日志。
- BASIC：仅记录请求方法和URL以及响应状态码和执行时间。
- HEADERS：记录基本信息以及请求和响应标头。
- FULL：记录请求和响应的标头、正文和元数据。

application.properties 设置日志级别

```properties
# 配置 feign 客户端日志级别为 debug（只支持设置为 debug 级别），再配合使用 Logger.Level 设置不同的日志级别
# https://blog.csdn.net/weixin_43472934/article/details/122253068
logging.level.com.future.demo.spring.cloud.feign.common.feign=debug
```

Java 设置日志级别

```java
@Configuration
public class FeignConfig {
    // 设置 OpenFeign 日志级别
    @Bean
    Logger.Level feignLogLevel() {
        return Logger.Level.FULL;
    }
}
```

访问`http://localhost:8080/api/v1/external/product/1`测试



### 启用请求和响应压缩

application.properties 添加配置如下：

```properties
# 启用请求和响应压缩
spring.cloud.openfeign.compression.request.enabled=true
spring.cloud.openfeign.compression.response.enabled=true
spring.cloud.openfeign.compression.request.mime-types=text/xml,application/xml,application/json
spring.cloud.openfeign.compression.request.min-request-size=2048
```

访问`http://localhost:8080/api/v1/external/product/1`测试，如果请求头有 Accept-Encoding: gzip 和 Accept-Encoding: deflate 表示已经启用请求和响应压缩。



### 自定义请求拦截器并添加请求头和请求参数

定义请求拦截器

```java
/**
 * 所有feign调用http头都注入my-header参数
 * https://developer.aliyun.com/article/1058305
 */
@Slf4j
public class MyRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        template.header("my-header", "my-value");

        // https://stackoverflow.com/questions/559155/how-do-i-get-a-httpservletrequest-in-my-spring-beans
        if (RequestContextHolder.getRequestAttributes() != null) {
            HttpServletRequest request =
                    ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                            .getRequest();
            String contextUserId = request.getParameter("contextUserId");
            if (StringUtils.hasText(contextUserId)) {
                template.query("contextUserId", contextUserId);
                log.debug("feign客户端成功注入上下文参数，contextUserId={}", contextUserId);
            }
        }
    }
}
```

注入请求拦截器

```java
// 自定义 OpenFeign 请求拦截器
@Bean
RequestInterceptor requestInterceptor() {
    return new MyRequestInterceptor();
}
```

访问`http://localhost:8080/api/v1/external/product/1`测试，查看日志会输出请求头和请求参数值。



### Feign 客户端添加请求头

>使用 @RequestHeader 注解`https://www.cnblogs.com/laeni/p/12733920.html`

```java
@FeignClient(
        contextId = "productFeign1",
        value = "spring-cloud-feign-demo-provider",
        path = "/api/v1/product")
public interface ProductFeign {
    @PostMapping("add")
    String add(@RequestHeader(value = "customHeader") String customHeader,
               @RequestBody(required = false) Product product);
}
```

使用 curl 请求接口并查看日志输出的请求头

```bash
curl -X POST http://localhost:8080/api/v1/external/product/add
```



### 错误处理

OpenFeign是一个声明式的Web服务客户端，它使得写HTTP客户端变得更简单，主要用于微服务架构中，以简化服务间的调用。ErrorDecoder是OpenFeign中的一个重要接口，它在处理HTTP响应中的错误时发挥着关键作用。以下是对OpenFeign ErrorDecoder的详细解释：

**一、ErrorDecoder的作用**

ErrorDecoder接口用于处理HTTP响应中的错误。当OpenFeign客户端发送请求并接收到响应时，如果响应状态码表示错误（如4xx或5xx），则ErrorDecoder会被调用以决定是否将响应视为异常。通过自定义ErrorDecoder，可以对错误进行更精细的处理，比如根据不同的错误码返回不同的异常类型，或者在某些情况下忽略错误。

**二、可能使用ErrorDecoder的场景**

1. **特定错误码处理**：根据HTTP响应的不同错误码执行不同的逻辑。
2. **忽略某些错误**：在某些情况下，可能希望忽略某些特定的错误（如404 Not Found），并返回一个默认值或空对象，而不是抛出异常。
3. **增强错误日志**：通过自定义ErrorDecoder来增强错误日志，记录更多的上下文信息，以便于调试和监控。
4. **统一异常处理**：将HTTP错误转换为统一的异常类型，并在应用程序的其他部分进行捕获和处理。

**三、自定义ErrorDecoder的步骤**

1. **创建实现类**：创建一个实现ErrorDecoder接口的类。该类需要实现decode方法，该方法接收一个Response对象作为参数，并返回一个Exception对象。在decode方法中，可以根据响应的状态码和其他信息来决定是否将响应视为异常，并返回相应的异常类型。
2. **配置Feign客户端**：在Feign客户端的配置中指定自定义的ErrorDecoder。这通常是在一个带有@Configuration注解的配置类中，通过@Bean注解来定义一个ErrorDecoder类型的Bean。

**四、示例代码**

以下是一个自定义ErrorDecoder的示例代码：

```java
import feign.Response;
import feign.codec.DecodeException;
import feign.codec.ErrorDecoder;
import feign.RetryableException;
 
public class CustomErrorDecoder implements ErrorDecoder {
    @Override
    public Exception decode(Response response) {
        if (response.status() >= 400 && response.status() < 500) {
            // 处理客户端错误（如404, 401等）
            if (response.status() == 404) {
                return new ResourceNotFoundException("Resource not found");
            } else if (response.status() == 401) {
                return new UnauthorizedException("Unauthorized");
            }
            // 其他客户端错误可以统一处理或抛出异常
            return new DecodeException(response.request().toString(), response);
        } else if (response.status() >= 500) {
            // 处理服务器错误（如500, 502等）
            return new ServerErrorException("Server error");
        }
        // 对于成功的响应，返回null表示没有错误
        return null;
    }
 
    // 自定义异常类
    public static class ResourceNotFoundException extends RuntimeException {
        public ResourceNotFoundException(String message) {
            super(message);
        }
    }
 
    public static class UnauthorizedException extends RuntimeException {
        public UnauthorizedException(String message) {
            super(message);
        }
    }
 
    public static class ServerErrorException extends RuntimeException {
        public ServerErrorException(String message) {
            super(message);
        }
    }
}
```

然后，在Feign客户端的配置中指定这个自定义的ErrorDecoder：

```java
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
 
@Configuration
@EnableFeignClients
public class FeignConfig {
    @Bean
    public ErrorDecoder errorDecoder() {
        return new CustomErrorDecoder();
    }
}
```

**五、注意事项**

1. **执行顺序**：在OpenFeign中，如果同时存在自定义Decoder和ErrorDecoder，当调用服务出现异常时，会先执行ErrorDecoder来处理异常，并将处理结果返回给调用方。如果调用服务正常返回结果，则先执行自定义Decoder对返回结果进行处理。
2. **测试与验证**：为了测试并验证自定义ErrorDecoder是否正常工作，可以编写单元测试或集成测试来模拟不同的HTTP响应，并检查是否抛出了预期的异常。

通过以上步骤和示例代码，可以灵活地自定义OpenFeign中的ErrorDecoder来处理各种HTTP响应错误。



**自定义错误处理：**

>详细用法请参考本站 [示例1](https://gitee.com/dexterleslie/demonstration/tree/main/demo-spring-boot/demo-spring-boot-openfeign-client)
>
>详细用法请参考本站 [示例2](https://gitee.com/dexterleslie/demonstration/tree/master/spring-cloud/spring-cloud-feign-demo)

- 非 `HTTP 200` 错误处理

  参考本站 [链接](/future/README.html#引用) 引用 `future-common` 依赖

  `Feign` 配置引用 `future-common` 依赖中的 `CustomizeErrorDecoder`

  ```java
  @Configuration
  @EnableFeignClients(
          clients = {
                  ApiFeign.class
          }
  )
  public class FeignConfiguration {
          /**
           * openfeign支持自动检查并抛出业务异常不需要编写代码判断errorCode是否不等于0
           *
           * @return
           */
          @Bean
          ErrorDecoder errorDecoder() {
                  return new CustomizeErrorDecoder();
          }
  }
  ```

- `HTTP 200` 时业务异常错误处理

  ```java
  @Test
  public void testHttp200() throws BusinessException {
      ObjectResponse<String> response = this.testSupportApiFeign.testHttp200();
      Assertions.assertEquals(ErrorCodeConstant.ErrorCodeCommon, response.getErrorCode());
      Assertions.assertEquals("测试异常", response.getErrorMessage());
      Assertions.assertNull(response.getData());
      try {
          FeignUtil.throwBizExceptionIfResponseFailed(response);
          Assertions.fail();
      } catch (BusinessException ex) {
          Assertions.assertEquals(ErrorCodeConstant.ErrorCodeCommon, ex.getErrorCode());
          Assertions.assertEquals("测试异常", ex.getErrorMessage());
          Assertions.assertNull(ex.getData());
      }
  }
  ```

  - 调用 `FeignUtil.throwBizExceptionIfResponseFailed(response);` 判断 `HTTP 200` 响应是否有业务异常。

  

### 自定义 fallback

> todo



### 注意提醒

>提示：定义 `Feign` 方法时需要 `throws BusinessException`，否则在抛出 `BusinessException` 时会导致抛出未定义抛出异常错误。
>
>详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-spring-boot/demo-spring-boot-openfeign-client)

```java
package com.future.demo;

import com.future.common.exception.BusinessException;
import com.future.common.http.ObjectResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(
        contextId = "testSupportApiFeign",
        value = "app-test-service",
        path = "/api/v1")
public interface TestSupportApiFeign {

    @GetMapping("test401Error")
    ObjectResponse<String> test401Error() throws BusinessException;

    @GetMapping("testHttp200")
    ObjectResponse<String> testHttp200() throws BusinessException;
}

```

- 如上面的 `test401Error()` 和 `testHttp200()` 方法需要定义 `throws BusinessException`



### 性能测试

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/spring-cloud/spring-cloud-feign-demo) 协助测试。

测试环境：`Hypervisor:VMware ESXi, 7.0.3, 20328353`、`Model:PowerEdge R740xd`、`Processor Type:Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`、`Provider` 主机 `8C8G`、`Consumer` 主机 `8C8G`、其他主机资源充足。

编译镜像

```sh
./build.sh && ./push.sh
```

复制应用部署文件

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

启动应用

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试应用是否正常运行

```sh
curl http://192.168.1.185/api/v1/external/product/testOpenFeignPerfAssist
```

测试

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185/api/v1/external/product/testOpenFeignPerfAssist
Running 30s test @ http://192.168.1.185/api/v1/external/product/testOpenFeignPerfAssist
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   397.97ms  262.42ms   7.54s    97.81%
    Req/Sec   678.82    177.50     2.33k    77.23%
  Latency Distribution
     50%  373.79ms
     75%  390.03ms
     90%  408.31ms
     99%    1.40s 
  161957 requests in 30.09s, 42.78MB read
Requests/sec:   5382.03
Transfer/sec:      1.42MB
```

查看 `Prometheus` 监控：http://192.168.1.17:3000/

销毁应用

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```


