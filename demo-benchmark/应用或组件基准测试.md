# 应用或组件基准测试



## 基于`xxl-job`分片广播特性实施分布式测试

> 注意：方案太不专业，使用 wrk+OpenResty 反向代理多个 SpringBoot 应用的方式。
>
> 详细用法请参考本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/master/demo-mysql-n-mariadb/demo-sharding-jdbc-benchmark)



## 基准测试单个`SpringBoot`应用

>基准测试单个 `SpringBoot` 应用在 `8C8G` 内存的 `JVM` 中的性能如何。

### 测试条件

宿主机：`Hypervisor:	VMware ESXi, 7.0.3, 20328353`、`型号:	PowerEdge R740xd`、`处理器类型:	Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`



### 测试过程

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-benchmark/demo-spring-boot-benchmark) 协助测试。

示例中 `inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081
```

编译镜像

```sh
./build.sh && ./push.sh
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.11:8080/
Running 1m test @ http://192.168.1.11:8080/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    54.17ms   33.53ms   1.94s    99.74%
    Req/Sec     9.60k     1.06k   13.03k    69.82%
  Latency Distribution
     50%   52.53ms
     75%   58.08ms
     90%   63.38ms
     99%   74.09ms
  4575800 requests in 1.00m, 0.90GB read
Requests/sec:  76207.38
Transfer/sec:     15.33MB
```

- `http://192.168.1.11:8080/` 为其中一个 `SpringBoot` 测试目标的地址。

查看 `Prometheus` 监控：http://192.168.1.17:3000/



### 测试结果

结论：

- `wrk` 使用较少的 `cpu` 资源即可产生很高的压力。



## 基准测试同一台主机内两个`SpringBoot`应用

>基准测试两个 `SpringBoot` 应用在同一台 `32C16G` 内存的主机中是否更加充分利用 `CPU` 资源。

### 测试条件

宿主机：`Hypervisor:	VMware ESXi, 7.0.3, 20328353`、`型号:	PowerEdge R740xd`、`处理器类型:	Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`

### 测试过程

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-benchmark/demo-spring-boot-benchmark) 协助测试。

先测试一个 `SpringBoot` 情况，示例中 `inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081
```

编译镜像

```sh
./build.sh && ./push.sh
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    36.23ms    9.95ms 248.25ms   59.70%
    Req/Sec    14.19k     1.89k   54.56k    70.92%
  Latency Distribution
     50%   33.47ms
     75%   46.33ms
     90%   50.50ms
     99%   57.81ms
  6767966 requests in 1.00m, 1.75GB read
Requests/sec: 112616.64
Transfer/sec:     29.75MB
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

再测试两个 `SpringBoot` 情况，`inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081 server_port2=8082 actuator_port2=8083
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    40.92ms   56.61ms 929.57ms   94.69%
    Req/Sec    16.83k     3.27k   48.29k    93.68%
  Latency Distribution
     50%   27.49ms
     75%   34.99ms
     90%   49.40ms
     99%  339.58ms
  7880477 requests in 1.00m, 2.03GB read
Requests/sec: 131133.88
Transfer/sec:     34.64MB
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

查看 `Prometheus` 监控：http://192.168.1.17:3000/



### 测试结果

结论：

- 两个 `SpringBoot` 应用也不能够更加充分利用`32`核 `CPU`。
- 两个 `SpringBoot` 应用 `QPS` 比单个 `SpringBoot` 应用稍高。



## 基准测试单个`OpenResty`

>提示：生产环境是一个 `OpenResty` 反向代理多个 `SpringBoot` 应用，所以不关心这个场景的性能。

### 测试条件

宿主机：

- VMware ESXi, 7.0.3, 20328353
- CPU 类型 Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz
- 网卡类型 Intel(R) Ethernet Controller X540-AT2 with 1 Gbit/s

被基准测试 OpenResty 主机：

- CentOS Stream release 8
- 4C4G

压力主机：

- CentOS Stream release 8
- CPU 和内存资源充足



### 测试过程

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-benchmark/demo-openresty-benchmark) 协助测试。

编译镜像

```sh
./build.sh && ./push.sh
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c2048 -d30s --latency --timeout 60 http://192.168.1.185
Running 30s test @ http://192.168.1.185
  8 threads and 2048 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    68.23ms  479.49ms   7.09s    97.91%
    Req/Sec    30.00k     5.35k   88.95k    88.42%
  Latency Distribution
     50%    8.33ms
     75%    8.70ms
     90%    9.20ms
     99%    2.48s 
  7168200 requests in 30.10s, 1.74GB read
Requests/sec: 238158.29
Transfer/sec:     59.28MB
```

查看 `Prometheus` 监控：http://192.168.1.17:3000/



### 测试结果

结论：

- 未经过优化单机的 OpenResty 并发能力达到 238158 QPS。
- OpenResty 会自动充分利用多核 CPU 资源。



## 基准测试`OpenResty`反向代理多个`OpenResty`

>提示：生产环境是一个 `OpenResty` 反向代理多个 `SpringBoot` 应用，所以不关心这个场景的性能。

### 测试条件

宿主机：

- VMware ESXi, 7.0.3, 20328353
- CPU 类型 Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz
- 网卡类型 Intel(R) Ethernet Controller X540-AT2 with 1 Gbit/s

一台反向代理 OpenResty Master 主机：

- CentOS Stream release 8
- 12C4G

三台被反向代理 OpenResty Slave 主机：

- CentOS Stream release 8
- 4C4G

压力主机：

- CentOS Stream release 8
- CPU 和内存资源充足



### 测试过程

内核参数文件描述符限制调优（在所有主机中）：参考 <a href="/linux/README.html#设置" target="_blank">链接</a>

在反向代理 OpenResty Master 主机中使用 docker compose 运行 [示例](https://gitee.com/dexterleslie/demonstration/tree/master/demo-benchmark/demo-openresty-reverseproxy-benchmark-master)

- 修改 nginx.conf

  ```
  upstream backend {
      # server 192.168.1.x:80;
      server 192.168.1.188;
      server 192.168.1.189;
      server 192.168.1.191;
  }
  ```

  - server 192.168.1.x 分别为三台被反向代理 OpenResty Slave 主机

- 启动 OpenResty Master

  ```bash
  docker compose up -d
  ```

  

在三台被反向代理 OpenResty Slave 主机中使用 docker compose 运行 [示例](https://gitee.com/dexterleslie/demonstration/tree/master/demo-benchmark/demo-openresty-reverseproxy-benchmark-slave)

```bash
docker compose up -d
```



#### 测试单台 Slave QPS

在压力主机中运行 wrk

```bash
$ wrk -t8 -c8192 -d15s --latency --timeout 30 http://192.168.1.187
Running 15s test @ http://192.168.1.187
  8 threads and 8192 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   116.76ms  606.26ms   8.07s    97.05%
    Req/Sec    23.11k     5.69k   44.32k    74.08%
  Latency Distribution
     50%   25.75ms
     75%   29.38ms
     90%   33.01ms
     99%    3.45s 
  2759171 requests in 15.09s, 773.62MB read
Requests/sec: 182870.02
Transfer/sec:     51.27MB
```



#### 测试 Master 整体 QPS

在压力主机中运行 wrk

```bash
wrk -t8 -c8192 -d15s --latency --timeout 30 http://192.168.1.185
Running 15s test @ http://192.168.1.185
  8 threads and 8192 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    34.02ms   90.68ms   3.10s    98.36%
    Req/Sec    40.47k     2.88k   48.32k    80.23%
  Latency Distribution
     50%   23.84ms
     75%   29.43ms
     90%   33.95ms
     99%  414.70ms
  4828907 requests in 15.09s, 1.43GB read
Requests/sec: 319997.55
Transfer/sec:     96.74MB
```



### 测试结果

结论：

- 单台反向代理主机 OpenResty Master CPU 等配置需要很高才能够拖动并发挥出其它三台被反响代理的 OpenResty Slave 主机。
- 单台反向代理主机 OpenResty Master 代理三台被反向代理的 OpenResty Slave 主机总体 QPS 还不如单独一台 OpenResty Master Standalone QPS 性能。



## 基准测试`OpenResty`反向代理`SpringBoot`应用（纵向扩展`scale-up`）

### 测试条件

宿主机：`Hypervisor:	VMware ESXi, 7.0.3, 20328353`、`型号:	PowerEdge R740xd`、`处理器类型:	Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`



### 测试过程

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-benchmark/demo-spring-boot-benchmark) 协助测试。

示例中 `inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081
```

`SpringBoot` 主机调整为 `8C8G`

编译镜像

```sh
./build.sh && ./push.sh
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    60.78ms   91.86ms   3.38s    99.43%
    Req/Sec     9.23k     1.08k   14.66k    74.02%
  Latency Distribution
     50%   55.12ms
     75%   61.28ms
     90%   68.08ms
     99%   88.97ms
  4407185 requests in 1.00m, 1.14GB read
Requests/sec:  73342.55
Transfer/sec:     19.37MB
```

`SpringBoot` 主机调整为 `32C16G`

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    38.18ms   27.14ms   1.83s    99.29%
    Req/Sec    13.67k     1.40k   22.36k    74.74%
  Latency Distribution
     50%   36.63ms
     75%   42.68ms
     90%   46.29ms
     99%   60.65ms
  6525137 requests in 1.00m, 1.68GB read
Requests/sec: 108570.44
Transfer/sec:     28.68MB
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

查看 `Prometheus` 监控：http://192.168.1.17:3000/



### 测试结果

结论：

- `SpringBoot` 服务实例 `scale-up` 会增加 `QPS`，但不是线性增加的。



## 基准测试`OpenResty`反向代理多个`SpringBoot`应用（横向扩展`scale-out`）

### 测试条件

宿主机：`Hypervisor:	VMware ESXi, 7.0.3, 20328353`、`型号:	PowerEdge R740xd`、`处理器类型:	Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz`



### 测试过程

使用本站 [示例](https://gitee.com/dexterleslie/demonstration/tree/main/demo-benchmark/demo-spring-boot-benchmark) 协助测试。

`SpringBoot` 主机调整为 `8C8G`

示例中 `inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081
```

编译镜像

```sh
./build.sh && ./push.sh
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    61.58ms    9.93ms   1.09s    83.83%
    Req/Sec     8.35k   792.89    20.78k    70.00%
  Latency Distribution
     50%   61.06ms
     75%   66.25ms
     90%   71.03ms
     99%   80.89ms
  3984396 requests in 1.00m, 1.03GB read
Requests/sec:  66323.62
Transfer/sec:     17.52MB
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

示例中 `inventory.ini [api]` 修改如下：

```ini
[api]
192.168.1.11 java_opts=-Xmx4g server_port=8080 actuator_port=8081
192.168.1.15 java_opts=-Xmx4g server_port=8080 actuator_port=8081
```

复制 `Anisble` 配置

```sh
ansible-playbook playbook-deployer-config.yml --inventory inventory.ini
```

运行测试目标

```sh
ansible-playbook playbook-service-start.yml --inventory inventory.ini
```

测试

```sh
$ wrk -t8 -c4096 -d60s --latency --timeout 60 http://192.168.1.185/
Running 1m test @ http://192.168.1.185/
  8 threads and 4096 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    38.22ms   44.31ms 994.84ms   96.42%
    Req/Sec    16.14k     4.08k   27.19k    77.38%
  Latency Distribution
     50%   30.32ms
     75%   48.93ms
     90%   56.50ms
     99%  290.56ms
  7588025 requests in 1.00m, 1.96GB read
Requests/sec: 126274.61
Transfer/sec:     33.36MB
```

销毁测试目标

```sh
ansible-playbook playbook-service-destroy.yml --inventory inventory.ini
```

查看 `Prometheus` 监控：http://192.168.1.17:3000/



### 测试结果

结论：

- 添加更多的 `SpringBoot` 应用节点 `QPS` 会增加的。

